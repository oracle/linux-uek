# SPDX-License-Identifier: GPL-2.0-only
# ===========================================================================
# Module final link and CTF generation
# ===========================================================================
# 1) compile all <module>.mod.c files
# 2) for external modules, generate CTF for the module (there is an extra,
#    externally-invoked target that does this for the entire kernel but does
#    not invoke the rst of the module-building process)
# 3) final link of the module to a <module.ko> file

# We need secondary expansion for 'module-ctfs-modular-prereq', below.

.SECONDEXPANSION:

PHONY := __modfinal
__modfinal:

include include/config/auto.conf
include $(srctree)/scripts/Kbuild.include

# for c_flags
include $(srctree)/scripts/Makefile.lib

# find all modules listed in modules.order
modules := $(sort $(shell cat $(MODORDER)))

__modfinal: $(modules)
	@:

# modname and part-of-module are set to make c_flags define proper module flags
modname = $(notdir $(@:.mod.o=))
part-of-module = y

quiet_cmd_cc_o_c = CC [M]  $@
      cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<

%.mod.o: %.mod.c FORCE
	$(call if_changed_dep,cc_o_c)

# Generate CTF for the entire kernel, or for the module alone if this is a
# build of an external module.

# These are overridden below.
module-ctfs-modular-prereq =
module-ctfs-modular =
separate-ctf :=
module-ctf-flags =
cmd_touch_ctf =
ctf-dir = ///.nonexistent
cmd-touch-ctf = @:

ifdef CONFIG_CTF

# This is quite tricky.  If called for non-external-modules, the CTF machinery
# needs to be told about all the built-in objects as well as all the external
# modules -- but Makefile.modfinal only knows about the latter.  So the toplevel
# makefile emits the names of the built-in objects into a temporary file, which
# is then catted and its contents used as prerequisites by this rule.
#
# We write the names of the object files to be scanned for CTF content into a
# file, then use that, to avoid hitting command-line length limits.  Module
# names can have all modules not named in the CTF_FILELIST filtered out:
# this requires a bit of fiddling because the toolchain CTF splits the CTF into
# separate files with names derived from that of the module, and we have to
# transform the names back before filtering, then re-transform them again.

ifdef CONFIG_CTF_USING_BINUTILS
CTF_ARCHIVE := scripts/ctf/ctfarchive
CTF_ARCHIVE_STANDALONE := :
else
CTF_ARCHIVE := scripts/ctf/dwarf2ctf
CTF_ARCHIVE_STANDALONE := scripts/ctf/dwarf2ctf
endif

ifeq ($(KBUILD_EXTMOD),)
ifdef CONFIG_CTF_USING_BINUTILS
separate-ctf := t
module-ctf-flags := --remove-section .ctf
ctf-modules-full := $(shell find . -name '*.ko.ctf' -print | sed 's,\.ctf$$,,')
else
ctf-modules-full := $(shell find . -name '*.ko' -print)
endif
ifeq ($(CTF_FILELIST),)
ctf-modules-reduced := $(ctf-modules-full)
else
ctf-modules-reduced := $(filter $(shell cat $(CTF_FILELIST)),$(ctf-modules-full))
endif
ifdef CONFIG_CTF_USING_BINUTILS
ctf-modules := $(addsuffix .ctf,$(ctf-modules-reduced))
else
ctf-modules := $(ctf-modules-reduced)
endif
ctf-dir :=
ctf-dir-mk :=
quiet_cmd_ctf = CTFA
      cmd_ctf = $(CTF_ARCHIVE) $@ $(srctree) objects.builtin modules_thick.builtin $(srctree)/scripts/ctf/member.blacklist $(ctf-filelist)
ctf-builtins := objects.builtin
ctf-builtins-prereq := $(ctf-builtins)
ctf-filelist := .ctf.filelist
ctf-filelist-raw := .ctf.filelist.raw
ctf-stamp :=

else
ctf-dir := $(KBUILD_EXTMOD)/.ctf
ctf-dir-mk := $(ctf-dir)
quiet_cmd_ctf = CTF
      cmd_ctf = $(CTF_ARCHIVE_STANDALONE) $(ctf-dir) -e $(ctf-filelist)
ctf-builtins := ////.no-builtins
ctf-builtins-prereq :=
ctf-modules := $(modules:.ko=.o)
ctf-filelist := $(ctf-dir)/$(notdir $(M)-extmod).ctf.filelist
ctf-filelist-raw := $(ctf-dir)/$(notdir $(M)-extmod).ctf.filelist.raw
ctf-stamp = $(ctf-dir)/$(notdir $(M)-extmod).stamp

# All the modules' CTF depends on the stamp file.

all-module-ctfs = $(addprefix $(ctf-dir)/,$(notdir $(modules:.ko=.mod.ctf)))
$(all-module-ctfs): $(ctf-stamp)

endif

# Split a list up like shell xargs does.
define xargs =
$(1) $(wordlist 1,1024,$(2))
$(if $(word 1025,$(2)),$(call xargs,$(1),$(wordlist 1025,$(words $(2)),$(2))))
endef

$(ctf-filelist-raw): $(ctf-builtins-prereq) $(ctf-modules)
	@rm -f $(ctf-filelist-raw);
	@if [[ -n "$(ctf-dir-mk)" ]]; then \
		mkdir -p "$(ctf-dir-mk)"; \
	fi
	$(call xargs,@printf "%s\n" >> $(ctf-filelist-raw),$^)
	@touch $(ctf-filelist-raw)

$(ctf-filelist): $(ctf-filelist-raw)
	@rm -f $(ctf-filelist);
	@cat $(ctf-filelist-raw) | while read -r obj; do \
		case $$obj in \
		$(ctf-builtins)) cat $$obj >> $(ctf-filelist);; \
		*.a) ar t $$obj > $(ctf-filelist);; \
		*.builtin) cat $$obj >> $(ctf-filelist);; \
		*) echo "$$obj" >> $(ctf-filelist);; \
		esac; \
	done
	@touch $(ctf-filelist)

ifeq ($(KBUILD_EXTMOD),)
# The CTF depends on the output CTF file list, and that depends
# on the .ko files for the modules.  Any file ending in .ctfa
# will do.
$(filter %.ctfa,$(MAKECMDGOALS)): %.ctfa: $(ctf-filelist)
	$(call if_changed,ctf)
else

# If libctf is in use, the toolchain has already added everything we need to
# standalone object files, and we don't need to do anything.
ifndef CONFIG_CTF_USING_BINUTILS

# The CTF depends on the output CTF file list, and that depends
# on the .o files for the modules
$(ctf-stamp): $(ctf-filelist)
	$(call if_changed,ctf)
	@shopt -s nullglob; \
	for name in $(ctf-dir)/*.ctf.new; do \
		$(srctree)/scripts/move-if-change $$name $${name%.new}; \
	done; \
	touch $(ctf-stamp)

# Expands to the names of the CTF files to be incorporated into this module.
# The former is used in prerequisite lists, thanks to secondary expansion.

module-ctfs-modular-prereq = $$(addprefix $(ctf-dir)/,$$(notdir $$*.mod.ctf))
module-ctfs-modular = $(addprefix $(ctf-dir)/,$(notdir $*.mod.ctf))

# Expands to the name of a CTF file, given a target of a module name given to
# one of the link rules below.

ctf-module-name = $(addprefix $(ctf-dir)/,$(notdir $(basename $@)).mod.ctf)

# An objcopy --add-section argument to add the CTF section to a standalone
# module.

module-ctf-flags = --add-section .ctf=$(ctf-module-name)

# We have to put content in our dummy no-CTF files because --add-section
# in binutils 2.20 silently fails if asked to add an empty file as a section.

cmd_touch_ctf = @for name in $(filter $(ctf-dir)/%,$(module-ctfs-modular)); do \
		    test -f $$name || dd if=/dev/zero of=$$name bs=1 count=1 2>/dev/null; \
		done

endif           # CONFIG_CTF_USING_BINUTILS

endif		# KBUILD_EXTMOD

endif		# !CONFIG_CTF

ARCH_POSTLINK := $(wildcard $(srctree)/arch/$(SRCARCH)/Makefile.postlink)

quiet_cmd_ld_ko_o = LD [M]  $@
      cmd_ld_ko_o =                                                     \
	$(LD) -r $(KBUILD_LDFLAGS)					\
		$(KBUILD_LDFLAGS_MODULE) $(LDFLAGS_MODULE)		\
		$(addprefix -T , $(KBUILD_LDS_MODULE))			\
                 $(LDFLAGS_$(modname)) -o $@.tmp            		\
		-o $@.tmp $(patsubst $(ctf-dir)/%,,$(filter %.o, $^)) && \
	$(if $(separate-ctf), $(OBJCOPY) --only-section=.ctf $@.tmp $@.ctf, true) && \
        $(OBJCOPY) $(module-ctf-flags) $@.tmp $@ && rm -f $@.tmp ;	\
	$(if $(ARCH_POSTLINK), $(MAKE) -f $(ARCH_POSTLINK) $@, true)

quiet_cmd_btf_ko = BTF [M] $@
      cmd_btf_ko =							\
	  if [ -f vmlinux ]; then					\
		LLVM_OBJCOPY=$(OBJCOPY) $(PAHOLE) -J --btf_base vmlinux $@; \
	  else								\
		printf "Skipping BTF generation for %s due to unavailability of vmlinux\n" $@ 1>&2; \
	  fi;

# Find any prerequisites that are newer than target or that do not exist.
# (This is not true for now; $? should contain any non-existent prerequisites,
# but it does not work as expected when .SECONDARY is present. This seems a bug
# of GNU Make.)
# PHONY targets skipped in both cases.
newer-prereqs = $(filter-out $(PHONY),$?)

# Same as newer-prereqs, but allows to exclude specified extra dependencies
newer_prereqs_except = $(filter-out $(PHONY) $(1),$?)

# Same as if_changed, but allows to exclude specified extra dependencies
if_changed_except = $(if $(call newer_prereqs_except,$(2))$(cmd-check),      \
	$(cmd);                                                              \
	printf '%s\n' 'cmd_$@ := $(make-cmd)' > $(dot-target).cmd, @:)

# Re-generate module BTFs if either module's .ko or vmlinux changed
$(modules): %.ko: %.o %.mod.o $(KBUILD_LDS_MODULE) $(module-ctfs-modular-prereq) $(ifneq ($(KBUILD_EXTMOD),),vmlinux) FORCE
	$(call cmd_touch_ctf)
	+$(call if_changed_except,ld_ko_o,vmlinux)
ifdef CONFIG_DEBUG_INFO_BTF_MODULES
	+$(if $(newer-prereqs),$(call cmd,btf_ko))
endif

targets += $(modules) $(modules:.ko=.mod.o)

# Add FORCE to the prequisites of a target to force it to be always rebuilt.
# ---------------------------------------------------------------------------

PHONY += FORCE
FORCE:

# Read all saved command lines and dependencies for the $(targets) we
# may be building above, using $(if_changed{,_dep}). As an
# optimization, we don't need to read them if the target does not
# exist, we will rebuild anyway in that case.

existing-targets := $(wildcard $(sort $(targets)))

-include $(foreach f,$(existing-targets),$(dir $(f)).$(notdir $(f)).cmd)

.PHONY: $(PHONY)
