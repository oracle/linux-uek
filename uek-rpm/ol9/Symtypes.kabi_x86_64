BUG_func void BUG_func ( void )
E#ARG_PTR_TO_BTF_ID ( 0 ) + 13
E#ARG_PTR_TO_CTX ( 0 ) + 8
E#ARG_PTR_TO_MAP_VALUE ( 0 ) + 3
E#ARG_PTR_TO_MEM ( 0 ) + 4
E#ARG_PTR_TO_SOCKET ( 0 ) + 12
E#ARG_PTR_TO_STACK ( 0 ) + 19
E#AUDIT_NTP_NVALS 6
E#BLKG_IOSTAT_NR 3
E#BPF_KPTR_PERCPU ( 1 << 4 )
E#BPF_KPTR_REF ( 1 << 3 )
E#BPF_KPTR_UNREF ( 1 << 2 )
E#BPF_LIST_HEAD ( 1 << 5 )
E#BPF_LIST_NODE ( 1 << 6 )
E#BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED 19
E#BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE_DEPRECATED ( E#BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED ) + 2
E#BPF_RB_NODE ( 1 << 8 )
E#BPF_RB_ROOT ( 1 << 7 )
E#BPF_TRAMP_MAX 3
E#CGROUP_LSM_START ( 0 ) + 28
E#CGROUP_SUBSYS_COUNT 14
E#CPUHP_AP_ONLINE_DYN ( E#CPUHP_BP_PREPARE_DYN + 20 ) + 108
E#CPUHP_BP_PREPARE_DYN ( 0 ) + 65
E#CPU_MAX_IDLE_TYPES ( 0 ) + 3
E#DEVICE_COUNT_RESOURCE E#PCI_NUM_RESOURCES
E#FLOW_ACTION_HW_STATS_DELAYED ( ( ( ( 1UL ) ) ) << ( E#FLOW_ACTION_HW_STATS_DELAYED_BIT ) )
E#FLOW_ACTION_HW_STATS_DELAYED_BIT 1
E#FLOW_ACTION_HW_STATS_DISABLED_BIT 2
E#FLOW_ACTION_HW_STATS_IMMEDIATE ( ( ( ( 1UL ) ) ) << ( E#FLOW_ACTION_HW_STATS_IMMEDIATE_BIT ) )
E#FLOW_ACTION_HW_STATS_IMMEDIATE_BIT 0
E#FLOW_ACTION_HW_STATS_NUM_BITS 3
E#FLOW_DISSECTOR_KEY_MAX 33
E#GRE_CT_MAX 2
E#HCTX_MAX_TYPES 3
E#HRTIMER_MAX_CLOCK_BASES 8
E#IB_CQ_NEXT_COMP 1 << 1
E#IB_CQ_SOLICITED 1 << 0
E#IB_MGMT_MAD_DATA 232
E#IB_POLL_LAST_POOL_TYPE E#IB_POLL_UNBOUND_WORKQUEUE
E#IB_POLL_UNBOUND_WORKQUEUE 2
E#IB_UVERBS_GID_TYPE_IB 0
E#IB_UVERBS_GID_TYPE_ROCE_V1 1
E#IB_UVERBS_GID_TYPE_ROCE_V2 2
E#IB_UVERBS_QPT_DRIVER 0xFF
E#IB_UVERBS_QPT_RAW_PACKET 8
E#IB_UVERBS_QPT_RC 2
E#IB_UVERBS_QPT_UC ( 2 ) + 1
E#IB_UVERBS_QPT_UD ( 2 ) + 2
E#IB_UVERBS_QPT_XRC_INI ( 8 ) + 1
E#IB_UVERBS_QPT_XRC_TGT ( 8 ) + 2
E#IB_UVERBS_SRQT_BASIC 0
E#IB_UVERBS_SRQT_TM 2
E#IB_UVERBS_SRQT_XRC 1
E#IB_UVERBS_WC_ATOMIC_WRITE 9
E#IB_UVERBS_WC_BIND_MW 5
E#IB_UVERBS_WC_COMP_SWAP 3
E#IB_UVERBS_WC_FETCH_ADD 4
E#IB_UVERBS_WC_FLUSH 8
E#IB_UVERBS_WC_LOCAL_INV 6
E#IB_UVERBS_WC_RDMA_READ 2
E#IB_UVERBS_WC_RDMA_WRITE 1
E#IB_UVERBS_WC_SEND 0
E#IB_UVERBS_WC_TSO 7
E#IB_UVERBS_WQT_RQ 0
E#IB_UVERBS_WR_ATOMIC_CMP_AND_SWP 5
E#IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD 6
E#IB_UVERBS_WR_ATOMIC_WRITE 15
E#IB_UVERBS_WR_BIND_MW 8
E#IB_UVERBS_WR_FLUSH 14
E#IB_UVERBS_WR_LOCAL_INV 7
E#IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP 12
E#IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD 13
E#IB_UVERBS_WR_RDMA_READ 4
E#IB_UVERBS_WR_RDMA_READ_WITH_INV 11
E#IB_UVERBS_WR_RDMA_WRITE 0
E#IB_UVERBS_WR_RDMA_WRITE_WITH_IMM 1
E#IB_UVERBS_WR_SEND 2
E#IB_UVERBS_WR_SEND_WITH_IMM 3
E#IB_UVERBS_WR_SEND_WITH_INV 9
E#IB_UVERBS_WR_TSO 10
E#IORING_OP_LAST 58
E#IORING_REGISTER_LAST ( 30 ) + 1
E#IP_CT_DIR_MAX 2
E#IP_CT_DIR_ORIGINAL 0
E#IP_CT_DIR_REPLY 1
E#IP_CT_ESTABLISHED 0
E#IP_CT_IS_REPLY 3
E#IP_CT_RELATED 1
E#IP_TUNNEL_VTI_BIT ( 0U ) + 16
E#KMALLOC_NORMAL 0
E#KMALLOC_RANDOM_START E#KMALLOC_NORMAL
E#MAX_CGROUP_BPF_ATTACH_TYPE ( E#CGROUP_LSM_START + 10 - 1 ) + 1
E#MAX_NETNS_BPF_ATTACH_TYPE ( 0 ) + 2
E#MAX_ZONELISTS 2
E#MEMCG_NR_MEMORY_EVENTS 9
E#MEM_FIXED_SIZE ( ( ( ( 1UL ) ) ) << ( 10 + 8 ) )
E#MEM_RINGBUF ( ( ( ( 1UL ) ) ) << ( 2 + 8 ) )
E#MEM_UNINIT ( ( ( ( 1UL ) ) ) << ( 7 + 8 ) )
E#MEM_WRITE ( ( ( ( 1UL ) ) ) << ( 18 + 8 ) )
E#MIGRATE_PCPTYPES 3
E#MIGRATE_TYPES ( E#MIGRATE_PCPTYPES ) + 3
E#MOD_MEM_NUM_TYPES ( 0 ) + 7
E#ND_OPT_TARGET_LL_ADDR 2
E#NEIGH_VAR_LOCKTIME 13
E#NFPROTO_NUMPROTO ( 10 ) + 1
E#NF_CT_EXT_NUM 10
E#NF_INET_NUMHOOKS 5
E#NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT 27
E#NR_KMALLOC_TYPES ( E#KMALLOC_RANDOM_START + 15 ) + 4
E#NR_LRU_BASE 0
E#NR_LRU_LISTS ( 0 + 2 + 1 ) + 2
E#NR_MM_COUNTERS 4
E#NR_MM_STATS 4
E#NR_NODE_STATES ( E#N_NORMAL_MEMORY ) + 4
E#NR_PSI_AGGREGATORS ( 0 ) + 2
E#NR_PSI_RESOURCES 4
E#NR_PSI_STATES 8
E#NR_PSI_TASK_COUNTS 4
E#NR_STAT_GROUPS 4
E#NR_VMSCAN_THROTTLE 4
E#NR_VM_NODE_STAT_ITEMS ( E#WORKINGSET_RESTORE_BASE ) + 33
E#NR_VM_NUMA_EVENT_ITEMS 6
E#NR_VM_ZONE_STAT_ITEMS ( E#NR_ZONE_LRU_BASE ) + 11
E#NR_WB_STAT_ITEMS 4
E#NR_WMARK 4
E#NR_ZONE_LRU_BASE 1
E#NUM_NL80211_BANDS 6
E#NUM_NL80211_EXT_FEATURES ( E#NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT ) + 42
E#NUM_NL80211_IFTYPES 13
E#N_NORMAL_MEMORY 2
E#PCI_BRIDGE_RESOURCES ( E#PCI_IOV_RESOURCES + 6 - 1 ) + 1
E#PCI_IOV_RESOURCES ( E#PCI_STD_RESOURCES + 6 - 1 ) + 2
E#PCI_NUM_RESOURCES ( E#PCI_BRIDGE_RESOURCES + 4 - 1 ) + 1
E#PCI_STD_RESOURCES 0
E#PHY_INTERFACE_MODE_MAX 34
E#PIDTYPE_MAX 4
E#PTR_MAYBE_NULL ( ( ( ( 1UL ) ) ) << ( 0 + 8 ) )
E#PTR_TO_BTF_ID ( 0 ) + 16
E#PTR_TO_MAP_VALUE ( 0 ) + 4
E#PTR_TO_SOCKET ( 0 ) + 11
E#PTR_TO_SOCK_COMMON ( 0 ) + 12
E#PTR_TO_TCP_SOCK ( 0 ) + 13
E#PTR_TRUSTED ( ( ( ( 1UL ) ) ) << ( 12 + 8 ) )
E#RDMA_DRIVER_I40IW 9
E#REG_LIVE_READ32 0x1
E#REG_LIVE_READ64 0x2
E#RET_PTR_TO_BTF_ID 8
E#RET_PTR_TO_MAP_VALUE 2
E#RET_PTR_TO_MEM 6
E#RET_PTR_TO_SOCKET 3
E#RET_PTR_TO_SOCK_COMMON 5
E#RET_PTR_TO_TCP_SOCK 4
E#RPC_DISPLAY_MAX ( 0 ) + 6
E#RX_MAX 4
E#SAS_LINK_RATE_1_5_GBPS 8
E#SAS_LINK_RATE_3_0_GBPS 9
E#SAS_PROTOCOL_SATA 0x01
E#SAS_PROTOCOL_STP 0x04
E#SB_FREEZE_COMPLETE 4
E#SCTP_CONNTRACK_MAX 10
E#SDEV_EVT_LAST E#SDEV_EVT_POWER_ON_RESET_OCCURRED
E#SDEV_EVT_MAXBITS E#SDEV_EVT_LAST + 1
E#SDEV_EVT_POWER_ON_RESET_OCCURRED ( 1 ) + 7
E#SKB_EXT_NUM 4
E#TASK_COMM_LEN 16
E#TCP_CONNTRACK_TIMEOUT_MAX 14
E#UCOUNT_COUNTS 12
E#UCOUNT_RLIMIT_COUNTS 4
E#UDP_CT_MAX 2
E#UVERBS_API_ATTR_BKEY_LEN ( 1 << E#UVERBS_API_ATTR_KEY_BITS ) - 1
E#UVERBS_API_ATTR_KEY_BITS 6
E#VLAN_PROTO_NUM ( 0 ) + 2
E#WATCH_TYPE__NR 2
E#WLAN_KEY_LEN_WEP104 13
E#WORKINGSET_ACTIVATE_BASE ( E#WORKINGSET_REFAULT_BASE ) + 2
E#WORKINGSET_REFAULT_BASE ( E#NR_LRU_BASE ) + 10
E#WORKINGSET_RESTORE_BASE ( E#WORKINGSET_ACTIVATE_BASE ) + 2
E#XDP_RSS_L3_DYNHDR ( ( ( ( 1UL ) ) ) << ( 2 ) )
E#XDP_RSS_L3_IPV4 ( ( ( ( 1UL ) ) ) << ( 0 ) )
E#XDP_RSS_L3_IPV6 ( ( ( ( 1UL ) ) ) << ( 1 ) )
E#XDP_RSS_L4 ( ( ( ( 1UL ) ) ) << ( 3 ) )
E#XDP_RSS_L4_ICMP ( ( ( ( 1UL ) ) ) << ( 8 ) )
E#XDP_RSS_L4_IPSEC ( ( ( ( 1UL ) ) ) << ( 7 ) )
E#XDP_RSS_L4_SCTP ( ( ( ( 1UL ) ) ) << ( 6 ) )
E#XDP_RSS_L4_TCP ( ( ( ( 1UL ) ) ) << ( 4 ) )
E#XDP_RSS_L4_UDP ( ( ( ( 1UL ) ) ) << ( 5 ) )
E#XDP_RSS_TYPE_L4_IPV6_SCTP E#XDP_RSS_L3_IPV6 | E#XDP_RSS_L4 | E#XDP_RSS_L4_SCTP
E#XDP_RSS_TYPE_L4_IPV6_TCP E#XDP_RSS_L3_IPV6 | E#XDP_RSS_L4 | E#XDP_RSS_L4_TCP
E#XDP_RSS_TYPE_L4_IPV6_UDP E#XDP_RSS_L3_IPV6 | E#XDP_RSS_L4 | E#XDP_RSS_L4_UDP
E#XDP_RSS_TYPE_NONE 0
E#XFRM_POLICY_MAX 3
E#XPS_MAPS_MAX ( 0 ) + 2
E#__BPF_CGROUP_STORAGE_MAX 2
E#__BPF_TYPE_FLAG_MAX ( ( ( ( ( 1UL ) ) ) << ( 18 + 8 ) ) ) + 1
E#__BPF_TYPE_LAST_FLAG E#__BPF_TYPE_FLAG_MAX - 1
E#__CT_DCCP_MAX 10
E#__DEVLINK_PARAM_CMODE_MAX 3
E#__DEVLINK_RELOAD_ACTION_MAX 3
E#__DEVLINK_RELOAD_LIMIT_MAX 2
E#__DPLL_PIN_TYPE_MAX ( 1 ) + 5
E#__ETHTOOL_LINK_MODE_MASK_NBITS ( 102 ) + 1
E#__FSNOTIFY_PRIO_NUM ( 0 ) + 3
E#__GARP_APPLICATION_MAX 1
E#__ICMP6_MIB_MAX ( 0 ) + 7
E#__ICMP_MIB_MAX ( 0 ) + 30
E#__IPSTATS_MIB_MAX ( 0 ) + 38
E#__IPV4_DEVCONF_MAX ( 1 ) + 33
E#__IP_TUNNEL_FLAG_NUM ( E#IP_TUNNEL_VTI_BIT ) + 2
E#__LINUX_MIB_MAX ( 0 ) + 132
E#__LINUX_MIB_TLSMAX ( 0 ) + 13
E#__LINUX_MIB_XFRMMAX ( 0 ) + 31
E#__MACSEC_OFFLOAD_END ( 2 ) + 1
E#__MACSEC_VALIDATE_END ( 2 ) + 1
E#__MAX_BPF_REG ( 0 ) + 11
E#__MAX_XDP_MODE ( 2 ) + 1
E#__MPTCP_MIB_MAX ( 0 ) + 71
E#__MRP_APPLICATION_MAX 1
E#__ND_OPT_ARRAY_MAX ( 14 ) + 1
E#__NFSIOS_BYTESMAX ( 0 ) + 8
E#__NFSIOS_COUNTSMAX ( 0 ) + 27
E#__NL80211_AUTHTYPE_NUM 8
E#__NL80211_BSS_SELECT_ATTR_AFTER_LAST 4
E#__NL802154_CCA_ATTR_AFTER_LAST 7
E#__NL802154_CCA_OPT_ATTR_AFTER_LAST 2
E#__NL802154_SUPPORTED_BOOL_AFTER_LAST 4
E#__RTAX_MAX 18
E#__SCTP_MIB_MAX ( 0 ) + 34
E#__TCP_MIB_MAX ( 0 ) + 16
E#__UDP_MIB_MAX ( 0 ) + 10
I_BDEV s#block_device * I_BDEV ( s#inode * )
__SCT__cond_resched extern typeof ( __cond_resched ) __SCT__cond_resched
__SCT__might_resched extern typeof ( __cond_resched ) __SCT__might_resched
__SCT__preempt_schedule extern typeof ( preempt_schedule_thunk ) __SCT__preempt_schedule
__bitmap_weight unsigned int __bitmap_weight ( const unsigned long * , unsigned int )
__blk_alloc_disk s#gendisk * __blk_alloc_disk ( s#queue_limits * , int , s#lock_class_key * )
__blk_mq_alloc_disk s#gendisk * __blk_mq_alloc_disk ( s#blk_mq_tag_set * , s#queue_limits * , void * , s#lock_class_key * )
__block_write_full_folio int __block_write_full_folio ( s#inode * , s#folio * , t#get_block_t * , s#writeback_control * )
__break_lease int __break_lease ( s#inode * , unsigned int , unsigned int )
__check_object_size extern void __check_object_size ( const void * , unsigned long , t#bool )
__const_udelay extern void __const_udelay ( unsigned long )
__cpu_active_mask extern s#cpumask __cpu_active_mask
__cpu_online_mask extern s#cpumask __cpu_online_mask
__cpu_possible_mask extern s#cpumask __cpu_possible_mask
__cpu_present_mask extern s#cpumask __cpu_present_mask
__cpuhp_remove_state void __cpuhp_remove_state ( e#cpuhp_state , t#bool )
__cpuhp_setup_state int __cpuhp_setup_state ( e#cpuhp_state , const char * , t#bool , int ( * ) ( unsigned int ) , int ( * ) ( unsigned int ) , t#bool )
__fentry__ extern void __fentry__ ( void )
__flush_workqueue extern void __flush_workqueue ( s#workqueue_struct * )
__folio_lock void __folio_lock ( s#folio * )
__folio_put void __folio_put ( s#folio * )
__fortify_panic void __fortify_panic ( const t#u8 , const t#size_t , const t#size_t )
__free_pages extern void __free_pages ( s#page * , unsigned int )
__generic_file_write_iter extern t#ssize_t __generic_file_write_iter ( s#kiocb * , s#iov_iter * )
__init_rwsem extern void __init_rwsem ( s#rw_semaphore * , const char * , s#lock_class_key * )
__init_swait_queue_head extern void __init_swait_queue_head ( s#swait_queue_head * , const char * , s#lock_class_key * )
__init_waitqueue_head extern void __init_waitqueue_head ( s#wait_queue_head * , const char * , s#lock_class_key * )
__insert_inode_hash extern void __insert_inode_hash ( s#inode * , unsigned long )
__kmalloc_cache_noprof void * __kmalloc_cache_noprof ( s#kmem_cache * , t#gfp_t , t#size_t )
__kmalloc_large_node_noprof void * __kmalloc_large_node_noprof ( t#size_t , t#gfp_t , int )
__kmalloc_large_noprof void * __kmalloc_large_noprof ( t#size_t , t#gfp_t )
__kmalloc_noprof void * __kmalloc_noprof ( t#size_t , t#gfp_t )
__kmem_cache_create_args s#kmem_cache * __kmem_cache_create_args ( const char * , unsigned int , s#kmem_cache_args * , t#slab_flags_t )
__list_add_valid_or_report extern t#bool __list_add_valid_or_report ( s#list_head * , s#list_head * , s#list_head * )
__list_del_entry_valid_or_report extern t#bool __list_del_entry_valid_or_report ( s#list_head * )
__mark_inode_dirty extern void __mark_inode_dirty ( s#inode * , int )
__mmap_lock_do_trace_acquire_returned void __mmap_lock_do_trace_acquire_returned ( s#mm_struct * , t#bool , t#bool )
__mmap_lock_do_trace_released void __mmap_lock_do_trace_released ( s#mm_struct * , t#bool )
__mmap_lock_do_trace_start_locking void __mmap_lock_do_trace_start_locking ( s#mm_struct * , t#bool )
__module_get extern void __module_get ( s#module * )
__msecs_to_jiffies extern unsigned long __msecs_to_jiffies ( const unsigned int )
__mutex_init extern void __mutex_init ( s#mutex * , const char * , s#lock_class_key * )
__num_online_cpus extern t#atomic_t __num_online_cpus
__pci_register_driver int __attribute__ ( ( __warn_unused_result__ ) ) __pci_register_driver ( s#pci_driver * , s#module * , const char * )
__per_cpu_offset extern unsigned long __per_cpu_offset [ 8192 ]
__put_cred extern void __put_cred ( s#cred * )
__put_devmap_managed_folio_refs t#bool __put_devmap_managed_folio_refs ( s#folio * , int )
__register_blkdev int __register_blkdev ( unsigned int , const char * , void ( * ) ( t#dev_t ) )
__register_chrdev extern int __register_chrdev ( unsigned int , unsigned int , unsigned int , const char * , const s#file_operations * )
__remove_inode_hash extern void __remove_inode_hash ( s#inode * )
__stack_chk_fail extern void __stack_chk_fail ( void )
__tasklet_hi_schedule extern void __tasklet_hi_schedule ( s#tasklet_struct * )
__tracepoint_mmap_lock_acquire_returned extern s#tracepoint __tracepoint_mmap_lock_acquire_returned
__tracepoint_mmap_lock_released extern s#tracepoint __tracepoint_mmap_lock_released
__tracepoint_mmap_lock_start_locking extern s#tracepoint __tracepoint_mmap_lock_start_locking
__unregister_chrdev extern void __unregister_chrdev ( unsigned int , unsigned int , unsigned int , const char * )
__virt_addr_valid extern t#bool __virt_addr_valid ( unsigned long )
__vmalloc_noprof extern void * __vmalloc_noprof ( unsigned long , t#gfp_t )
__wake_up int __wake_up ( s#wait_queue_head * , unsigned int , int , void * )
__warn_printk extern __attribute__ ( ( __format__ ( printf , 1 , 2 ) ) ) void __warn_printk ( const char * , ... )
__x86_indirect_thunk_r10 extern t#retpoline_thunk_t __x86_indirect_thunk_r10
__x86_indirect_thunk_r12 extern t#retpoline_thunk_t __x86_indirect_thunk_r12
__x86_indirect_thunk_r13 extern t#retpoline_thunk_t __x86_indirect_thunk_r13
__x86_indirect_thunk_r14 extern t#retpoline_thunk_t __x86_indirect_thunk_r14
__x86_indirect_thunk_r15 extern t#retpoline_thunk_t __x86_indirect_thunk_r15
__x86_indirect_thunk_r8 extern t#retpoline_thunk_t __x86_indirect_thunk_r8
__x86_indirect_thunk_rax extern t#retpoline_thunk_t __x86_indirect_thunk_rax
__x86_indirect_thunk_rbp extern t#retpoline_thunk_t __x86_indirect_thunk_rbp
__x86_indirect_thunk_rbx extern t#retpoline_thunk_t __x86_indirect_thunk_rbx
__x86_indirect_thunk_rcx extern t#retpoline_thunk_t __x86_indirect_thunk_rcx
__x86_indirect_thunk_rdx extern t#retpoline_thunk_t __x86_indirect_thunk_rdx
__x86_return_thunk extern void __x86_return_thunk ( void )
_bin2bcd unsigned char _bin2bcd ( unsigned )
_copy_from_user extern __attribute__ ( ( __warn_unused_result__ ) ) unsigned long _copy_from_user ( void * , const void * , unsigned long )
_copy_to_user extern __attribute__ ( ( __warn_unused_result__ ) ) unsigned long _copy_to_user ( void * , const void * , unsigned long )
_dev_err __attribute__ ( ( __format__ ( printf , 2 , 3 ) ) ) __attribute__ ( ( __cold__ ) ) void _dev_err ( const s#device * , const char * , ... )
_dev_info __attribute__ ( ( __format__ ( printf , 2 , 3 ) ) ) __attribute__ ( ( __cold__ ) ) void _dev_info ( const s#device * , const char * , ... )
_dev_printk __attribute__ ( ( __format__ ( printf , 3 , 4 ) ) ) __attribute__ ( ( __cold__ ) ) void _dev_printk ( const char * , const s#device * , const char * , ... )
_dev_warn __attribute__ ( ( __format__ ( printf , 2 , 3 ) ) ) __attribute__ ( ( __cold__ ) ) void _dev_warn ( const s#device * , const char * , ... )
_find_first_and_bit extern unsigned long _find_first_and_bit ( const unsigned long * , const unsigned long * , unsigned long )
_find_first_bit extern unsigned long _find_first_bit ( const unsigned long * , unsigned long )
_find_next_bit unsigned long _find_next_bit ( const unsigned long * , unsigned long , unsigned long )
_printk __attribute__ ( ( __format__ ( printf , 1 , 2 ) ) ) __attribute__ ( ( __cold__ ) ) int _printk ( const char * , ... )
_raw_read_lock void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_read_lock ( t#rwlock_t * )
_raw_read_lock_irqsave unsigned long __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_read_lock_irqsave ( t#rwlock_t * )
_raw_read_unlock void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_read_unlock ( t#rwlock_t * )
_raw_read_unlock_irqrestore void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_read_unlock_irqrestore ( t#rwlock_t * , unsigned long )
_raw_spin_lock void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_spin_lock ( t#raw_spinlock_t * )
_raw_spin_lock_bh void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_spin_lock_bh ( t#raw_spinlock_t * )
_raw_spin_lock_irq void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_spin_lock_irq ( t#raw_spinlock_t * )
_raw_spin_lock_irqsave unsigned long __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_spin_lock_irqsave ( t#raw_spinlock_t * )
_raw_spin_unlock void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_spin_unlock ( t#raw_spinlock_t * )
_raw_spin_unlock_bh void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_spin_unlock_bh ( t#raw_spinlock_t * )
_raw_spin_unlock_irq void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_spin_unlock_irq ( t#raw_spinlock_t * )
_raw_spin_unlock_irqrestore void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_spin_unlock_irqrestore ( t#raw_spinlock_t * , unsigned long )
_raw_write_lock void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_write_lock ( t#rwlock_t * )
_raw_write_lock_irqsave unsigned long __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_write_lock_irqsave ( t#rwlock_t * )
_raw_write_unlock void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_write_unlock ( t#rwlock_t * )
_raw_write_unlock_irqrestore void __attribute__ ( ( __section__ ( ".spinlock.text" ) ) ) _raw_write_unlock_irqrestore ( t#rwlock_t * , unsigned long )
_totalram_pages extern t#atomic_long_t _totalram_pages
acfs_only_symbol void acfs_only_symbol ( char [ 1 ] )
add_timer extern void add_timer ( s#timer_list * )
add_wait_queue extern void add_wait_queue ( s#wait_queue_head * , s#wait_queue_entry * )
alloc_chrdev_region extern int alloc_chrdev_region ( t#dev_t * , unsigned , unsigned , const char * )
alloc_pages_noprof s#page * alloc_pages_noprof ( t#gfp_t , unsigned int )
alloc_workqueue __attribute__ ( ( __format__ ( printf , 1 , 4 ) ) ) s#workqueue_struct * alloc_workqueue ( const char * , unsigned int , int , ... )
autoremove_wake_function int autoremove_wake_function ( s#wait_queue_entry * , unsigned , int , void * )
bdev_end_io_acct void bdev_end_io_acct ( s#block_device * , e#req_op , unsigned int , unsigned long )
bdev_file_open_by_dev s#file * bdev_file_open_by_dev ( t#dev_t , t#blk_mode_t , void * , const s#blk_holder_ops * )
bdev_file_open_by_path s#file * bdev_file_open_by_path ( const char * , t#blk_mode_t , void * , const s#blk_holder_ops * )
bdev_fput void bdev_fput ( s#file * )
bdev_freeze int bdev_freeze ( s#block_device * )
bdev_start_io_acct unsigned long bdev_start_io_acct ( s#block_device * , e#req_op , unsigned long )
bdev_thaw int bdev_thaw ( s#block_device * )
bio_add_page int __attribute__ ( ( __warn_unused_result__ ) ) bio_add_page ( s#bio * , s#page * , unsigned , unsigned )
bio_alloc_bioset s#bio * bio_alloc_bioset ( s#block_device * , unsigned short , t#blk_opf_t , t#gfp_t , s#bio_set * )
bio_endio extern void bio_endio ( s#bio * )
bio_init void bio_init ( s#bio * , s#block_device * , s#bio_vec * , unsigned short , t#blk_opf_t )
bio_integrity_add_page int bio_integrity_add_page ( s#bio * , s#page * , unsigned int , unsigned int )
bio_integrity_alloc s#bio_integrity_payload * bio_integrity_alloc ( s#bio * , t#gfp_t , unsigned int )
bio_put extern void bio_put ( s#bio * )
blk_finish_plug extern void blk_finish_plug ( s#blk_plug * )
blk_mq_alloc_tag_set int blk_mq_alloc_tag_set ( s#blk_mq_tag_set * )
blk_mq_complete_request void blk_mq_complete_request ( s#request * )
blk_mq_end_request void blk_mq_end_request ( s#request * , t#blk_status_t )
blk_mq_free_tag_set void blk_mq_free_tag_set ( s#blk_mq_tag_set * )
blk_mq_kick_requeue_list void blk_mq_kick_requeue_list ( s#request_queue * )
blk_mq_map_queues void blk_mq_map_queues ( s#blk_mq_queue_map * )
blk_mq_pci_map_queues void blk_mq_pci_map_queues ( s#blk_mq_queue_map * , s#pci_dev * , int )
blk_mq_requeue_request void blk_mq_requeue_request ( s#request * , t#bool )
blk_mq_start_request void blk_mq_start_request ( s#request * )
blk_mq_start_stopped_hw_queues void blk_mq_start_stopped_hw_queues ( s#request_queue * , t#bool )
blk_mq_stop_hw_queues void blk_mq_stop_hw_queues ( s#request_queue * )
blk_mq_unique_tag t#u32 blk_mq_unique_tag ( s#request * )
blk_put_queue extern void blk_put_queue ( s#request_queue * )
blk_set_stacking_limits extern void blk_set_stacking_limits ( s#queue_limits * )
blk_stack_limits extern int blk_stack_limits ( s#queue_limits * , s#queue_limits * , t#sector_t )
blk_start_plug extern void blk_start_plug ( s#blk_plug * )
blkdev_issue_discard int blkdev_issue_discard ( s#block_device * , t#sector_t , t#sector_t , t#gfp_t )
block_invalidate_folio void block_invalidate_folio ( s#folio * , t#size_t , t#size_t )
block_write_begin int block_write_begin ( s#address_space * , t#loff_t , unsigned , s#folio * * , t#get_block_t * )
block_write_end int block_write_end ( s#file * , s#address_space * , t#loff_t , unsigned , unsigned , s#folio * , void * )
boot_cpu_data extern s#cpuinfo_x86 boot_cpu_data
bsg_job_done void bsg_job_done ( s#bsg_job * , int , unsigned int )
call_usermodehelper extern int call_usermodehelper ( const char * , char * * , char * * , int )
cancel_delayed_work_sync extern t#bool cancel_delayed_work_sync ( s#delayed_work * )
capable extern t#bool capable ( int )
cdev_add int cdev_add ( s#cdev * , t#dev_t , unsigned )
cdev_del void cdev_del ( s#cdev * )
cdev_init void cdev_init ( s#cdev * , const s#file_operations * )
check_zeroed_user extern __attribute__ ( ( __warn_unused_result__ ) ) int check_zeroed_user ( const void * , t#size_t )
clear_inode extern void clear_inode ( s#inode * )
clear_page_dirty_for_io t#bool clear_page_dirty_for_io ( s#page * )
close_fd extern int close_fd ( unsigned int )
complete extern void complete ( s#completion * )
const_pcpu_hot extern __attribute__ ( ( section ( ".data..percpu" "..shared_aligned" ) ) ) __typeof__ ( const s#pcpu_hot ) const_pcpu_hot
d_add extern void d_add ( s#dentry * , s#inode * )
d_alloc extern s#dentry * d_alloc ( s#dentry * , const s#qstr * )
d_drop extern void d_drop ( s#dentry * )
d_find_alias extern s#dentry * d_find_alias ( s#inode * )
d_instantiate extern void d_instantiate ( s#dentry * , s#inode * )
d_invalidate extern void d_invalidate ( s#dentry * )
d_lookup extern s#dentry * d_lookup ( const s#dentry * , const s#qstr * )
d_make_root extern s#dentry * d_make_root ( s#inode * )
d_move extern void d_move ( s#dentry * , s#dentry * )
d_obtain_alias extern s#dentry * d_obtain_alias ( s#inode * )
d_path extern char * d_path ( const s#path * , char * , int )
d_prune_aliases extern void d_prune_aliases ( s#inode * )
d_set_d_op extern void d_set_d_op ( s#dentry * , const s#dentry_operations * )
d_splice_alias extern s#dentry * d_splice_alias ( s#inode * , s#dentry * )
debugfs_create_dir s#dentry * debugfs_create_dir ( const char * , s#dentry * )
debugfs_create_file s#dentry * debugfs_create_file ( const char * , t#umode_t , s#dentry * , void * , const s#file_operations * )
debugfs_remove void debugfs_remove ( s#dentry * )
default_llseek extern t#loff_t default_llseek ( s#file * , t#loff_t , int )
default_wake_function int default_wake_function ( s#wait_queue_entry * , unsigned , int , void * )
del_gendisk void del_gendisk ( s#gendisk * )
delayed_work_timer_fn void delayed_work_timer_fn ( s#timer_list * )
dentry_path_raw extern char * dentry_path_raw ( const s#dentry * , char * , int )
destroy_workqueue extern void destroy_workqueue ( s#workqueue_struct * )
dev_driver_string const char * dev_driver_string ( const s#device * )
device_add_disk int __attribute__ ( ( __warn_unused_result__ ) ) device_add_disk ( s#device * , s#gendisk * , const s#attribute_group * * )
devmap_managed_key extern s#static_key_false devmap_managed_key
dget_parent extern s#dentry * dget_parent ( s#dentry * )
disk_check_media_change t#bool disk_check_media_change ( s#gendisk * )
dma_alloc_attrs void * dma_alloc_attrs ( s#device * , t#size_t , t#dma_addr_t * , t#gfp_t , unsigned long )
dma_free_attrs void dma_free_attrs ( s#device * , t#size_t , void * , t#dma_addr_t , unsigned long )
dma_map_page_attrs t#dma_addr_t dma_map_page_attrs ( s#device * , s#page * , t#size_t , t#size_t , e#dma_data_direction , unsigned long )
dma_set_coherent_mask int dma_set_coherent_mask ( s#device * , t#u64 )
dma_set_mask int dma_set_mask ( s#device * , t#u64 )
dma_unmap_page_attrs void dma_unmap_page_attrs ( s#device * , t#dma_addr_t , t#size_t , e#dma_data_direction , unsigned long )
done_path_create extern void done_path_create ( s#path * , s#dentry * )
down extern void down ( s#semaphore * )
down_interruptible extern int __attribute__ ( ( __warn_unused_result__ ) ) down_interruptible ( s#semaphore * )
down_read extern void down_read ( s#rw_semaphore * )
down_read_trylock extern int down_read_trylock ( s#rw_semaphore * )
down_write extern void down_write ( s#rw_semaphore * )
down_write_trylock extern int down_write_trylock ( s#rw_semaphore * )
dput extern void dput ( s#dentry * )
drop_nlink extern void drop_nlink ( s#inode * )
dump_stack extern void dump_stack ( void )
e#audit_state enum audit_state { AUDIT_STATE_DISABLED , AUDIT_STATE_BUILD , AUDIT_STATE_RECORD }
e#blk_crypto_mode_num enum blk_crypto_mode_num { BLK_ENCRYPTION_MODE_INVALID , BLK_ENCRYPTION_MODE_AES_256_XTS , BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV , BLK_ENCRYPTION_MODE_ADIANTUM , BLK_ENCRYPTION_MODE_SM4_XTS , BLK_ENCRYPTION_MODE_MAX , }
e#blk_eh_timer_return enum blk_eh_timer_return { BLK_EH_DONE , BLK_EH_RESET_TIMER , }
e#blk_integrity_checksum enum blk_integrity_checksum { BLK_INTEGRITY_CSUM_NONE = 0 , BLK_INTEGRITY_CSUM_IP = 1 , BLK_INTEGRITY_CSUM_CRC = 2 , BLK_INTEGRITY_CSUM_CRC64 = 3 , }
e#blk_unique_id enum blk_unique_id { BLK_UID_T10 = 1 , BLK_UID_EUI64 = 2 , BLK_UID_NAA = 3 , }
e#bpf_access_type enum bpf_access_type { BPF_READ = 1 , BPF_WRITE = 2 }
e#bpf_arg_type enum bpf_arg_type { ARG_DONTCARE = 0 , ARG_CONST_MAP_PTR , ARG_PTR_TO_MAP_KEY , ARG_PTR_TO_MAP_VALUE , ARG_PTR_TO_MEM , ARG_PTR_TO_ARENA , ARG_CONST_SIZE , ARG_CONST_SIZE_OR_ZERO , ARG_PTR_TO_CTX , ARG_ANYTHING , ARG_PTR_TO_SPIN_LOCK , ARG_PTR_TO_SOCK_COMMON , ARG_PTR_TO_SOCKET , ARG_PTR_TO_BTF_ID , ARG_PTR_TO_RINGBUF_MEM , ARG_CONST_ALLOC_SIZE_OR_ZERO , ARG_PTR_TO_BTF_ID_SOCK_COMMON , ARG_PTR_TO_PERCPU_BTF_ID , ARG_PTR_TO_FUNC , ARG_PTR_TO_STACK , ARG_PTR_TO_CONST_STR , ARG_PTR_TO_TIMER , ARG_KPTR_XCHG_DEST , ARG_PTR_TO_DYNPTR , __BPF_ARG_TYPE_MAX , ARG_PTR_TO_MAP_VALUE_OR_NULL = E#PTR_MAYBE_NULL | E#ARG_PTR_TO_MAP_VALUE , ARG_PTR_TO_MEM_OR_NULL = E#PTR_MAYBE_NULL | E#ARG_PTR_TO_MEM , ARG_PTR_TO_CTX_OR_NULL = E#PTR_MAYBE_NULL | E#ARG_PTR_TO_CTX , ARG_PTR_TO_SOCKET_OR_NULL = E#PTR_MAYBE_NULL | E#ARG_PTR_TO_SOCKET , ARG_PTR_TO_STACK_OR_NULL = E#PTR_MAYBE_NULL | E#ARG_PTR_TO_STACK , ARG_PTR_TO_BTF_ID_OR_NULL = E#PTR_MAYBE_NULL | E#ARG_PTR_TO_BTF_ID , ARG_PTR_TO_UNINIT_MEM = E#MEM_UNINIT | E#MEM_WRITE | E#ARG_PTR_TO_MEM , ARG_PTR_TO_FIXED_SIZE_MEM = E#MEM_FIXED_SIZE | E#ARG_PTR_TO_MEM , __BPF_ARG_TYPE_LIMIT = ( E#__BPF_TYPE_LAST_FLAG | ( E#__BPF_TYPE_LAST_FLAG - 1 ) ) , }
e#bpf_attach_type enum bpf_attach_type { BPF_CGROUP_INET_INGRESS , BPF_CGROUP_INET_EGRESS , BPF_CGROUP_INET_SOCK_CREATE , BPF_CGROUP_SOCK_OPS , BPF_SK_SKB_STREAM_PARSER , BPF_SK_SKB_STREAM_VERDICT , BPF_CGROUP_DEVICE , BPF_SK_MSG_VERDICT , BPF_CGROUP_INET4_BIND , BPF_CGROUP_INET6_BIND , BPF_CGROUP_INET4_CONNECT , BPF_CGROUP_INET6_CONNECT , BPF_CGROUP_INET4_POST_BIND , BPF_CGROUP_INET6_POST_BIND , BPF_CGROUP_UDP4_SENDMSG , BPF_CGROUP_UDP6_SENDMSG , BPF_LIRC_MODE2 , BPF_FLOW_DISSECTOR , BPF_CGROUP_SYSCTL , BPF_CGROUP_UDP4_RECVMSG , BPF_CGROUP_UDP6_RECVMSG , BPF_CGROUP_GETSOCKOPT , BPF_CGROUP_SETSOCKOPT , BPF_TRACE_RAW_TP , BPF_TRACE_FENTRY , BPF_TRACE_FEXIT , BPF_MODIFY_RETURN , BPF_LSM_MAC , BPF_TRACE_ITER , BPF_CGROUP_INET4_GETPEERNAME , BPF_CGROUP_INET6_GETPEERNAME , BPF_CGROUP_INET4_GETSOCKNAME , BPF_CGROUP_INET6_GETSOCKNAME , BPF_XDP_DEVMAP , BPF_CGROUP_INET_SOCK_RELEASE , BPF_XDP_CPUMAP , BPF_SK_LOOKUP , BPF_XDP , BPF_SK_SKB_VERDICT , BPF_SK_REUSEPORT_SELECT , BPF_SK_REUSEPORT_SELECT_OR_MIGRATE , BPF_PERF_EVENT , BPF_TRACE_KPROBE_MULTI , BPF_LSM_CGROUP , BPF_STRUCT_OPS , BPF_NETFILTER , BPF_TCX_INGRESS , BPF_TCX_EGRESS , BPF_TRACE_UPROBE_MULTI , BPF_CGROUP_UNIX_CONNECT , BPF_CGROUP_UNIX_SENDMSG , BPF_CGROUP_UNIX_RECVMSG , BPF_CGROUP_UNIX_GETPEERNAME , BPF_CGROUP_UNIX_GETSOCKNAME , BPF_NETKIT_PRIMARY , BPF_NETKIT_PEER , BPF_TRACE_KPROBE_SESSION , __MAX_BPF_ATTACH_TYPE }
e#bpf_cgroup_iter_order enum bpf_cgroup_iter_order { BPF_CGROUP_ITER_ORDER_UNSPEC = 0 , BPF_CGROUP_ITER_SELF_ONLY , BPF_CGROUP_ITER_DESCENDANTS_PRE , BPF_CGROUP_ITER_DESCENDANTS_POST , BPF_CGROUP_ITER_ANCESTORS_UP , }
e#bpf_dynptr_type enum bpf_dynptr_type { BPF_DYNPTR_TYPE_INVALID , BPF_DYNPTR_TYPE_LOCAL , BPF_DYNPTR_TYPE_RINGBUF , BPF_DYNPTR_TYPE_SKB , BPF_DYNPTR_TYPE_XDP , }
e#bpf_func_id enum bpf_func_id { BPF_FUNC_unspec = 0 , BPF_FUNC_map_lookup_elem = 1 , BPF_FUNC_map_update_elem = 2 , BPF_FUNC_map_delete_elem = 3 , BPF_FUNC_probe_read = 4 , BPF_FUNC_ktime_get_ns = 5 , BPF_FUNC_trace_printk = 6 , BPF_FUNC_get_prandom_u32 = 7 , BPF_FUNC_get_smp_processor_id = 8 , BPF_FUNC_skb_store_bytes = 9 , BPF_FUNC_l3_csum_replace = 10 , BPF_FUNC_l4_csum_replace = 11 , BPF_FUNC_tail_call = 12 , BPF_FUNC_clone_redirect = 13 , BPF_FUNC_get_current_pid_tgid = 14 , BPF_FUNC_get_current_uid_gid = 15 , BPF_FUNC_get_current_comm = 16 , BPF_FUNC_get_cgroup_classid = 17 , BPF_FUNC_skb_vlan_push = 18 , BPF_FUNC_skb_vlan_pop = 19 , BPF_FUNC_skb_get_tunnel_key = 20 , BPF_FUNC_skb_set_tunnel_key = 21 , BPF_FUNC_perf_event_read = 22 , BPF_FUNC_redirect = 23 , BPF_FUNC_get_route_realm = 24 , BPF_FUNC_perf_event_output = 25 , BPF_FUNC_skb_load_bytes = 26 , BPF_FUNC_get_stackid = 27 , BPF_FUNC_csum_diff = 28 , BPF_FUNC_skb_get_tunnel_opt = 29 , BPF_FUNC_skb_set_tunnel_opt = 30 , BPF_FUNC_skb_change_proto = 31 , BPF_FUNC_skb_change_type = 32 , BPF_FUNC_skb_under_cgroup = 33 , BPF_FUNC_get_hash_recalc = 34 , BPF_FUNC_get_current_task = 35 , BPF_FUNC_probe_write_user = 36 , BPF_FUNC_current_task_under_cgroup = 37 , BPF_FUNC_skb_change_tail = 38 , BPF_FUNC_skb_pull_data = 39 , BPF_FUNC_csum_update = 40 , BPF_FUNC_set_hash_invalid = 41 , BPF_FUNC_get_numa_node_id = 42 , BPF_FUNC_skb_change_head = 43 , BPF_FUNC_xdp_adjust_head = 44 , BPF_FUNC_probe_read_str = 45 , BPF_FUNC_get_socket_cookie = 46 , BPF_FUNC_get_socket_uid = 47 , BPF_FUNC_set_hash = 48 , BPF_FUNC_setsockopt = 49 , BPF_FUNC_skb_adjust_room = 50 , BPF_FUNC_redirect_map = 51 , BPF_FUNC_sk_redirect_map = 52 , BPF_FUNC_sock_map_update = 53 , BPF_FUNC_xdp_adjust_meta = 54 , BPF_FUNC_perf_event_read_value = 55 , BPF_FUNC_perf_prog_read_value = 56 , BPF_FUNC_getsockopt = 57 , BPF_FUNC_override_return = 58 , BPF_FUNC_sock_ops_cb_flags_set = 59 , BPF_FUNC_msg_redirect_map = 60 , BPF_FUNC_msg_apply_bytes = 61 , BPF_FUNC_msg_cork_bytes = 62 , BPF_FUNC_msg_pull_data = 63 , BPF_FUNC_bind = 64 , BPF_FUNC_xdp_adjust_tail = 65 , BPF_FUNC_skb_get_xfrm_state = 66 , BPF_FUNC_get_stack = 67 , BPF_FUNC_skb_load_bytes_relative = 68 , BPF_FUNC_fib_lookup = 69 , BPF_FUNC_sock_hash_update = 70 , BPF_FUNC_msg_redirect_hash = 71 , BPF_FUNC_sk_redirect_hash = 72 , BPF_FUNC_lwt_push_encap = 73 , BPF_FUNC_lwt_seg6_store_bytes = 74 , BPF_FUNC_lwt_seg6_adjust_srh = 75 , BPF_FUNC_lwt_seg6_action = 76 , BPF_FUNC_rc_repeat = 77 , BPF_FUNC_rc_keydown = 78 , BPF_FUNC_skb_cgroup_id = 79 , BPF_FUNC_get_current_cgroup_id = 80 , BPF_FUNC_get_local_storage = 81 , BPF_FUNC_sk_select_reuseport = 82 , BPF_FUNC_skb_ancestor_cgroup_id = 83 , BPF_FUNC_sk_lookup_tcp = 84 , BPF_FUNC_sk_lookup_udp = 85 , BPF_FUNC_sk_release = 86 , BPF_FUNC_map_push_elem = 87 , BPF_FUNC_map_pop_elem = 88 , BPF_FUNC_map_peek_elem = 89 , BPF_FUNC_msg_push_data = 90 , BPF_FUNC_msg_pop_data = 91 , BPF_FUNC_rc_pointer_rel = 92 , BPF_FUNC_spin_lock = 93 , BPF_FUNC_spin_unlock = 94 , BPF_FUNC_sk_fullsock = 95 , BPF_FUNC_tcp_sock = 96 , BPF_FUNC_skb_ecn_set_ce = 97 , BPF_FUNC_get_listener_sock = 98 , BPF_FUNC_skc_lookup_tcp = 99 , BPF_FUNC_tcp_check_syncookie = 100 , BPF_FUNC_sysctl_get_name = 101 , BPF_FUNC_sysctl_get_current_value = 102 , BPF_FUNC_sysctl_get_new_value = 103 , BPF_FUNC_sysctl_set_new_value = 104 , BPF_FUNC_strtol = 105 , BPF_FUNC_strtoul = 106 , BPF_FUNC_sk_storage_get = 107 , BPF_FUNC_sk_storage_delete = 108 , BPF_FUNC_send_signal = 109 , BPF_FUNC_tcp_gen_syncookie = 110 , BPF_FUNC_skb_output = 111 , BPF_FUNC_probe_read_user = 112 , BPF_FUNC_probe_read_kernel = 113 , BPF_FUNC_probe_read_user_str = 114 , BPF_FUNC_probe_read_kernel_str = 115 , BPF_FUNC_tcp_send_ack = 116 , BPF_FUNC_send_signal_thread = 117 , BPF_FUNC_jiffies64 = 118 , BPF_FUNC_read_branch_records = 119 , BPF_FUNC_get_ns_current_pid_tgid = 120 , BPF_FUNC_xdp_output = 121 , BPF_FUNC_get_netns_cookie = 122 , BPF_FUNC_get_current_ancestor_cgroup_id = 123 , BPF_FUNC_sk_assign = 124 , BPF_FUNC_ktime_get_boot_ns = 125 , BPF_FUNC_seq_printf = 126 , BPF_FUNC_seq_write = 127 , BPF_FUNC_sk_cgroup_id = 128 , BPF_FUNC_sk_ancestor_cgroup_id = 129 , BPF_FUNC_ringbuf_output = 130 , BPF_FUNC_ringbuf_reserve = 131 , BPF_FUNC_ringbuf_submit = 132 , BPF_FUNC_ringbuf_discard = 133 , BPF_FUNC_ringbuf_query = 134 , BPF_FUNC_csum_level = 135 , BPF_FUNC_skc_to_tcp6_sock = 136 , BPF_FUNC_skc_to_tcp_sock = 137 , BPF_FUNC_skc_to_tcp_timewait_sock = 138 , BPF_FUNC_skc_to_tcp_request_sock = 139 , BPF_FUNC_skc_to_udp6_sock = 140 , BPF_FUNC_get_task_stack = 141 , BPF_FUNC_load_hdr_opt = 142 , BPF_FUNC_store_hdr_opt = 143 , BPF_FUNC_reserve_hdr_opt = 144 , BPF_FUNC_inode_storage_get = 145 , BPF_FUNC_inode_storage_delete = 146 , BPF_FUNC_d_path = 147 , BPF_FUNC_copy_from_user = 148 , BPF_FUNC_snprintf_btf = 149 , BPF_FUNC_seq_printf_btf = 150 , BPF_FUNC_skb_cgroup_classid = 151 , BPF_FUNC_redirect_neigh = 152 , BPF_FUNC_per_cpu_ptr = 153 , BPF_FUNC_this_cpu_ptr = 154 , BPF_FUNC_redirect_peer = 155 , BPF_FUNC_task_storage_get = 156 , BPF_FUNC_task_storage_delete = 157 , BPF_FUNC_get_current_task_btf = 158 , BPF_FUNC_bprm_opts_set = 159 , BPF_FUNC_ktime_get_coarse_ns = 160 , BPF_FUNC_ima_inode_hash = 161 , BPF_FUNC_sock_from_file = 162 , BPF_FUNC_check_mtu = 163 , BPF_FUNC_for_each_map_elem = 164 , BPF_FUNC_snprintf = 165 , BPF_FUNC_sys_bpf = 166 , BPF_FUNC_btf_find_by_name_kind = 167 , BPF_FUNC_sys_close = 168 , BPF_FUNC_timer_init = 169 , BPF_FUNC_timer_set_callback = 170 , BPF_FUNC_timer_start = 171 , BPF_FUNC_timer_cancel = 172 , BPF_FUNC_get_func_ip = 173 , BPF_FUNC_get_attach_cookie = 174 , BPF_FUNC_task_pt_regs = 175 , BPF_FUNC_get_branch_snapshot = 176 , BPF_FUNC_trace_vprintk = 177 , BPF_FUNC_skc_to_unix_sock = 178 , BPF_FUNC_kallsyms_lookup_name = 179 , BPF_FUNC_find_vma = 180 , BPF_FUNC_loop = 181 , BPF_FUNC_strncmp = 182 , BPF_FUNC_get_func_arg = 183 , BPF_FUNC_get_func_ret = 184 , BPF_FUNC_get_func_arg_cnt = 185 , BPF_FUNC_get_retval = 186 , BPF_FUNC_set_retval = 187 , BPF_FUNC_xdp_get_buff_len = 188 , BPF_FUNC_xdp_load_bytes = 189 , BPF_FUNC_xdp_store_bytes = 190 , BPF_FUNC_copy_from_user_task = 191 , BPF_FUNC_skb_set_tstamp = 192 , BPF_FUNC_ima_file_hash = 193 , BPF_FUNC_kptr_xchg = 194 , BPF_FUNC_map_lookup_percpu_elem = 195 , BPF_FUNC_skc_to_mptcp_sock = 196 , BPF_FUNC_dynptr_from_mem = 197 , BPF_FUNC_ringbuf_reserve_dynptr = 198 , BPF_FUNC_ringbuf_submit_dynptr = 199 , BPF_FUNC_ringbuf_discard_dynptr = 200 , BPF_FUNC_dynptr_read = 201 , BPF_FUNC_dynptr_write = 202 , BPF_FUNC_dynptr_data = 203 , BPF_FUNC_tcp_raw_gen_syncookie_ipv4 = 204 , BPF_FUNC_tcp_raw_gen_syncookie_ipv6 = 205 , BPF_FUNC_tcp_raw_check_syncookie_ipv4 = 206 , BPF_FUNC_tcp_raw_check_syncookie_ipv6 = 207 , BPF_FUNC_ktime_get_tai_ns = 208 , BPF_FUNC_user_ringbuf_drain = 209 , BPF_FUNC_cgrp_storage_get = 210 , BPF_FUNC_cgrp_storage_delete = 211 , __BPF_FUNC_MAX_ID , }
e#bpf_iter_state enum bpf_iter_state { BPF_ITER_STATE_INVALID , BPF_ITER_STATE_ACTIVE , BPF_ITER_STATE_DRAINED , }
e#bpf_iter_task_type enum bpf_iter_task_type { BPF_TASK_ITER_ALL = 0 , BPF_TASK_ITER_TID , BPF_TASK_ITER_TGID , }
e#bpf_link_type enum bpf_link_type { BPF_LINK_TYPE_UNSPEC = 0 , BPF_LINK_TYPE_RAW_TRACEPOINT = 1 , BPF_LINK_TYPE_TRACING = 2 , BPF_LINK_TYPE_CGROUP = 3 , BPF_LINK_TYPE_ITER = 4 , BPF_LINK_TYPE_NETNS = 5 , BPF_LINK_TYPE_XDP = 6 , BPF_LINK_TYPE_PERF_EVENT = 7 , BPF_LINK_TYPE_KPROBE_MULTI = 8 , BPF_LINK_TYPE_STRUCT_OPS = 9 , BPF_LINK_TYPE_NETFILTER = 10 , BPF_LINK_TYPE_TCX = 11 , BPF_LINK_TYPE_UPROBE_MULTI = 12 , BPF_LINK_TYPE_NETKIT = 13 , BPF_LINK_TYPE_SOCKMAP = 14 , __MAX_BPF_LINK_TYPE , }
e#bpf_map_type enum bpf_map_type { BPF_MAP_TYPE_UNSPEC , BPF_MAP_TYPE_HASH , BPF_MAP_TYPE_ARRAY , BPF_MAP_TYPE_PROG_ARRAY , BPF_MAP_TYPE_PERF_EVENT_ARRAY , BPF_MAP_TYPE_PERCPU_HASH , BPF_MAP_TYPE_PERCPU_ARRAY , BPF_MAP_TYPE_STACK_TRACE , BPF_MAP_TYPE_CGROUP_ARRAY , BPF_MAP_TYPE_LRU_HASH , BPF_MAP_TYPE_LRU_PERCPU_HASH , BPF_MAP_TYPE_LPM_TRIE , BPF_MAP_TYPE_ARRAY_OF_MAPS , BPF_MAP_TYPE_HASH_OF_MAPS , BPF_MAP_TYPE_DEVMAP , BPF_MAP_TYPE_SOCKMAP , BPF_MAP_TYPE_CPUMAP , BPF_MAP_TYPE_XSKMAP , BPF_MAP_TYPE_SOCKHASH , BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED , BPF_MAP_TYPE_CGROUP_STORAGE = E#BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED , BPF_MAP_TYPE_REUSEPORT_SOCKARRAY , BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE_DEPRECATED , BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = E#BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE_DEPRECATED , BPF_MAP_TYPE_QUEUE , BPF_MAP_TYPE_STACK , BPF_MAP_TYPE_SK_STORAGE , BPF_MAP_TYPE_DEVMAP_HASH , BPF_MAP_TYPE_STRUCT_OPS , BPF_MAP_TYPE_RINGBUF , BPF_MAP_TYPE_INODE_STORAGE , BPF_MAP_TYPE_TASK_STORAGE , BPF_MAP_TYPE_BLOOM_FILTER , BPF_MAP_TYPE_USER_RINGBUF , BPF_MAP_TYPE_CGRP_STORAGE , BPF_MAP_TYPE_ARENA , __MAX_BPF_MAP_TYPE }
e#bpf_netdev_command enum bpf_netdev_command { XDP_SETUP_PROG , XDP_SETUP_PROG_HW , BPF_OFFLOAD_MAP_ALLOC , BPF_OFFLOAD_MAP_FREE , XDP_SETUP_XSK_POOL , }
e#bpf_prog_type enum bpf_prog_type { BPF_PROG_TYPE_UNSPEC , BPF_PROG_TYPE_SOCKET_FILTER , BPF_PROG_TYPE_KPROBE , BPF_PROG_TYPE_SCHED_CLS , BPF_PROG_TYPE_SCHED_ACT , BPF_PROG_TYPE_TRACEPOINT , BPF_PROG_TYPE_XDP , BPF_PROG_TYPE_PERF_EVENT , BPF_PROG_TYPE_CGROUP_SKB , BPF_PROG_TYPE_CGROUP_SOCK , BPF_PROG_TYPE_LWT_IN , BPF_PROG_TYPE_LWT_OUT , BPF_PROG_TYPE_LWT_XMIT , BPF_PROG_TYPE_SOCK_OPS , BPF_PROG_TYPE_SK_SKB , BPF_PROG_TYPE_CGROUP_DEVICE , BPF_PROG_TYPE_SK_MSG , BPF_PROG_TYPE_RAW_TRACEPOINT , BPF_PROG_TYPE_CGROUP_SOCK_ADDR , BPF_PROG_TYPE_LWT_SEG6LOCAL , BPF_PROG_TYPE_LIRC_MODE2 , BPF_PROG_TYPE_SK_REUSEPORT , BPF_PROG_TYPE_FLOW_DISSECTOR , BPF_PROG_TYPE_CGROUP_SYSCTL , BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE , BPF_PROG_TYPE_CGROUP_SOCKOPT , BPF_PROG_TYPE_TRACING , BPF_PROG_TYPE_STRUCT_OPS , BPF_PROG_TYPE_EXT , BPF_PROG_TYPE_LSM , BPF_PROG_TYPE_SK_LOOKUP , BPF_PROG_TYPE_SYSCALL , BPF_PROG_TYPE_NETFILTER , __MAX_BPF_PROG_TYPE }
e#bpf_reg_liveness enum bpf_reg_liveness { REG_LIVE_NONE = 0 , REG_LIVE_READ32 = 0x1 , REG_LIVE_READ64 = 0x2 , REG_LIVE_READ = E#REG_LIVE_READ32 | E#REG_LIVE_READ64 , REG_LIVE_WRITTEN = 0x4 , REG_LIVE_DONE = 0x8 , }
e#bpf_reg_type enum bpf_reg_type { NOT_INIT = 0 , SCALAR_VALUE , PTR_TO_CTX , CONST_PTR_TO_MAP , PTR_TO_MAP_VALUE , PTR_TO_MAP_KEY , PTR_TO_STACK , PTR_TO_PACKET_META , PTR_TO_PACKET , PTR_TO_PACKET_END , PTR_TO_FLOW_KEYS , PTR_TO_SOCKET , PTR_TO_SOCK_COMMON , PTR_TO_TCP_SOCK , PTR_TO_TP_BUFFER , PTR_TO_XDP_SOCK , PTR_TO_BTF_ID , PTR_TO_MEM , PTR_TO_ARENA , PTR_TO_BUF , PTR_TO_FUNC , CONST_PTR_TO_DYNPTR , __BPF_REG_TYPE_MAX , PTR_TO_MAP_VALUE_OR_NULL = E#PTR_MAYBE_NULL | E#PTR_TO_MAP_VALUE , PTR_TO_SOCKET_OR_NULL = E#PTR_MAYBE_NULL | E#PTR_TO_SOCKET , PTR_TO_SOCK_COMMON_OR_NULL = E#PTR_MAYBE_NULL | E#PTR_TO_SOCK_COMMON , PTR_TO_TCP_SOCK_OR_NULL = E#PTR_MAYBE_NULL | E#PTR_TO_TCP_SOCK , PTR_TO_BTF_ID_OR_NULL = E#PTR_MAYBE_NULL | E#PTR_TO_BTF_ID , __BPF_REG_TYPE_LIMIT = ( E#__BPF_TYPE_LAST_FLAG | ( E#__BPF_TYPE_LAST_FLAG - 1 ) ) , }
e#bpf_return_type enum bpf_return_type { RET_INTEGER , RET_VOID , RET_PTR_TO_MAP_VALUE , RET_PTR_TO_SOCKET , RET_PTR_TO_TCP_SOCK , RET_PTR_TO_SOCK_COMMON , RET_PTR_TO_MEM , RET_PTR_TO_MEM_OR_BTF_ID , RET_PTR_TO_BTF_ID , __BPF_RET_TYPE_MAX , RET_PTR_TO_MAP_VALUE_OR_NULL = E#PTR_MAYBE_NULL | E#RET_PTR_TO_MAP_VALUE , RET_PTR_TO_SOCKET_OR_NULL = E#PTR_MAYBE_NULL | E#RET_PTR_TO_SOCKET , RET_PTR_TO_TCP_SOCK_OR_NULL = E#PTR_MAYBE_NULL | E#RET_PTR_TO_TCP_SOCK , RET_PTR_TO_SOCK_COMMON_OR_NULL = E#PTR_MAYBE_NULL | E#RET_PTR_TO_SOCK_COMMON , RET_PTR_TO_RINGBUF_MEM_OR_NULL = E#PTR_MAYBE_NULL | E#MEM_RINGBUF | E#RET_PTR_TO_MEM , RET_PTR_TO_DYNPTR_MEM_OR_NULL = E#PTR_MAYBE_NULL | E#RET_PTR_TO_MEM , RET_PTR_TO_BTF_ID_OR_NULL = E#PTR_MAYBE_NULL | E#RET_PTR_TO_BTF_ID , RET_PTR_TO_BTF_ID_TRUSTED = E#PTR_TRUSTED | E#RET_PTR_TO_BTF_ID , __BPF_RET_TYPE_LIMIT = ( E#__BPF_TYPE_LAST_FLAG | ( E#__BPF_TYPE_LAST_FLAG - 1 ) ) , }
e#bss_source_type enum bss_source_type { BSS_SOURCE_DIRECT = 0 , BSS_SOURCE_MBSSID , BSS_SOURCE_STA_PROFILE , }
e#btf_field_type enum btf_field_type { BPF_SPIN_LOCK = ( 1 << 0 ) , BPF_TIMER = ( 1 << 1 ) , BPF_KPTR_UNREF = ( 1 << 2 ) , BPF_KPTR_REF = ( 1 << 3 ) , BPF_KPTR_PERCPU = ( 1 << 4 ) , BPF_KPTR = E#BPF_KPTR_UNREF | E#BPF_KPTR_REF | E#BPF_KPTR_PERCPU , BPF_LIST_HEAD = ( 1 << 5 ) , BPF_LIST_NODE = ( 1 << 6 ) , BPF_RB_ROOT = ( 1 << 7 ) , BPF_RB_NODE = ( 1 << 8 ) , BPF_GRAPH_NODE = E#BPF_RB_NODE | E#BPF_LIST_NODE , BPF_GRAPH_ROOT = E#BPF_RB_ROOT | E#BPF_LIST_HEAD , BPF_REFCOUNT = ( 1 << 9 ) , BPF_WORKQUEUE = ( 1 << 10 ) , }
e#cfg80211_signal_type enum cfg80211_signal_type { CFG80211_SIGNAL_TYPE_NONE , CFG80211_SIGNAL_TYPE_MBM , CFG80211_SIGNAL_TYPE_UNSPEC , }
e#class_map_type enum class_map_type { DD_CLASS_TYPE_DISJOINT_BITS , DD_CLASS_TYPE_LEVEL_NUM , DD_CLASS_TYPE_DISJOINT_NAMES , DD_CLASS_TYPE_LEVEL_NAMES , }
e#cpuhp_state enum cpuhp_state { CPUHP_INVALID = - 1 , CPUHP_OFFLINE = 0 , CPUHP_CREATE_THREADS , CPUHP_PERF_PREPARE , CPUHP_PERF_X86_PREPARE , CPUHP_PERF_X86_AMD_UNCORE_PREP , CPUHP_PERF_POWER , CPUHP_PERF_SUPERH , CPUHP_X86_HPET_DEAD , CPUHP_X86_MCE_DEAD , CPUHP_VIRT_NET_DEAD , CPUHP_IBMVNIC_DEAD , CPUHP_SLUB_DEAD , CPUHP_DEBUG_OBJ_DEAD , CPUHP_MM_WRITEBACK_DEAD , CPUHP_MM_VMSTAT_DEAD , CPUHP_SOFTIRQ_DEAD , CPUHP_NET_MVNETA_DEAD , CPUHP_CPUIDLE_DEAD , CPUHP_ARM64_FPSIMD_DEAD , CPUHP_ARM_OMAP_WAKE_DEAD , CPUHP_IRQ_POLL_DEAD , CPUHP_BLOCK_SOFTIRQ_DEAD , CPUHP_BIO_DEAD , CPUHP_ACPI_CPUDRV_DEAD , CPUHP_S390_PFAULT_DEAD , CPUHP_BLK_MQ_DEAD , CPUHP_FS_BUFF_DEAD , CPUHP_PRINTK_DEAD , CPUHP_MM_MEMCQ_DEAD , CPUHP_PERCPU_CNT_DEAD , CPUHP_RADIX_DEAD , CPUHP_PAGE_ALLOC , CPUHP_NET_DEV_DEAD , CPUHP_PCI_XGENE_DEAD , CPUHP_IOMMU_IOVA_DEAD , CPUHP_AP_ARM_CACHE_B15_RAC_DEAD , CPUHP_PADATA_DEAD , CPUHP_AP_DTPM_CPU_DEAD , CPUHP_RANDOM_PREPARE , CPUHP_WORKQUEUE_PREP , CPUHP_POWER_NUMA_PREPARE , CPUHP_HRTIMERS_PREPARE , CPUHP_X2APIC_PREPARE , CPUHP_SMPCFD_PREPARE , CPUHP_RELAY_PREPARE , CPUHP_MD_RAID5_PREPARE , CPUHP_RCUTREE_PREP , CPUHP_CPUIDLE_COUPLED_PREPARE , CPUHP_POWERPC_PMAC_PREPARE , CPUHP_POWERPC_MMU_CTX_PREPARE , CPUHP_XEN_PREPARE , CPUHP_XEN_EVTCHN_PREPARE , CPUHP_ARM_SHMOBILE_SCU_PREPARE , CPUHP_SH_SH3X_PREPARE , CPUHP_TOPOLOGY_PREPARE , CPUHP_NET_IUCV_PREPARE , CPUHP_ARM_BL_PREPARE , CPUHP_TRACE_RB_PREPARE , CPUHP_MM_ZS_PREPARE , CPUHP_MM_ZSWP_POOL_PREPARE , CPUHP_KVM_PPC_BOOK3S_PREPARE , CPUHP_ZCOMP_PREPARE , CPUHP_TIMERS_PREPARE , CPUHP_TMIGR_PREPARE , CPUHP_MIPS_SOC_PREPARE , CPUHP_BP_PREPARE_DYN , CPUHP_BP_PREPARE_DYN_END = E#CPUHP_BP_PREPARE_DYN + 20 , CPUHP_BP_KICK_AP , CPUHP_BRINGUP_CPU , CPUHP_AP_IDLE_DEAD , CPUHP_AP_OFFLINE , CPUHP_AP_CACHECTRL_STARTING , CPUHP_AP_SCHED_STARTING , CPUHP_AP_RCUTREE_DYING , CPUHP_AP_CPU_PM_STARTING , CPUHP_AP_IRQ_GIC_STARTING , CPUHP_AP_IRQ_HIP04_STARTING , CPUHP_AP_IRQ_APPLE_AIC_STARTING , CPUHP_AP_IRQ_ARMADA_XP_STARTING , CPUHP_AP_IRQ_BCM2836_STARTING , CPUHP_AP_IRQ_MIPS_GIC_STARTING , CPUHP_AP_IRQ_EIOINTC_STARTING , CPUHP_AP_IRQ_AVECINTC_STARTING , CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING , CPUHP_AP_IRQ_RISCV_IMSIC_STARTING , CPUHP_AP_IRQ_RISCV_SBI_IPI_STARTING , CPUHP_AP_ARM_MVEBU_COHERENCY , CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING , CPUHP_AP_PERF_X86_STARTING , CPUHP_AP_PERF_X86_AMD_IBS_STARTING , CPUHP_AP_PERF_XTENSA_STARTING , CPUHP_AP_ARM_VFP_STARTING , CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING , CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING , CPUHP_AP_PERF_ARM_ACPI_STARTING , CPUHP_AP_PERF_ARM_STARTING , CPUHP_AP_PERF_RISCV_STARTING , CPUHP_AP_ARM_L2X0_STARTING , CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING , CPUHP_AP_ARM_ARCH_TIMER_STARTING , CPUHP_AP_ARM_ARCH_TIMER_EVTSTRM_STARTING , CPUHP_AP_ARM_GLOBAL_TIMER_STARTING , CPUHP_AP_JCORE_TIMER_STARTING , CPUHP_AP_ARM_TWD_STARTING , CPUHP_AP_QCOM_TIMER_STARTING , CPUHP_AP_TEGRA_TIMER_STARTING , CPUHP_AP_ARMADA_TIMER_STARTING , CPUHP_AP_MIPS_GIC_TIMER_STARTING , CPUHP_AP_ARC_TIMER_STARTING , CPUHP_AP_REALTEK_TIMER_STARTING , CPUHP_AP_RISCV_TIMER_STARTING , CPUHP_AP_CLINT_TIMER_STARTING , CPUHP_AP_CSKY_TIMER_STARTING , CPUHP_AP_TI_GP_TIMER_STARTING , CPUHP_AP_HYPERV_TIMER_STARTING , CPUHP_AP_DUMMY_TIMER_STARTING , CPUHP_AP_ARM_XEN_STARTING , CPUHP_AP_ARM_XEN_RUNSTATE_STARTING , CPUHP_AP_ARM_CORESIGHT_STARTING , CPUHP_AP_ARM_CORESIGHT_CTI_STARTING , CPUHP_AP_ARM64_ISNDEP_STARTING , CPUHP_AP_SMPCFD_DYING , CPUHP_AP_HRTIMERS_DYING , CPUHP_AP_TICK_DYING , CPUHP_AP_X86_TBOOT_DYING , CPUHP_AP_ARM_CACHE_B15_RAC_DYING , CPUHP_AP_ONLINE , CPUHP_TEARDOWN_CPU , CPUHP_AP_ONLINE_IDLE , CPUHP_AP_HYPERV_ONLINE , CPUHP_AP_KVM_ONLINE , CPUHP_AP_SCHED_WAIT_EMPTY , CPUHP_AP_SMPBOOT_THREADS , CPUHP_AP_IRQ_AFFINITY_ONLINE , CPUHP_AP_BLK_MQ_ONLINE , CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS , CPUHP_AP_X86_INTEL_EPB_ONLINE , CPUHP_AP_PERF_ONLINE , CPUHP_AP_PERF_X86_ONLINE , CPUHP_AP_PERF_X86_UNCORE_ONLINE , CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE , CPUHP_AP_PERF_X86_AMD_POWER_ONLINE , CPUHP_AP_PERF_X86_RAPL_ONLINE , CPUHP_AP_PERF_S390_CF_ONLINE , CPUHP_AP_PERF_S390_SF_ONLINE , CPUHP_AP_PERF_ARM_CCI_ONLINE , CPUHP_AP_PERF_ARM_CCN_ONLINE , CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE , CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE , CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE , CPUHP_AP_PERF_ARM_HISI_L3_ONLINE , CPUHP_AP_PERF_ARM_HISI_PA_ONLINE , CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE , CPUHP_AP_PERF_ARM_HISI_PCIE_PMU_ONLINE , CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE , CPUHP_AP_PERF_ARM_L2X0_ONLINE , CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE , CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE , CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE , CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE , CPUHP_AP_PERF_ARM_MARVELL_CN10K_DDR_ONLINE , CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE , CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE , CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE , CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE , CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE , CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE , CPUHP_AP_PERF_CSKY_ONLINE , CPUHP_AP_TMIGR_ONLINE , CPUHP_AP_WATCHDOG_ONLINE , CPUHP_AP_WORKQUEUE_ONLINE , CPUHP_AP_RANDOM_ONLINE , CPUHP_AP_RCUTREE_ONLINE , CPUHP_AP_BASE_CACHEINFO_ONLINE , CPUHP_AP_ONLINE_DYN , CPUHP_AP_ONLINE_DYN_END = E#CPUHP_AP_ONLINE_DYN + 40 , CPUHP_AP_X86_HPET_ONLINE , CPUHP_AP_X86_KVM_CLK_ONLINE , CPUHP_AP_ACTIVE , CPUHP_ONLINE , }
e#d_real_type enum d_real_type { D_REAL_DATA , D_REAL_METADATA , }
e#dev_dma_attr enum dev_dma_attr { DEV_DMA_NOT_SUPPORTED , DEV_DMA_NON_COHERENT , DEV_DMA_COHERENT , }
e#dev_pm_qos_req_type enum dev_pm_qos_req_type { DEV_PM_QOS_RESUME_LATENCY = 1 , DEV_PM_QOS_LATENCY_TOLERANCE , DEV_PM_QOS_MIN_FREQUENCY , DEV_PM_QOS_MAX_FREQUENCY , DEV_PM_QOS_FLAGS , }
e#device_link_state enum device_link_state { DL_STATE_NONE = - 1 , DL_STATE_DORMANT = 0 , DL_STATE_AVAILABLE , DL_STATE_CONSUMER_PROBE , DL_STATE_ACTIVE , DL_STATE_SUPPLIER_UNBIND , }
e#device_physical_location_horizontal_position enum device_physical_location_horizontal_position { DEVICE_HORI_POS_LEFT , DEVICE_HORI_POS_CENTER , DEVICE_HORI_POS_RIGHT , }
e#device_physical_location_panel enum device_physical_location_panel { DEVICE_PANEL_TOP , DEVICE_PANEL_BOTTOM , DEVICE_PANEL_LEFT , DEVICE_PANEL_RIGHT , DEVICE_PANEL_FRONT , DEVICE_PANEL_BACK , DEVICE_PANEL_UNKNOWN , }
e#device_physical_location_vertical_position enum device_physical_location_vertical_position { DEVICE_VERT_POS_UPPER , DEVICE_VERT_POS_CENTER , DEVICE_VERT_POS_LOWER , }
e#device_removable enum device_removable { DEVICE_REMOVABLE_NOT_SUPPORTED = 0 , DEVICE_REMOVABLE_UNKNOWN , DEVICE_FIXED , DEVICE_REMOVABLE , }
e#devlink_dpipe_field_mapping_type enum devlink_dpipe_field_mapping_type { DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE , DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX , }
e#devlink_eswitch_encap_mode enum devlink_eswitch_encap_mode { DEVLINK_ESWITCH_ENCAP_MODE_NONE , DEVLINK_ESWITCH_ENCAP_MODE_BASIC , }
e#devlink_param_cmode enum devlink_param_cmode { DEVLINK_PARAM_CMODE_RUNTIME , DEVLINK_PARAM_CMODE_DRIVERINIT , DEVLINK_PARAM_CMODE_PERMANENT , __DEVLINK_PARAM_CMODE_MAX , DEVLINK_PARAM_CMODE_MAX = E#__DEVLINK_PARAM_CMODE_MAX - 1 }
e#devlink_port_flavour enum devlink_port_flavour { DEVLINK_PORT_FLAVOUR_PHYSICAL , DEVLINK_PORT_FLAVOUR_CPU , DEVLINK_PORT_FLAVOUR_DSA , DEVLINK_PORT_FLAVOUR_PCI_PF , DEVLINK_PORT_FLAVOUR_PCI_VF , DEVLINK_PORT_FLAVOUR_VIRTUAL , DEVLINK_PORT_FLAVOUR_UNUSED , DEVLINK_PORT_FLAVOUR_PCI_SF , }
e#devlink_port_fn_opstate enum devlink_port_fn_opstate { DEVLINK_PORT_FN_OPSTATE_DETACHED , DEVLINK_PORT_FN_OPSTATE_ATTACHED , }
e#devlink_port_fn_state enum devlink_port_fn_state { DEVLINK_PORT_FN_STATE_INACTIVE , DEVLINK_PORT_FN_STATE_ACTIVE , }
e#devlink_port_type enum devlink_port_type { DEVLINK_PORT_TYPE_NOTSET , DEVLINK_PORT_TYPE_AUTO , DEVLINK_PORT_TYPE_ETH , DEVLINK_PORT_TYPE_IB , }
e#devlink_rate_type enum devlink_rate_type { DEVLINK_RATE_TYPE_LEAF , DEVLINK_RATE_TYPE_NODE , }
e#devlink_reload_action enum devlink_reload_action { DEVLINK_RELOAD_ACTION_UNSPEC , DEVLINK_RELOAD_ACTION_DRIVER_REINIT , DEVLINK_RELOAD_ACTION_FW_ACTIVATE , __DEVLINK_RELOAD_ACTION_MAX , DEVLINK_RELOAD_ACTION_MAX = E#__DEVLINK_RELOAD_ACTION_MAX - 1 }
e#devlink_reload_limit enum devlink_reload_limit { DEVLINK_RELOAD_LIMIT_UNSPEC , DEVLINK_RELOAD_LIMIT_NO_RESET , __DEVLINK_RELOAD_LIMIT_MAX , DEVLINK_RELOAD_LIMIT_MAX = E#__DEVLINK_RELOAD_LIMIT_MAX - 1 }
e#devlink_sb_pool_type enum devlink_sb_pool_type { DEVLINK_SB_POOL_TYPE_INGRESS , DEVLINK_SB_POOL_TYPE_EGRESS , }
e#devlink_sb_threshold_type enum devlink_sb_threshold_type { DEVLINK_SB_THRESHOLD_TYPE_STATIC , DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC , }
e#devlink_selftest_status enum devlink_selftest_status { DEVLINK_SELFTEST_STATUS_SKIP , DEVLINK_SELFTEST_STATUS_PASS , DEVLINK_SELFTEST_STATUS_FAIL }
e#devlink_trap_action enum devlink_trap_action { DEVLINK_TRAP_ACTION_DROP , DEVLINK_TRAP_ACTION_TRAP , DEVLINK_TRAP_ACTION_MIRROR , }
e#devlink_trap_type enum devlink_trap_type { DEVLINK_TRAP_TYPE_DROP , DEVLINK_TRAP_TYPE_EXCEPTION , DEVLINK_TRAP_TYPE_CONTROL , }
e#dl_dev_state enum dl_dev_state { DL_DEV_NO_DRIVER = 0 , DL_DEV_PROBING , DL_DEV_DRIVER_BOUND , DL_DEV_UNBINDING , }
e#dma_data_direction enum dma_data_direction { DMA_BIDIRECTIONAL = 0 , DMA_TO_DEVICE = 1 , DMA_FROM_DEVICE = 2 , DMA_NONE = 3 , }
e#dpll_pin_type enum dpll_pin_type { DPLL_PIN_TYPE_MUX = 1 , DPLL_PIN_TYPE_EXT , DPLL_PIN_TYPE_SYNCE_ETH_PORT , DPLL_PIN_TYPE_INT_OSCILLATOR , DPLL_PIN_TYPE_GNSS , __DPLL_PIN_TYPE_MAX , DPLL_PIN_TYPE_MAX = ( E#__DPLL_PIN_TYPE_MAX - 1 ) }
e#dsa_db_type enum dsa_db_type { DSA_DB_PORT , DSA_DB_LAG , DSA_DB_BRIDGE , }
e#dsa_tag_protocol enum dsa_tag_protocol { DSA_TAG_PROTO_NONE = 0 , DSA_TAG_PROTO_BRCM = 1 , DSA_TAG_PROTO_BRCM_LEGACY = 22 , DSA_TAG_PROTO_BRCM_PREPEND = 2 , DSA_TAG_PROTO_DSA = 3 , DSA_TAG_PROTO_EDSA = 4 , DSA_TAG_PROTO_GSWIP = 5 , DSA_TAG_PROTO_KSZ9477 = 6 , DSA_TAG_PROTO_KSZ9893 = 7 , DSA_TAG_PROTO_LAN9303 = 8 , DSA_TAG_PROTO_MTK = 9 , DSA_TAG_PROTO_QCA = 10 , DSA_TAG_PROTO_TRAILER = 11 , DSA_TAG_PROTO_8021Q = 12 , DSA_TAG_PROTO_SJA1105 = 13 , DSA_TAG_PROTO_KSZ8795 = 14 , DSA_TAG_PROTO_OCELOT = 15 , DSA_TAG_PROTO_AR9331 = 16 , DSA_TAG_PROTO_RTL4_A = 17 , DSA_TAG_PROTO_HELLCREEK = 18 , DSA_TAG_PROTO_XRS700X = 19 , DSA_TAG_PROTO_OCELOT_8021Q = 20 , DSA_TAG_PROTO_SEVILLE = 21 , DSA_TAG_PROTO_SJA1110 = 23 , DSA_TAG_PROTO_RTL8_4 = 24 , DSA_TAG_PROTO_RTL8_4T = 25 , DSA_TAG_PROTO_RZN1_A5PSW = 26 , DSA_TAG_PROTO_LAN937X = 27 , DSA_TAG_PROTO_VSC73XX_8021Q = 28 , }
e#elv_merge enum elv_merge { ELEVATOR_NO_MERGE = 0 , ELEVATOR_FRONT_MERGE = 1 , ELEVATOR_BACK_MERGE = 2 , ELEVATOR_DISCARD_MERGE = 3 , }
e#environment_cap enum environment_cap { ENVIRON_ANY , ENVIRON_INDOOR , ENVIRON_OUTDOOR , }
e#ethtool_link_ext_state enum ethtool_link_ext_state { ETHTOOL_LINK_EXT_STATE_AUTONEG , ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE , ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH , ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY , ETHTOOL_LINK_EXT_STATE_NO_CABLE , ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE , ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE , ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE , ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED , ETHTOOL_LINK_EXT_STATE_OVERHEAT , ETHTOOL_LINK_EXT_STATE_MODULE , }
e#ethtool_link_ext_substate_autoneg enum ethtool_link_ext_substate_autoneg { ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1 , ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED , ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED , ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE , ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE , ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD , }
e#ethtool_link_ext_substate_bad_signal_integrity enum ethtool_link_ext_substate_bad_signal_integrity { ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1 , ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE , ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST , ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS , }
e#ethtool_link_ext_substate_cable_issue enum ethtool_link_ext_substate_cable_issue { ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1 , ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE , }
e#ethtool_link_ext_substate_link_logical_mismatch enum ethtool_link_ext_substate_link_logical_mismatch { ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1 , ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK , ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS , ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED , ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED , }
e#ethtool_link_ext_substate_link_training enum ethtool_link_ext_substate_link_training { ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1 , ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT , ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY , ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT , }
e#ethtool_link_ext_substate_module enum ethtool_link_ext_substate_module { ETHTOOL_LINK_EXT_SUBSTATE_MODULE_CMIS_NOT_READY = 1 , }
e#ethtool_mac_stats_src enum ethtool_mac_stats_src { ETHTOOL_MAC_STATS_SRC_AGGREGATE , ETHTOOL_MAC_STATS_SRC_EMAC , ETHTOOL_MAC_STATS_SRC_PMAC , }
e#ethtool_mm_verify_status enum ethtool_mm_verify_status { ETHTOOL_MM_VERIFY_STATUS_UNKNOWN , ETHTOOL_MM_VERIFY_STATUS_INITIAL , ETHTOOL_MM_VERIFY_STATUS_VERIFYING , ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED , ETHTOOL_MM_VERIFY_STATUS_FAILED , ETHTOOL_MM_VERIFY_STATUS_DISABLED , }
e#ethtool_module_power_mode enum ethtool_module_power_mode { ETHTOOL_MODULE_POWER_MODE_LOW = 1 , ETHTOOL_MODULE_POWER_MODE_HIGH , }
e#ethtool_module_power_mode_policy enum ethtool_module_power_mode_policy { ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH = 1 , ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO , }
e#ethtool_phys_id_state enum ethtool_phys_id_state { ETHTOOL_ID_INACTIVE , ETHTOOL_ID_ACTIVE , ETHTOOL_ID_ON , ETHTOOL_ID_OFF }
e#fault_flag enum fault_flag { FAULT_FLAG_WRITE = 1 << 0 , FAULT_FLAG_MKWRITE = 1 << 1 , FAULT_FLAG_ALLOW_RETRY = 1 << 2 , FAULT_FLAG_RETRY_NOWAIT = 1 << 3 , FAULT_FLAG_KILLABLE = 1 << 4 , FAULT_FLAG_TRIED = 1 << 5 , FAULT_FLAG_USER = 1 << 6 , FAULT_FLAG_REMOTE = 1 << 7 , FAULT_FLAG_INSTRUCTION = 1 << 8 , FAULT_FLAG_INTERRUPTIBLE = 1 << 9 , FAULT_FLAG_UNSHARE = 1 << 10 , FAULT_FLAG_ORIG_PTE_VALID = 1 << 11 , FAULT_FLAG_VMA_LOCK = 1 << 12 , }
e#fc_host_event_code enum fc_host_event_code { FCH_EVT_LIP = 0x1 , FCH_EVT_LINKUP = 0x2 , FCH_EVT_LINKDOWN = 0x3 , FCH_EVT_LIPRESET = 0x4 , FCH_EVT_RSCN = 0x5 , FCH_EVT_ADAPTER_CHANGE = 0x103 , FCH_EVT_PORT_UNKNOWN = 0x200 , FCH_EVT_PORT_OFFLINE = 0x201 , FCH_EVT_PORT_ONLINE = 0x202 , FCH_EVT_PORT_FABRIC = 0x204 , FCH_EVT_LINK_UNKNOWN = 0x500 , FCH_EVT_LINK_FPIN = 0x501 , FCH_EVT_LINK_FPIN_ACK = 0x502 , FCH_EVT_VENDOR_UNIQUE = 0xffff , }
e#fc_port_state enum fc_port_state { FC_PORTSTATE_UNKNOWN , FC_PORTSTATE_NOTPRESENT , FC_PORTSTATE_ONLINE , FC_PORTSTATE_OFFLINE , FC_PORTSTATE_BLOCKED , FC_PORTSTATE_BYPASSED , FC_PORTSTATE_DIAGNOSTICS , FC_PORTSTATE_LINKDOWN , FC_PORTSTATE_ERROR , FC_PORTSTATE_LOOPBACK , FC_PORTSTATE_DELETED , FC_PORTSTATE_MARGINAL , }
e#fc_port_type enum fc_port_type { FC_PORTTYPE_UNKNOWN , FC_PORTTYPE_OTHER , FC_PORTTYPE_NOTPRESENT , FC_PORTTYPE_NPORT , FC_PORTTYPE_NLPORT , FC_PORTTYPE_LPORT , FC_PORTTYPE_PTP , FC_PORTTYPE_NPIV , }
e#fc_vport_state enum fc_vport_state { FC_VPORT_UNKNOWN , FC_VPORT_ACTIVE , FC_VPORT_DISABLED , FC_VPORT_LINKDOWN , FC_VPORT_INITIALIZING , FC_VPORT_NO_FABRIC_SUPP , FC_VPORT_NO_FABRIC_RSCS , FC_VPORT_FABRIC_LOGOUT , FC_VPORT_FABRIC_REJ_WWN , FC_VPORT_FAILED , }
e#flow_action_hw_stats enum flow_action_hw_stats { FLOW_ACTION_HW_STATS_IMMEDIATE = ( ( ( ( 1UL ) ) ) << ( E#FLOW_ACTION_HW_STATS_IMMEDIATE_BIT ) ) , FLOW_ACTION_HW_STATS_DELAYED = ( ( ( ( 1UL ) ) ) << ( E#FLOW_ACTION_HW_STATS_DELAYED_BIT ) ) , FLOW_ACTION_HW_STATS_ANY = E#FLOW_ACTION_HW_STATS_IMMEDIATE | E#FLOW_ACTION_HW_STATS_DELAYED , FLOW_ACTION_HW_STATS_DISABLED = ( ( ( ( 1UL ) ) ) << ( E#FLOW_ACTION_HW_STATS_DISABLED_BIT ) ) , FLOW_ACTION_HW_STATS_DONT_CARE = ( ( ( ( 1UL ) ) ) << ( E#FLOW_ACTION_HW_STATS_NUM_BITS ) ) - 1 , }
e#flow_action_id enum flow_action_id { FLOW_ACTION_ACCEPT = 0 , FLOW_ACTION_DROP , FLOW_ACTION_TRAP , FLOW_ACTION_GOTO , FLOW_ACTION_REDIRECT , FLOW_ACTION_MIRRED , FLOW_ACTION_REDIRECT_INGRESS , FLOW_ACTION_MIRRED_INGRESS , FLOW_ACTION_VLAN_PUSH , FLOW_ACTION_VLAN_POP , FLOW_ACTION_VLAN_MANGLE , FLOW_ACTION_TUNNEL_ENCAP , FLOW_ACTION_TUNNEL_DECAP , FLOW_ACTION_MANGLE , FLOW_ACTION_ADD , FLOW_ACTION_CSUM , FLOW_ACTION_MARK , FLOW_ACTION_PTYPE , FLOW_ACTION_PRIORITY , FLOW_ACTION_RX_QUEUE_MAPPING , FLOW_ACTION_WAKE , FLOW_ACTION_QUEUE , FLOW_ACTION_SAMPLE , FLOW_ACTION_POLICE , FLOW_ACTION_CT , FLOW_ACTION_CT_METADATA , FLOW_ACTION_MPLS_PUSH , FLOW_ACTION_MPLS_POP , FLOW_ACTION_MPLS_MANGLE , FLOW_ACTION_GATE , FLOW_ACTION_PPPOE_PUSH , FLOW_ACTION_JUMP , FLOW_ACTION_PIPE , FLOW_ACTION_VLAN_PUSH_ETH , FLOW_ACTION_VLAN_POP_ETH , FLOW_ACTION_CONTINUE , NUM_FLOW_ACTIONS , }
e#flow_action_mangle_base enum flow_action_mangle_base { FLOW_ACT_MANGLE_UNSPEC = 0 , FLOW_ACT_MANGLE_HDR_TYPE_ETH , FLOW_ACT_MANGLE_HDR_TYPE_IP4 , FLOW_ACT_MANGLE_HDR_TYPE_IP6 , FLOW_ACT_MANGLE_HDR_TYPE_TCP , FLOW_ACT_MANGLE_HDR_TYPE_UDP , }
e#flow_block_command enum flow_block_command { FLOW_BLOCK_BIND , FLOW_BLOCK_UNBIND , }
e#flow_cls_command enum flow_cls_command { FLOW_CLS_REPLACE , FLOW_CLS_DESTROY , FLOW_CLS_STATS , FLOW_CLS_TMPLT_CREATE , FLOW_CLS_TMPLT_DESTROY , }
e#flow_offload_tuple_dir enum flow_offload_tuple_dir { FLOW_OFFLOAD_DIR_ORIGINAL = E#IP_CT_DIR_ORIGINAL , FLOW_OFFLOAD_DIR_REPLY = E#IP_CT_DIR_REPLY , }
e#freeze_holder enum freeze_holder { FREEZE_HOLDER_KERNEL = ( 1U << 0 ) , FREEZE_HOLDER_USERSPACE = ( 1U << 1 ) , FREEZE_MAY_NEST = ( 1U << 2 ) , }
e#freq_qos_req_type enum freq_qos_req_type { FREQ_QOS_MIN = 1 , FREQ_QOS_MAX , }
e#fs_context_phase enum fs_context_phase { FS_CONTEXT_CREATE_PARAMS , FS_CONTEXT_CREATING , FS_CONTEXT_AWAITING_MOUNT , FS_CONTEXT_AWAITING_RECONF , FS_CONTEXT_RECONF_PARAMS , FS_CONTEXT_RECONFIGURING , FS_CONTEXT_FAILED , }
e#fs_context_purpose enum fs_context_purpose { FS_CONTEXT_FOR_MOUNT , FS_CONTEXT_FOR_SUBMOUNT , FS_CONTEXT_FOR_RECONFIGURE , }
e#fs_value_type enum fs_value_type { fs_value_is_undefined , fs_value_is_flag , fs_value_is_string , fs_value_is_blob , fs_value_is_filename , fs_value_is_file , }
e#fscache_cache_state enum fscache_cache_state { FSCACHE_CACHE_IS_NOT_PRESENT , FSCACHE_CACHE_IS_PREPARING , FSCACHE_CACHE_IS_ACTIVE , FSCACHE_CACHE_GOT_IOERROR , FSCACHE_CACHE_IS_WITHDRAWN , }
e#fscache_cookie_state enum fscache_cookie_state { FSCACHE_COOKIE_STATE_QUIESCENT , FSCACHE_COOKIE_STATE_LOOKING_UP , FSCACHE_COOKIE_STATE_CREATING , FSCACHE_COOKIE_STATE_ACTIVE , FSCACHE_COOKIE_STATE_INVALIDATING , FSCACHE_COOKIE_STATE_FAILED , FSCACHE_COOKIE_STATE_LRU_DISCARDING , FSCACHE_COOKIE_STATE_WITHDRAWING , FSCACHE_COOKIE_STATE_RELINQUISHING , FSCACHE_COOKIE_STATE_DROPPED , }
e#fscache_want_state enum fscache_want_state { FSCACHE_WANT_PARAMS , FSCACHE_WANT_WRITE , FSCACHE_WANT_READ , }
e#ftrace_ops_cmd enum ftrace_ops_cmd { FTRACE_OPS_CMD_ENABLE_SHARE_IPMODIFY_SELF , FTRACE_OPS_CMD_ENABLE_SHARE_IPMODIFY_PEER , FTRACE_OPS_CMD_DISABLE_SHARE_IPMODIFY_PEER , }
e#garp_applications enum garp_applications { GARP_APPLICATION_GVRP , __GARP_APPLICATION_MAX }
e#hash_algo enum hash_algo { HASH_ALGO_MD4 , HASH_ALGO_MD5 , HASH_ALGO_SHA1 , HASH_ALGO_RIPE_MD_160 , HASH_ALGO_SHA256 , HASH_ALGO_SHA384 , HASH_ALGO_SHA512 , HASH_ALGO_SHA224 , HASH_ALGO_RIPE_MD_128 , HASH_ALGO_RIPE_MD_256 , HASH_ALGO_RIPE_MD_320 , HASH_ALGO_WP_256 , HASH_ALGO_WP_384 , HASH_ALGO_WP_512 , HASH_ALGO_TGR_128 , HASH_ALGO_TGR_160 , HASH_ALGO_TGR_192 , HASH_ALGO_SM3_256 , HASH_ALGO_STREEBOG_256 , HASH_ALGO_STREEBOG_512 , HASH_ALGO_SHA3_256 , HASH_ALGO_SHA3_384 , HASH_ALGO_SHA3_512 , HASH_ALGO__LAST }
e#hrtimer_restart enum hrtimer_restart { HRTIMER_NORESTART , HRTIMER_RESTART , }
e#hwtstamp_rx_filters enum hwtstamp_rx_filters { HWTSTAMP_FILTER_NONE , HWTSTAMP_FILTER_ALL , HWTSTAMP_FILTER_SOME , HWTSTAMP_FILTER_PTP_V1_L4_EVENT , HWTSTAMP_FILTER_PTP_V1_L4_SYNC , HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ , HWTSTAMP_FILTER_PTP_V2_L4_EVENT , HWTSTAMP_FILTER_PTP_V2_L4_SYNC , HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ , HWTSTAMP_FILTER_PTP_V2_L2_EVENT , HWTSTAMP_FILTER_PTP_V2_L2_SYNC , HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ , HWTSTAMP_FILTER_PTP_V2_EVENT , HWTSTAMP_FILTER_PTP_V2_SYNC , HWTSTAMP_FILTER_PTP_V2_DELAY_REQ , HWTSTAMP_FILTER_NTP_ALL , __HWTSTAMP_FILTER_CNT }
e#hwtstamp_source enum hwtstamp_source { HWTSTAMP_SOURCE_UNSPEC , HWTSTAMP_SOURCE_NETDEV , HWTSTAMP_SOURCE_PHYLIB , }
e#hwtstamp_tx_types enum hwtstamp_tx_types { HWTSTAMP_TX_OFF , HWTSTAMP_TX_ON , HWTSTAMP_TX_ONESTEP_SYNC , HWTSTAMP_TX_ONESTEP_P2P , __HWTSTAMP_TX_CNT }
e#ib_atomic_cap enum ib_atomic_cap { IB_ATOMIC_NONE , IB_ATOMIC_HCA , IB_ATOMIC_GLOB }
e#ib_cq_notify_flags enum ib_cq_notify_flags { IB_CQ_SOLICITED = 1 << 0 , IB_CQ_NEXT_COMP = 1 << 1 , IB_CQ_SOLICITED_MASK = E#IB_CQ_SOLICITED | E#IB_CQ_NEXT_COMP , IB_CQ_REPORT_MISSED_EVENTS = 1 << 2 , }
e#ib_event_type enum ib_event_type { IB_EVENT_CQ_ERR , IB_EVENT_QP_FATAL , IB_EVENT_QP_REQ_ERR , IB_EVENT_QP_ACCESS_ERR , IB_EVENT_COMM_EST , IB_EVENT_SQ_DRAINED , IB_EVENT_PATH_MIG , IB_EVENT_PATH_MIG_ERR , IB_EVENT_DEVICE_FATAL , IB_EVENT_PORT_ACTIVE , IB_EVENT_PORT_ERR , IB_EVENT_LID_CHANGE , IB_EVENT_PKEY_CHANGE , IB_EVENT_SM_CHANGE , IB_EVENT_SRQ_ERR , IB_EVENT_SRQ_LIMIT_REACHED , IB_EVENT_QP_LAST_WQE_REACHED , IB_EVENT_CLIENT_REREGISTER , IB_EVENT_GID_CHANGE , IB_EVENT_WQ_FATAL , }
e#ib_flow_action_type enum ib_flow_action_type { IB_FLOW_ACTION_UNSPECIFIED , IB_FLOW_ACTION_ESP = 1 , }
e#ib_flow_attr_type enum ib_flow_attr_type { IB_FLOW_ATTR_NORMAL = 0x0 , IB_FLOW_ATTR_ALL_DEFAULT = 0x1 , IB_FLOW_ATTR_MC_DEFAULT = 0x2 , IB_FLOW_ATTR_SNIFFER = 0x3 }
e#ib_flow_spec_type enum ib_flow_spec_type { IB_FLOW_SPEC_SNIFFER = 0 , IB_FLOW_SPEC_ETH = 0x20 , IB_FLOW_SPEC_IB = 0x22 , IB_FLOW_SPEC_IPV4 = 0x30 , IB_FLOW_SPEC_IPV6 = 0x31 , IB_FLOW_SPEC_ESP = 0x34 , IB_FLOW_SPEC_TCP = 0x40 , IB_FLOW_SPEC_UDP = 0x41 , IB_FLOW_SPEC_VXLAN_TUNNEL = 0x50 , IB_FLOW_SPEC_GRE = 0x51 , IB_FLOW_SPEC_MPLS = 0x60 , IB_FLOW_SPEC_INNER = 0x100 , IB_FLOW_SPEC_ACTION_TAG = 0x1000 , IB_FLOW_SPEC_ACTION_DROP = 0x1001 , IB_FLOW_SPEC_ACTION_HANDLE = 0x1002 , IB_FLOW_SPEC_ACTION_COUNT = 0x1003 , }
e#ib_gid_type enum ib_gid_type { IB_GID_TYPE_IB = E#IB_UVERBS_GID_TYPE_IB , IB_GID_TYPE_ROCE = E#IB_UVERBS_GID_TYPE_ROCE_V1 , IB_GID_TYPE_ROCE_UDP_ENCAP = E#IB_UVERBS_GID_TYPE_ROCE_V2 , IB_GID_TYPE_SIZE }
e#ib_mig_state enum ib_mig_state { IB_MIG_MIGRATED , IB_MIG_REARM , IB_MIG_ARMED }
e#ib_mr_type enum ib_mr_type { IB_MR_TYPE_MEM_REG , IB_MR_TYPE_SG_GAPS , IB_MR_TYPE_DM , IB_MR_TYPE_USER , IB_MR_TYPE_DMA , IB_MR_TYPE_INTEGRITY , }
e#ib_mtu enum ib_mtu { IB_MTU_256 = 1 , IB_MTU_512 = 2 , IB_MTU_1024 = 3 , IB_MTU_2048 = 4 , IB_MTU_4096 = 5 }
e#ib_mw_type enum ib_mw_type { IB_MW_TYPE_1 = 1 , IB_MW_TYPE_2 = 2 }
e#ib_poll_context enum ib_poll_context { IB_POLL_SOFTIRQ , IB_POLL_WORKQUEUE , IB_POLL_UNBOUND_WORKQUEUE , IB_POLL_LAST_POOL_TYPE = E#IB_POLL_UNBOUND_WORKQUEUE , IB_POLL_DIRECT , }
e#ib_port_state enum ib_port_state { IB_PORT_NOP = 0 , IB_PORT_DOWN = 1 , IB_PORT_INIT = 2 , IB_PORT_ARMED = 3 , IB_PORT_ACTIVE = 4 , IB_PORT_ACTIVE_DEFER = 5 }
e#ib_qp_state enum ib_qp_state { IB_QPS_RESET , IB_QPS_INIT , IB_QPS_RTR , IB_QPS_RTS , IB_QPS_SQD , IB_QPS_SQE , IB_QPS_ERR }
e#ib_qp_type enum ib_qp_type { IB_QPT_SMI , IB_QPT_GSI , IB_QPT_RC = E#IB_UVERBS_QPT_RC , IB_QPT_UC = E#IB_UVERBS_QPT_UC , IB_QPT_UD = E#IB_UVERBS_QPT_UD , IB_QPT_RAW_IPV6 , IB_QPT_RAW_ETHERTYPE , IB_QPT_RAW_PACKET = E#IB_UVERBS_QPT_RAW_PACKET , IB_QPT_XRC_INI = E#IB_UVERBS_QPT_XRC_INI , IB_QPT_XRC_TGT = E#IB_UVERBS_QPT_XRC_TGT , IB_QPT_MAX , IB_QPT_DRIVER = E#IB_UVERBS_QPT_DRIVER , IB_QPT_RESERVED1 = 0x1000 , IB_QPT_RESERVED2 , IB_QPT_RESERVED3 , IB_QPT_RESERVED4 , IB_QPT_RESERVED5 , IB_QPT_RESERVED6 , IB_QPT_RESERVED7 , IB_QPT_RESERVED8 , IB_QPT_RESERVED9 , IB_QPT_RESERVED10 , }
e#ib_sig_err_type enum ib_sig_err_type { IB_SIG_BAD_GUARD , IB_SIG_BAD_REFTAG , IB_SIG_BAD_APPTAG , }
e#ib_sig_type enum ib_sig_type { IB_SIGNAL_ALL_WR , IB_SIGNAL_REQ_WR }
e#ib_signature_type enum ib_signature_type { IB_SIG_TYPE_NONE , IB_SIG_TYPE_T10_DIF , }
e#ib_srq_attr_mask enum ib_srq_attr_mask { IB_SRQ_MAX_WR = 1 << 0 , IB_SRQ_LIMIT = 1 << 1 , }
e#ib_srq_type enum ib_srq_type { IB_SRQT_BASIC = E#IB_UVERBS_SRQT_BASIC , IB_SRQT_XRC = E#IB_UVERBS_SRQT_XRC , IB_SRQT_TM = E#IB_UVERBS_SRQT_TM , }
e#ib_t10_dif_bg_type enum ib_t10_dif_bg_type { IB_T10DIF_CRC , IB_T10DIF_CSUM , }
e#ib_uverbs_advise_mr_advice enum ib_uverbs_advise_mr_advice { IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH , IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE , IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT , }
e#ib_wc_opcode enum ib_wc_opcode { IB_WC_SEND = E#IB_UVERBS_WC_SEND , IB_WC_RDMA_WRITE = E#IB_UVERBS_WC_RDMA_WRITE , IB_WC_RDMA_READ = E#IB_UVERBS_WC_RDMA_READ , IB_WC_COMP_SWAP = E#IB_UVERBS_WC_COMP_SWAP , IB_WC_FETCH_ADD = E#IB_UVERBS_WC_FETCH_ADD , IB_WC_BIND_MW = E#IB_UVERBS_WC_BIND_MW , IB_WC_LOCAL_INV = E#IB_UVERBS_WC_LOCAL_INV , IB_WC_LSO = E#IB_UVERBS_WC_TSO , IB_WC_ATOMIC_WRITE = E#IB_UVERBS_WC_ATOMIC_WRITE , IB_WC_REG_MR , IB_WC_MASKED_COMP_SWAP , IB_WC_MASKED_FETCH_ADD , IB_WC_FLUSH = E#IB_UVERBS_WC_FLUSH , IB_WC_RECV = 1 << 7 , IB_WC_RECV_RDMA_WITH_IMM }
e#ib_wc_status enum ib_wc_status { IB_WC_SUCCESS , IB_WC_LOC_LEN_ERR , IB_WC_LOC_QP_OP_ERR , IB_WC_LOC_EEC_OP_ERR , IB_WC_LOC_PROT_ERR , IB_WC_WR_FLUSH_ERR , IB_WC_MW_BIND_ERR , IB_WC_BAD_RESP_ERR , IB_WC_LOC_ACCESS_ERR , IB_WC_REM_INV_REQ_ERR , IB_WC_REM_ACCESS_ERR , IB_WC_REM_OP_ERR , IB_WC_RETRY_EXC_ERR , IB_WC_RNR_RETRY_EXC_ERR , IB_WC_LOC_RDD_VIOL_ERR , IB_WC_REM_INV_RD_REQ_ERR , IB_WC_REM_ABORT_ERR , IB_WC_INV_EECN_ERR , IB_WC_INV_EEC_STATE_ERR , IB_WC_FATAL_ERR , IB_WC_RESP_TIMEOUT_ERR , IB_WC_GENERAL_ERR }
e#ib_wq_state enum ib_wq_state { IB_WQS_RESET , IB_WQS_RDY , IB_WQS_ERR }
e#ib_wq_type enum ib_wq_type { IB_WQT_RQ = E#IB_UVERBS_WQT_RQ , }
e#ib_wr_opcode enum ib_wr_opcode { IB_WR_RDMA_WRITE = E#IB_UVERBS_WR_RDMA_WRITE , IB_WR_RDMA_WRITE_WITH_IMM = E#IB_UVERBS_WR_RDMA_WRITE_WITH_IMM , IB_WR_SEND = E#IB_UVERBS_WR_SEND , IB_WR_SEND_WITH_IMM = E#IB_UVERBS_WR_SEND_WITH_IMM , IB_WR_RDMA_READ = E#IB_UVERBS_WR_RDMA_READ , IB_WR_ATOMIC_CMP_AND_SWP = E#IB_UVERBS_WR_ATOMIC_CMP_AND_SWP , IB_WR_ATOMIC_FETCH_AND_ADD = E#IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD , IB_WR_BIND_MW = E#IB_UVERBS_WR_BIND_MW , IB_WR_LSO = E#IB_UVERBS_WR_TSO , IB_WR_SEND_WITH_INV = E#IB_UVERBS_WR_SEND_WITH_INV , IB_WR_RDMA_READ_WITH_INV = E#IB_UVERBS_WR_RDMA_READ_WITH_INV , IB_WR_LOCAL_INV = E#IB_UVERBS_WR_LOCAL_INV , IB_WR_MASKED_ATOMIC_CMP_AND_SWP = E#IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP , IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = E#IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD , IB_WR_FLUSH = E#IB_UVERBS_WR_FLUSH , IB_WR_ATOMIC_WRITE = E#IB_UVERBS_WR_ATOMIC_WRITE , IB_WR_REG_MR = 0x20 , IB_WR_REG_MR_INTEGRITY , IB_WR_RESERVED1 = 0xf0 , IB_WR_RESERVED2 , IB_WR_RESERVED3 , IB_WR_RESERVED4 , IB_WR_RESERVED5 , IB_WR_RESERVED6 , IB_WR_RESERVED7 , IB_WR_RESERVED8 , IB_WR_RESERVED9 , IB_WR_RESERVED10 , }
e#ieee80211_bss_type enum ieee80211_bss_type { IEEE80211_BSS_TYPE_ESS , IEEE80211_BSS_TYPE_PBSS , IEEE80211_BSS_TYPE_IBSS , IEEE80211_BSS_TYPE_MBSS , IEEE80211_BSS_TYPE_ANY }
e#ieee80211_edmg_bw_config enum ieee80211_edmg_bw_config { IEEE80211_EDMG_BW_CONFIG_4 = 4 , IEEE80211_EDMG_BW_CONFIG_5 = 5 , IEEE80211_EDMG_BW_CONFIG_6 = 6 , IEEE80211_EDMG_BW_CONFIG_7 = 7 , IEEE80211_EDMG_BW_CONFIG_8 = 8 , IEEE80211_EDMG_BW_CONFIG_9 = 9 , IEEE80211_EDMG_BW_CONFIG_10 = 10 , IEEE80211_EDMG_BW_CONFIG_11 = 11 , IEEE80211_EDMG_BW_CONFIG_12 = 12 , IEEE80211_EDMG_BW_CONFIG_13 = 13 , IEEE80211_EDMG_BW_CONFIG_14 = 14 , IEEE80211_EDMG_BW_CONFIG_15 = 15 , }
e#ieee802154_filtering_level enum ieee802154_filtering_level { IEEE802154_FILTERING_NONE , IEEE802154_FILTERING_1_FCS , IEEE802154_FILTERING_2_PROMISCUOUS , IEEE802154_FILTERING_3_SCAN , IEEE802154_FILTERING_4_FRAME_FIELDS , }
e#iommu_cap enum iommu_cap { IOMMU_CAP_CACHE_COHERENCY , IOMMU_CAP_NOEXEC , IOMMU_CAP_PRE_BOOT_PROTECTION , IOMMU_CAP_ENFORCE_CACHE_COHERENCY , IOMMU_CAP_DEFERRED_FLUSH , IOMMU_CAP_DIRTY_TRACKING , }
e#iommu_dev_features enum iommu_dev_features { IOMMU_DEV_FEAT_SVA , IOMMU_DEV_FEAT_IOPF , }
e#ip_conntrack_dir enum ip_conntrack_dir { IP_CT_DIR_ORIGINAL , IP_CT_DIR_REPLY , IP_CT_DIR_MAX }
e#ip_conntrack_info enum ip_conntrack_info { IP_CT_ESTABLISHED , IP_CT_RELATED , IP_CT_NEW , IP_CT_IS_REPLY , IP_CT_ESTABLISHED_REPLY = E#IP_CT_ESTABLISHED + E#IP_CT_IS_REPLY , IP_CT_RELATED_REPLY = E#IP_CT_RELATED + E#IP_CT_IS_REPLY , IP_CT_NUMBER , IP_CT_UNTRACKED = 7 , }
e#irq_alloc_type enum irq_alloc_type { X86_IRQ_ALLOC_TYPE_IOAPIC = 1 , X86_IRQ_ALLOC_TYPE_HPET , X86_IRQ_ALLOC_TYPE_PCI_MSI , X86_IRQ_ALLOC_TYPE_PCI_MSIX , X86_IRQ_ALLOC_TYPE_DMAR , X86_IRQ_ALLOC_TYPE_AMDVI , X86_IRQ_ALLOC_TYPE_UV , }
e#irq_domain_bus_token enum irq_domain_bus_token { DOMAIN_BUS_ANY = 0 , DOMAIN_BUS_WIRED , DOMAIN_BUS_GENERIC_MSI , DOMAIN_BUS_PCI_MSI , DOMAIN_BUS_PLATFORM_MSI , DOMAIN_BUS_NEXUS , DOMAIN_BUS_IPI , DOMAIN_BUS_FSL_MC_MSI , DOMAIN_BUS_TI_SCI_INTA_MSI , DOMAIN_BUS_WAKEUP , DOMAIN_BUS_VMD_MSI , DOMAIN_BUS_PCI_DEVICE_MSI , DOMAIN_BUS_PCI_DEVICE_MSIX , DOMAIN_BUS_DMAR , DOMAIN_BUS_AMDVI , DOMAIN_BUS_DEVICE_MSI , DOMAIN_BUS_WIRED_TO_MSI , }
e#irq_gc_flags enum irq_gc_flags { IRQ_GC_INIT_MASK_CACHE = 1 << 0 , IRQ_GC_INIT_NESTED_LOCK = 1 << 1 , IRQ_GC_MASK_CACHE_PER_TYPE = 1 << 2 , IRQ_GC_NO_MASK = 1 << 3 , IRQ_GC_BE_IO = 1 << 4 , }
e#irqchip_irq_state@56cb9417 enum irqchip_irq_state { UNKNOWN }
e#irqchip_irq_state@8b3c971d enum irqchip_irq_state { IRQCHIP_STATE_PENDING , IRQCHIP_STATE_ACTIVE , IRQCHIP_STATE_MASKED , IRQCHIP_STATE_LINE_LEVEL , }
e#irqreturn enum irqreturn { IRQ_NONE = ( 0 << 0 ) , IRQ_HANDLED = ( 1 << 0 ) , IRQ_WAKE_THREAD = ( 1 << 1 ) , }
e#iw_cm_event_type enum iw_cm_event_type { IW_CM_EVENT_CONNECT_REQUEST = 1 , IW_CM_EVENT_CONNECT_REPLY , IW_CM_EVENT_ESTABLISHED , IW_CM_EVENT_DISCONNECT , IW_CM_EVENT_CLOSE }
e#kernel_pkey_operation enum kernel_pkey_operation { kernel_pkey_encrypt , kernel_pkey_decrypt , kernel_pkey_sign , kernel_pkey_verify , }
e#kobj_ns_type enum kobj_ns_type { KOBJ_NS_TYPE_NONE = 0 , KOBJ_NS_TYPE_NET , KOBJ_NS_TYPES }
e#led_brightness enum led_brightness { LED_OFF = 0 , LED_ON = 1 , LED_HALF = 127 , LED_FULL = 255 , }
e#libipw_state enum libipw_state { LIBIPW_UNINITIALIZED = 0 , LIBIPW_INITIALIZED , LIBIPW_ASSOCIATING , LIBIPW_ASSOCIATED , LIBIPW_AUTHENTICATING , LIBIPW_AUTHENTICATED , LIBIPW_SHUTDOWN }
e#macsec_offload enum macsec_offload { MACSEC_OFFLOAD_OFF = 0 , MACSEC_OFFLOAD_PHY = 1 , MACSEC_OFFLOAD_MAC = 2 , __MACSEC_OFFLOAD_END , MACSEC_OFFLOAD_MAX = E#__MACSEC_OFFLOAD_END - 1 , }
e#macsec_validation_type enum macsec_validation_type { MACSEC_VALIDATE_DISABLED = 0 , MACSEC_VALIDATE_CHECK = 1 , MACSEC_VALIDATE_STRICT = 2 , __MACSEC_VALIDATE_END , MACSEC_VALIDATE_MAX = E#__MACSEC_VALIDATE_END - 1 , }
e#memory_type enum memory_type { MEMORY_DEVICE_PRIVATE = 1 , MEMORY_DEVICE_COHERENT , MEMORY_DEVICE_FS_DAX , MEMORY_DEVICE_GENERIC , MEMORY_DEVICE_PCI_P2PDMA , }
e#metadata_type enum metadata_type { METADATA_IP_TUNNEL , METADATA_HW_PORT_MUX , METADATA_MACSEC , METADATA_XFRM , }
e#migrate_mode enum migrate_mode { MIGRATE_ASYNC , MIGRATE_SYNC_LIGHT , MIGRATE_SYNC , }
e#module_state enum module_state { MODULE_STATE_LIVE , MODULE_STATE_COMING , MODULE_STATE_GOING , MODULE_STATE_UNFORMED , }
e#mq_rq_state enum mq_rq_state { MQ_RQ_IDLE = 0 , MQ_RQ_IN_FLIGHT = 1 , MQ_RQ_COMPLETE = 2 , }
e#mrp_applications enum mrp_applications { MRP_APPLICATION_MVRP , __MRP_APPLICATION_MAX }
e#net_device_path_type enum net_device_path_type { DEV_PATH_ETHERNET = 0 , DEV_PATH_VLAN , DEV_PATH_BRIDGE , DEV_PATH_PPPOE , DEV_PATH_DSA , DEV_PATH_MTK_WDMA , }
e#netdev_lag_hash enum netdev_lag_hash { NETDEV_LAG_HASH_NONE , NETDEV_LAG_HASH_L2 , NETDEV_LAG_HASH_L34 , NETDEV_LAG_HASH_L23 , NETDEV_LAG_HASH_E23 , NETDEV_LAG_HASH_E34 , NETDEV_LAG_HASH_VLAN_SRCMAC , NETDEV_LAG_HASH_UNKNOWN , }
e#netdev_lag_tx_type enum netdev_lag_tx_type { NETDEV_LAG_TX_TYPE_UNKNOWN , NETDEV_LAG_TX_TYPE_RANDOM , NETDEV_LAG_TX_TYPE_BROADCAST , NETDEV_LAG_TX_TYPE_ROUNDROBIN , NETDEV_LAG_TX_TYPE_ACTIVEBACKUP , NETDEV_LAG_TX_TYPE_HASH , }
e#netdev_ml_priv_type enum netdev_ml_priv_type { ML_PRIV_NONE , ML_PRIV_CAN , }
e#netdev_stat_type enum netdev_stat_type { NETDEV_PCPU_STAT_NONE , NETDEV_PCPU_STAT_LSTATS , NETDEV_PCPU_STAT_TSTATS , NETDEV_PCPU_STAT_DSTATS , }
e#netdev_tx enum netdev_tx { __NETDEV_TX_MIN = ( - ( ( int ) ( ~ 0U >> 1 ) ) - 1 ) , NETDEV_TX_OK = 0x00 , NETDEV_TX_BUSY = 0x10 , }
e#netfs_io_origin enum netfs_io_origin { NETFS_READAHEAD , NETFS_READPAGE , NETFS_READ_GAPS , NETFS_READ_FOR_WRITE , NETFS_DIO_READ , NETFS_WRITEBACK , NETFS_WRITETHROUGH , NETFS_UNBUFFERED_WRITE , NETFS_DIO_WRITE , NETFS_PGPRIV2_COPY_TO_CACHE , nr__netfs_io_origin }
e#netfs_io_source enum netfs_io_source { NETFS_SOURCE_UNKNOWN , NETFS_FILL_WITH_ZEROES , NETFS_DOWNLOAD_FROM_SERVER , NETFS_READ_FROM_CACHE , NETFS_INVALID_READ , NETFS_UPLOAD_TO_SERVER , NETFS_WRITE_TO_CACHE , NETFS_INVALID_WRITE , }
e#netfs_read_from_hole enum netfs_read_from_hole { NETFS_READ_HOLE_IGNORE , NETFS_READ_HOLE_CLEAR , NETFS_READ_HOLE_FAIL , }
e#nf_log_type enum nf_log_type { NF_LOG_TYPE_LOG = 0 , NF_LOG_TYPE_ULOG , NF_LOG_TYPE_MAX }
e#nfs3_stable_how enum nfs3_stable_how { NFS_UNSTABLE = 0 , NFS_DATA_SYNC = 1 , NFS_FILE_SYNC = 2 , NFS_INVALID_STABLE_HOW = - 1 }
e#nfs4_change_attr_type enum nfs4_change_attr_type { NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR = 0 , NFS4_CHANGE_TYPE_IS_VERSION_COUNTER = 1 , NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS = 2 , NFS4_CHANGE_TYPE_IS_TIME_METADATA = 3 , NFS4_CHANGE_TYPE_IS_UNDEFINED = 4 , }
e#nl80211_auth_type enum nl80211_auth_type { NL80211_AUTHTYPE_OPEN_SYSTEM , NL80211_AUTHTYPE_SHARED_KEY , NL80211_AUTHTYPE_FT , NL80211_AUTHTYPE_NETWORK_EAP , NL80211_AUTHTYPE_SAE , NL80211_AUTHTYPE_FILS_SK , NL80211_AUTHTYPE_FILS_SK_PFS , NL80211_AUTHTYPE_FILS_PK , __NL80211_AUTHTYPE_NUM , NL80211_AUTHTYPE_MAX = E#__NL80211_AUTHTYPE_NUM - 1 , NL80211_AUTHTYPE_AUTOMATIC }
e#nl80211_band enum nl80211_band { NL80211_BAND_2GHZ , NL80211_BAND_5GHZ , NL80211_BAND_60GHZ , NL80211_BAND_6GHZ , NL80211_BAND_S1GHZ , NL80211_BAND_LC , NUM_NL80211_BANDS , }
e#nl80211_bss_select_attr enum nl80211_bss_select_attr { __NL80211_BSS_SELECT_ATTR_INVALID , NL80211_BSS_SELECT_ATTR_RSSI , NL80211_BSS_SELECT_ATTR_BAND_PREF , NL80211_BSS_SELECT_ATTR_RSSI_ADJUST , __NL80211_BSS_SELECT_ATTR_AFTER_LAST , NL80211_BSS_SELECT_ATTR_MAX = E#__NL80211_BSS_SELECT_ATTR_AFTER_LAST - 1 }
e#nl80211_chan_width enum nl80211_chan_width { NL80211_CHAN_WIDTH_20_NOHT , NL80211_CHAN_WIDTH_20 , NL80211_CHAN_WIDTH_40 , NL80211_CHAN_WIDTH_80 , NL80211_CHAN_WIDTH_80P80 , NL80211_CHAN_WIDTH_160 , NL80211_CHAN_WIDTH_5 , NL80211_CHAN_WIDTH_10 , NL80211_CHAN_WIDTH_1 , NL80211_CHAN_WIDTH_2 , NL80211_CHAN_WIDTH_4 , NL80211_CHAN_WIDTH_8 , NL80211_CHAN_WIDTH_16 , NL80211_CHAN_WIDTH_320 , }
e#nl80211_cqm_rssi_threshold_event enum nl80211_cqm_rssi_threshold_event { NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW , NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH , NL80211_CQM_RSSI_BEACON_LOSS_EVENT , }
e#nl80211_dfs_regions enum nl80211_dfs_regions { NL80211_DFS_UNSET = 0 , NL80211_DFS_FCC = 1 , NL80211_DFS_ETSI = 2 , NL80211_DFS_JP = 3 , }
e#nl80211_dfs_state enum nl80211_dfs_state { NL80211_DFS_USABLE , NL80211_DFS_UNAVAILABLE , NL80211_DFS_AVAILABLE , }
e#nl80211_iftype enum nl80211_iftype { NL80211_IFTYPE_UNSPECIFIED , NL80211_IFTYPE_ADHOC , NL80211_IFTYPE_STATION , NL80211_IFTYPE_AP , NL80211_IFTYPE_AP_VLAN , NL80211_IFTYPE_WDS , NL80211_IFTYPE_MONITOR , NL80211_IFTYPE_MESH_POINT , NL80211_IFTYPE_P2P_CLIENT , NL80211_IFTYPE_P2P_GO , NL80211_IFTYPE_P2P_DEVICE , NL80211_IFTYPE_OCB , NL80211_IFTYPE_NAN , NUM_NL80211_IFTYPES , NL80211_IFTYPE_MAX = E#NUM_NL80211_IFTYPES - 1 }
e#nl80211_key_mode enum nl80211_key_mode { NL80211_KEY_RX_TX , NL80211_KEY_NO_TX , NL80211_KEY_SET_TX }
e#nl80211_mfp enum nl80211_mfp { NL80211_MFP_NO , NL80211_MFP_REQUIRED , NL80211_MFP_OPTIONAL , }
e#nl80211_reg_initiator enum nl80211_reg_initiator { NL80211_REGDOM_SET_BY_CORE , NL80211_REGDOM_SET_BY_USER , NL80211_REGDOM_SET_BY_DRIVER , NL80211_REGDOM_SET_BY_COUNTRY_IE , }
e#nl80211_sae_pwe_mechanism enum nl80211_sae_pwe_mechanism { NL80211_SAE_PWE_UNSPECIFIED , NL80211_SAE_PWE_HUNT_AND_PECK , NL80211_SAE_PWE_HASH_TO_ELEMENT , NL80211_SAE_PWE_BOTH , }
e#nl80211_sar_type enum nl80211_sar_type { NL80211_SAR_TYPE_POWER , NUM_NL80211_SAR_TYPE , }
e#nl80211_user_reg_hint_type enum nl80211_user_reg_hint_type { NL80211_USER_REG_HINT_USER = 0 , NL80211_USER_REG_HINT_CELL_BASE = 1 , NL80211_USER_REG_HINT_INDOOR = 2 , }
e#nl802154_cca_modes enum nl802154_cca_modes { __NL802154_CCA_INVALID , NL802154_CCA_ENERGY , NL802154_CCA_CARRIER , NL802154_CCA_ENERGY_CARRIER , NL802154_CCA_ALOHA , NL802154_CCA_UWB_SHR , NL802154_CCA_UWB_MULTIPLEXED , __NL802154_CCA_ATTR_AFTER_LAST , NL802154_CCA_ATTR_MAX = E#__NL802154_CCA_ATTR_AFTER_LAST - 1 }
e#nl802154_cca_opts enum nl802154_cca_opts { NL802154_CCA_OPT_ENERGY_CARRIER_AND , NL802154_CCA_OPT_ENERGY_CARRIER_OR , __NL802154_CCA_OPT_ATTR_AFTER_LAST , NL802154_CCA_OPT_ATTR_MAX = E#__NL802154_CCA_OPT_ATTR_AFTER_LAST - 1 }
e#nl802154_supported_bool_states enum nl802154_supported_bool_states { NL802154_SUPPORTED_BOOL_FALSE , NL802154_SUPPORTED_BOOL_TRUE , __NL802154_SUPPORTED_BOOL_INVALD , NL802154_SUPPORTED_BOOL_BOTH , __NL802154_SUPPORTED_BOOL_AFTER_LAST , NL802154_SUPPORTED_BOOL_MAX = E#__NL802154_SUPPORTED_BOOL_AFTER_LAST - 1 }
e#nvme_fc_obj_state enum nvme_fc_obj_state { FC_OBJSTATE_UNKNOWN , FC_OBJSTATE_NOTPRESENT , FC_OBJSTATE_ONLINE , FC_OBJSTATE_OFFLINE , FC_OBJSTATE_BLOCKED , FC_OBJSTATE_BYPASSED , FC_OBJSTATE_DIAGNOSTICS , FC_OBJSTATE_LINKDOWN , FC_OBJSTATE_ERROR , FC_OBJSTATE_LOOPBACK , FC_OBJSTATE_DELETED , }
e#nvmefc_fcp_datadir enum nvmefc_fcp_datadir { NVMEFC_FCP_NODATA , NVMEFC_FCP_WRITE , NVMEFC_FCP_READ , }
e#nvmem_type enum nvmem_type { NVMEM_TYPE_UNKNOWN = 0 , NVMEM_TYPE_EEPROM , NVMEM_TYPE_OTP , NVMEM_TYPE_BATTERY_BACKED , NVMEM_TYPE_FRAM , }
e#perf_event_state enum perf_event_state { PERF_EVENT_STATE_DEAD = - 4 , PERF_EVENT_STATE_EXIT = - 3 , PERF_EVENT_STATE_ERROR = - 2 , PERF_EVENT_STATE_OFF = - 1 , PERF_EVENT_STATE_INACTIVE = 0 , PERF_EVENT_STATE_ACTIVE = 1 , }
e#phy_state enum phy_state { PHY_DOWN = 0 , PHY_READY , PHY_HALTED , PHY_ERROR , PHY_UP , PHY_RUNNING , PHY_NOLINK , PHY_CABLETEST , }
e#phylink_op_type enum phylink_op_type { PHYLINK_NETDEV = 0 , PHYLINK_DEV , }
e#pid_type enum pid_type { PIDTYPE_PID , PIDTYPE_TGID , PIDTYPE_PGID , PIDTYPE_SID , PIDTYPE_MAX , }
e#pm_qos_type enum pm_qos_type { PM_QOS_UNITIALIZED , PM_QOS_MAX , PM_QOS_MIN , }
e#pnfs_iomode enum pnfs_iomode { IOMODE_READ = 1 , IOMODE_RW = 2 , IOMODE_ANY = 3 , }
e#pnfs_try_status enum pnfs_try_status { PNFS_ATTEMPTED = 0 , PNFS_NOT_ATTEMPTED = 1 , PNFS_TRY_AGAIN = 2 , }
e#port_pkey_state enum port_pkey_state { IB_PORT_PKEY_NOT_VALID = 0 , IB_PORT_PKEY_VALID = 1 , IB_PORT_PKEY_LISTED = 2 , }
e#pr_type enum pr_type { PR_WRITE_EXCLUSIVE = 1 , PR_EXCLUSIVE_ACCESS = 2 , PR_WRITE_EXCLUSIVE_REG_ONLY = 3 , PR_EXCLUSIVE_ACCESS_REG_ONLY = 4 , PR_WRITE_EXCLUSIVE_ALL_REGS = 5 , PR_EXCLUSIVE_ACCESS_ALL_REGS = 6 , }
e#print_line_t enum print_line_t { TRACE_TYPE_PARTIAL_LINE = 0 , TRACE_TYPE_HANDLED = 1 , TRACE_TYPE_UNHANDLED = 2 , TRACE_TYPE_NO_CONSUME = 3 }
e#probe_type enum probe_type { PROBE_DEFAULT_STRATEGY , PROBE_PREFER_ASYNCHRONOUS , PROBE_FORCE_SYNCHRONOUS , }
e#quota_type enum quota_type { USRQUOTA = 0 , GRPQUOTA = 1 , PRJQUOTA = 2 , }
e#rdma_ah_attr_type enum rdma_ah_attr_type { RDMA_AH_ATTR_TYPE_UNDEFINED , RDMA_AH_ATTR_TYPE_IB , RDMA_AH_ATTR_TYPE_ROCE , RDMA_AH_ATTR_TYPE_OPA , }
e#rdma_cm_event_type enum rdma_cm_event_type { RDMA_CM_EVENT_ADDR_RESOLVED , RDMA_CM_EVENT_ADDR_ERROR , RDMA_CM_EVENT_ROUTE_RESOLVED , RDMA_CM_EVENT_ROUTE_ERROR , RDMA_CM_EVENT_CONNECT_REQUEST , RDMA_CM_EVENT_CONNECT_RESPONSE , RDMA_CM_EVENT_CONNECT_ERROR , RDMA_CM_EVENT_UNREACHABLE , RDMA_CM_EVENT_REJECTED , RDMA_CM_EVENT_ESTABLISHED , RDMA_CM_EVENT_DISCONNECTED , RDMA_CM_EVENT_DEVICE_REMOVAL , RDMA_CM_EVENT_MULTICAST_JOIN , RDMA_CM_EVENT_MULTICAST_ERROR , RDMA_CM_EVENT_ADDR_CHANGE , RDMA_CM_EVENT_TIMEWAIT_EXIT }
e#rdma_driver_id enum rdma_driver_id { RDMA_DRIVER_UNKNOWN , RDMA_DRIVER_MLX5 , RDMA_DRIVER_MLX4 , RDMA_DRIVER_CXGB3 , RDMA_DRIVER_CXGB4 , RDMA_DRIVER_MTHCA , RDMA_DRIVER_BNXT_RE , RDMA_DRIVER_OCRDMA , RDMA_DRIVER_NES , RDMA_DRIVER_I40IW , RDMA_DRIVER_IRDMA = E#RDMA_DRIVER_I40IW , RDMA_DRIVER_VMW_PVRDMA , RDMA_DRIVER_QEDR , RDMA_DRIVER_HNS , RDMA_DRIVER_USNIC , RDMA_DRIVER_RXE , RDMA_DRIVER_HFI1 , RDMA_DRIVER_QIB , RDMA_DRIVER_EFA , RDMA_DRIVER_SIW , RDMA_DRIVER_ERDMA , RDMA_DRIVER_MANA , }
e#rdma_link_layer enum rdma_link_layer { IB_LINK_LAYER_UNSPECIFIED , IB_LINK_LAYER_INFINIBAND , IB_LINK_LAYER_ETHERNET , }
e#rdma_lookup_mode enum rdma_lookup_mode { UVERBS_LOOKUP_READ , UVERBS_LOOKUP_WRITE , UVERBS_LOOKUP_DESTROY , }
e#rdma_netdev_t enum rdma_netdev_t { RDMA_NETDEV_OPA_VNIC , RDMA_NETDEV_IPOIB , }
e#rdma_network_type enum rdma_network_type { RDMA_NETWORK_IB , RDMA_NETWORK_ROCE_V1 , RDMA_NETWORK_IPV4 , RDMA_NETWORK_IPV6 }
e#rdma_nl_counter_mask enum rdma_nl_counter_mask { RDMA_COUNTER_MASK_QP_TYPE = 1 , RDMA_COUNTER_MASK_PID = 1 << 1 , }
e#rdma_nl_counter_mode enum rdma_nl_counter_mode { RDMA_COUNTER_MODE_NONE , RDMA_COUNTER_MODE_AUTO , RDMA_COUNTER_MODE_MANUAL , RDMA_COUNTER_MODE_MAX , }
e#rdma_nl_dev_type enum rdma_nl_dev_type { RDMA_DEVICE_TYPE_SMI = 1 , }
e#rdma_nl_name_assign_type enum rdma_nl_name_assign_type { RDMA_NAME_ASSIGN_TYPE_UNKNOWN = 0 , RDMA_NAME_ASSIGN_TYPE_USER = 1 , }
e#rdma_remove_reason enum rdma_remove_reason { RDMA_REMOVE_DESTROY , RDMA_REMOVE_CLOSE , RDMA_REMOVE_DRIVER_REMOVE , RDMA_REMOVE_ABORT , RDMA_REMOVE_DRIVER_FAILURE , }
e#rdma_restrack_type enum rdma_restrack_type { RDMA_RESTRACK_PD , RDMA_RESTRACK_CQ , RDMA_RESTRACK_QP , RDMA_RESTRACK_CM_ID , RDMA_RESTRACK_MR , RDMA_RESTRACK_CTX , RDMA_RESTRACK_COUNTER , RDMA_RESTRACK_SRQ , RDMA_RESTRACK_MAX }
e#rdma_transport_type enum rdma_transport_type { RDMA_TRANSPORT_IB , RDMA_TRANSPORT_IWARP , RDMA_TRANSPORT_USNIC , RDMA_TRANSPORT_USNIC_UDP , RDMA_TRANSPORT_UNSPECIFIED , }
e#rdma_ucm_port_space enum rdma_ucm_port_space { RDMA_PS_IPOIB = 0x0002 , RDMA_PS_IB = 0x013F , RDMA_PS_TCP = 0x0106 , RDMA_PS_UDP = 0x0111 , }
e#req_op enum req_op { REQ_OP_READ = ( blk_opf_t ) 0 , REQ_OP_WRITE = ( blk_opf_t ) 1 , REQ_OP_FLUSH = ( blk_opf_t ) 2 , REQ_OP_DISCARD = ( blk_opf_t ) 3 , REQ_OP_SECURE_ERASE = ( blk_opf_t ) 5 , REQ_OP_ZONE_APPEND = ( blk_opf_t ) 7 , REQ_OP_WRITE_ZEROES = ( blk_opf_t ) 9 , REQ_OP_ZONE_OPEN = ( blk_opf_t ) 10 , REQ_OP_ZONE_CLOSE = ( blk_opf_t ) 11 , REQ_OP_ZONE_FINISH = ( blk_opf_t ) 12 , REQ_OP_ZONE_RESET = ( blk_opf_t ) 13 , REQ_OP_ZONE_RESET_ALL = ( blk_opf_t ) 15 , REQ_OP_DRV_IN = ( blk_opf_t ) 34 , REQ_OP_DRV_OUT = ( blk_opf_t ) 35 , REQ_OP_LAST = ( blk_opf_t ) 36 , }
e#rpm_request enum rpm_request { RPM_REQ_NONE = 0 , RPM_REQ_IDLE , RPM_REQ_SUSPEND , RPM_REQ_AUTOSUSPEND , RPM_REQ_RESUME , }
e#rpm_status enum rpm_status { RPM_INVALID = - 1 , RPM_ACTIVE = 0 , RPM_RESUMING , RPM_SUSPENDED , RPM_SUSPENDING , }
e#rq_end_io_ret enum rq_end_io_ret { RQ_END_IO_NONE , RQ_END_IO_FREE , }
e#rq_qos_id enum rq_qos_id { RQ_QOS_WBT , RQ_QOS_LATENCY , RQ_QOS_COST , }
e#rw_hint enum rw_hint { WRITE_LIFE_NOT_SET = 0 , WRITE_LIFE_NONE = 1 , WRITE_LIFE_SHORT = 2 , WRITE_LIFE_MEDIUM = 3 , WRITE_LIFE_LONG = 4 , WRITE_LIFE_EXTREME = 5 , }
e#rx_handler_result enum rx_handler_result { RX_HANDLER_CONSUMED , RX_HANDLER_ANOTHER , RX_HANDLER_EXACT , RX_HANDLER_PASS , }
e#sa_path_rec_type enum sa_path_rec_type { SA_PATH_REC_TYPE_IB , SA_PATH_REC_TYPE_ROCE_V1 , SA_PATH_REC_TYPE_ROCE_V2 , SA_PATH_REC_TYPE_OPA }
e#sas_device_type enum sas_device_type { SAS_PHY_UNUSED = 0 , SAS_END_DEVICE = 1 , SAS_EDGE_EXPANDER_DEVICE = 2 , SAS_FANOUT_EXPANDER_DEVICE = 3 , SAS_HA = 4 , SAS_SATA_DEV = 5 , SAS_SATA_PM = 7 , SAS_SATA_PM_PORT = 8 , SAS_SATA_PENDING = 9 , }
e#sas_linkrate enum sas_linkrate { SAS_LINK_RATE_UNKNOWN = 0 , SAS_PHY_DISABLED = 1 , SAS_PHY_RESET_PROBLEM = 2 , SAS_SATA_SPINUP_HOLD = 3 , SAS_SATA_PORT_SELECTOR = 4 , SAS_PHY_RESET_IN_PROGRESS = 5 , SAS_LINK_RATE_1_5_GBPS = 8 , SAS_LINK_RATE_G1 = E#SAS_LINK_RATE_1_5_GBPS , SAS_LINK_RATE_3_0_GBPS = 9 , SAS_LINK_RATE_G2 = E#SAS_LINK_RATE_3_0_GBPS , SAS_LINK_RATE_6_0_GBPS = 10 , SAS_LINK_RATE_12_0_GBPS = 11 , SAS_LINK_RATE_22_5_GBPS = 12 , SAS_LINK_RATE_FAILED = 0x10 , SAS_PHY_VIRTUAL = 0x11 , }
e#sas_protocol enum sas_protocol { SAS_PROTOCOL_NONE = 0 , SAS_PROTOCOL_SATA = 0x01 , SAS_PROTOCOL_SMP = 0x02 , SAS_PROTOCOL_STP = 0x04 , SAS_PROTOCOL_SSP = 0x08 , SAS_PROTOCOL_ALL = 0x0E , SAS_PROTOCOL_STP_ALL = E#SAS_PROTOCOL_STP | E#SAS_PROTOCOL_SATA , SAS_PROTOCOL_INTERNAL_ABORT = 0x10 , }
e#sched_bind_type enum sched_bind_type { SCHED_QUEUE , SCHED_FLOWC , }
e#scsi_cmnd_submitter enum scsi_cmnd_submitter { SUBMITTED_BY_BLOCK_LAYER = 0 , SUBMITTED_BY_SCSI_ERROR_HANDLER = 1 , SUBMITTED_BY_SCSI_RESET_IOCTL = 2 , }
e#scsi_device_state enum scsi_device_state { SDEV_CREATED = 1 , SDEV_RUNNING , SDEV_CANCEL , SDEV_DEL , SDEV_QUIESCE , SDEV_OFFLINE , SDEV_TRANSPORT_OFFLINE , SDEV_BLOCK , SDEV_CREATED_BLOCK , }
e#scsi_disposition enum scsi_disposition { NEEDS_RETRY = 0x2001 , SUCCESS = 0x2002 , FAILED = 0x2003 , QUEUED = 0x2004 , SOFT_ERROR = 0x2005 , ADD_TO_MLQUEUE = 0x2006 , TIMEOUT_ERROR = 0x2007 , SCSI_RETURN_NOT_HANDLED = 0x2008 , FAST_IO_FAIL = 0x2009 , }
e#scsi_host_state enum scsi_host_state { SHOST_CREATED = 1 , SHOST_RUNNING , SHOST_CANCEL , SHOST_DEL , SHOST_RECOVERY , SHOST_CANCEL_RECOVERY , SHOST_DEL_RECOVERY , }
e#scsi_target_state enum scsi_target_state { STARGET_CREATED = 1 , STARGET_RUNNING , STARGET_REMOVE , STARGET_CREATED_REMOVE , STARGET_DEL , }
e#scsi_timeout_action enum scsi_timeout_action { SCSI_EH_DONE , SCSI_EH_RESET_TIMER , SCSI_EH_NOT_HANDLED , }
e#sctp_conntrack enum sctp_conntrack { SCTP_CONNTRACK_NONE , SCTP_CONNTRACK_CLOSED , SCTP_CONNTRACK_COOKIE_WAIT , SCTP_CONNTRACK_COOKIE_ECHOED , SCTP_CONNTRACK_ESTABLISHED , SCTP_CONNTRACK_SHUTDOWN_SENT , SCTP_CONNTRACK_SHUTDOWN_RECD , SCTP_CONNTRACK_SHUTDOWN_ACK_SENT , SCTP_CONNTRACK_HEARTBEAT_SENT , SCTP_CONNTRACK_HEARTBEAT_ACKED , SCTP_CONNTRACK_MAX }
e#sk_rst_reason enum sk_rst_reason { SK_RST_REASON_NOT_SPECIFIED , SK_RST_REASON_NO_SOCKET , SK_RST_REASON_TCP_INVALID_ACK_SEQUENCE , SK_RST_REASON_TCP_RFC7323_PAWS , SK_RST_REASON_TCP_TOO_OLD_ACK , SK_RST_REASON_TCP_ACK_UNSENT_DATA , SK_RST_REASON_TCP_FLAGS , SK_RST_REASON_TCP_OLD_ACK , SK_RST_REASON_TCP_ABORT_ON_DATA , SK_RST_REASON_TCP_TIMEWAIT_SOCKET , SK_RST_REASON_INVALID_SYN , SK_RST_REASON_TCP_ABORT_ON_CLOSE , SK_RST_REASON_TCP_ABORT_ON_LINGER , SK_RST_REASON_TCP_ABORT_ON_MEMORY , SK_RST_REASON_TCP_STATE , SK_RST_REASON_TCP_KEEPALIVE_TIMEOUT , SK_RST_REASON_TCP_DISCONNECT_WITH_DATA , SK_RST_REASON_MPTCP_RST_EUNSPEC , SK_RST_REASON_MPTCP_RST_EMPTCP , SK_RST_REASON_MPTCP_RST_ERESOURCE , SK_RST_REASON_MPTCP_RST_EPROHIBIT , SK_RST_REASON_MPTCP_RST_EWQ2BIG , SK_RST_REASON_MPTCP_RST_EBADPERF , SK_RST_REASON_MPTCP_RST_EMIDDLEBOX , SK_RST_REASON_ERROR , SK_RST_REASON_MAX , }
e#svc_auth_status enum svc_auth_status { SVC_GARBAGE = 1 , SVC_SYSERR , SVC_VALID , SVC_NEGATIVE , SVC_OK , SVC_DROP , SVC_CLOSE , SVC_DENIED , SVC_PENDING , SVC_COMPLETE , }
e#switchdev_obj_id enum switchdev_obj_id { SWITCHDEV_OBJ_ID_UNDEFINED , SWITCHDEV_OBJ_ID_PORT_VLAN , SWITCHDEV_OBJ_ID_PORT_MDB , SWITCHDEV_OBJ_ID_HOST_MDB , SWITCHDEV_OBJ_ID_MRP , SWITCHDEV_OBJ_ID_RING_TEST_MRP , SWITCHDEV_OBJ_ID_RING_ROLE_MRP , SWITCHDEV_OBJ_ID_RING_STATE_MRP , SWITCHDEV_OBJ_ID_IN_TEST_MRP , SWITCHDEV_OBJ_ID_IN_ROLE_MRP , SWITCHDEV_OBJ_ID_IN_STATE_MRP , }
e#system_states extern enum system_states { SYSTEM_BOOTING , SYSTEM_SCHEDULING , SYSTEM_FREEING_INITMEM , SYSTEM_RUNNING , SYSTEM_HALT , SYSTEM_POWER_OFF , SYSTEM_RESTART , SYSTEM_SUSPEND , }
e#task_work_notify_mode enum task_work_notify_mode { TWA_NONE = 0 , TWA_RESUME , TWA_SIGNAL , TWA_SIGNAL_NO_IPI , TWA_NMI_CURRENT , TWA_FLAGS = 0xff00 , TWAF_NO_ALLOC = 0x0100 , }
e#tc_setup_type enum tc_setup_type { TC_QUERY_CAPS , TC_SETUP_QDISC_MQPRIO , TC_SETUP_CLSU32 , TC_SETUP_CLSFLOWER , TC_SETUP_CLSMATCHALL , TC_SETUP_CLSBPF , TC_SETUP_BLOCK , TC_SETUP_QDISC_CBS , TC_SETUP_QDISC_RED , TC_SETUP_QDISC_PRIO , TC_SETUP_QDISC_MQ , TC_SETUP_QDISC_ETF , TC_SETUP_ROOT_QDISC , TC_SETUP_QDISC_GRED , TC_SETUP_QDISC_TAPRIO , TC_SETUP_FT , TC_SETUP_QDISC_ETS , TC_SETUP_QDISC_TBF , TC_SETUP_QDISC_FIFO , TC_SETUP_QDISC_HTB , TC_SETUP_ACT , }
e#tca_id enum tca_id { TCA_ID_UNSPEC = 0 , TCA_ID_POLICE = 1 , TCA_ID_GACT = 5 , TCA_ID_IPT = 6 , TCA_ID_PEDIT = 7 , TCA_ID_MIRRED = 8 , TCA_ID_NAT = 9 , TCA_ID_XT = 10 , TCA_ID_SKBEDIT = 11 , TCA_ID_VLAN = 12 , TCA_ID_BPF = 13 , TCA_ID_CONNMARK = 14 , TCA_ID_SKBMOD = 15 , TCA_ID_CSUM = 16 , TCA_ID_TUNNEL_KEY = 17 , TCA_ID_SIMP = 22 , TCA_ID_IFE = 25 , TCA_ID_SAMPLE = 26 , TCA_ID_CTINFO , TCA_ID_MPLS , TCA_ID_CT , TCA_ID_GATE , __TCA_ID_MAX = 255 }
e#tcp_ca_event enum tcp_ca_event { CA_EVENT_TX_START , CA_EVENT_CWND_RESTART , CA_EVENT_COMPLETE_CWR , CA_EVENT_LOSS , CA_EVENT_ECN_NO_CE , CA_EVENT_ECN_IS_CE , }
e#timespec_type enum timespec_type { TT_NONE = 0 , TT_NATIVE = 1 , TT_COMPAT = 2 , }
e#tk_offsets enum tk_offsets { TK_OFFS_REAL , TK_OFFS_BOOT , TK_OFFS_TAI , TK_OFFS_MAX , }
e#tls_offload_ctx_dir enum tls_offload_ctx_dir { TLS_OFFLOAD_CTX_DIR_RX , TLS_OFFLOAD_CTX_DIR_TX , }
e#trace_reg enum trace_reg { TRACE_REG_REGISTER , TRACE_REG_UNREGISTER , TRACE_REG_PERF_REGISTER , TRACE_REG_PERF_UNREGISTER , TRACE_REG_PERF_OPEN , TRACE_REG_PERF_CLOSE , TRACE_REG_PERF_ADD , TRACE_REG_PERF_DEL , }
e#uprobe_task_state enum uprobe_task_state { UTASK_RUNNING , UTASK_SSTEP , UTASK_SSTEP_ACK , UTASK_SSTEP_TRAPPED , }
e#vtime_state enum vtime_state { VTIME_INACTIVE = 0 , VTIME_IDLE , VTIME_SYS , VTIME_USER , VTIME_GUEST , }
e#watch_notification_type enum watch_notification_type { WATCH_TYPE_META = 0 , WATCH_TYPE_KEY_NOTIFY = 1 , WATCH_TYPE__NR = 2 }
e#wb_reason enum wb_reason { WB_REASON_BACKGROUND , WB_REASON_VMSCAN , WB_REASON_SYNC , WB_REASON_PERIODIC , WB_REASON_LAPTOP_TIMER , WB_REASON_FS_FREE_SPACE , WB_REASON_FORKER_THREAD , WB_REASON_FOREIGN_FLUSH , WB_REASON_MAX , }
e#writeback_sync_modes enum writeback_sync_modes { WB_SYNC_NONE , WB_SYNC_ALL , }
e#xdp_rss_hash_type enum xdp_rss_hash_type { XDP_RSS_L3_IPV4 = ( ( ( ( 1UL ) ) ) << ( 0 ) ) , XDP_RSS_L3_IPV6 = ( ( ( ( 1UL ) ) ) << ( 1 ) ) , XDP_RSS_L3_DYNHDR = ( ( ( ( 1UL ) ) ) << ( 2 ) ) , XDP_RSS_L4 = ( ( ( ( 1UL ) ) ) << ( 3 ) ) , XDP_RSS_L4_TCP = ( ( ( ( 1UL ) ) ) << ( 4 ) ) , XDP_RSS_L4_UDP = ( ( ( ( 1UL ) ) ) << ( 5 ) ) , XDP_RSS_L4_SCTP = ( ( ( ( 1UL ) ) ) << ( 6 ) ) , XDP_RSS_L4_IPSEC = ( ( ( ( 1UL ) ) ) << ( 7 ) ) , XDP_RSS_L4_ICMP = ( ( ( ( 1UL ) ) ) << ( 8 ) ) , XDP_RSS_TYPE_NONE = 0 , XDP_RSS_TYPE_L2 = E#XDP_RSS_TYPE_NONE , XDP_RSS_TYPE_L3_IPV4 = E#XDP_RSS_L3_IPV4 , XDP_RSS_TYPE_L3_IPV6 = E#XDP_RSS_L3_IPV6 , XDP_RSS_TYPE_L3_IPV4_OPT = E#XDP_RSS_L3_IPV4 | E#XDP_RSS_L3_DYNHDR , XDP_RSS_TYPE_L3_IPV6_EX = E#XDP_RSS_L3_IPV6 | E#XDP_RSS_L3_DYNHDR , XDP_RSS_TYPE_L4_ANY = E#XDP_RSS_L4 , XDP_RSS_TYPE_L4_IPV4_TCP = E#XDP_RSS_L3_IPV4 | E#XDP_RSS_L4 | E#XDP_RSS_L4_TCP , XDP_RSS_TYPE_L4_IPV4_UDP = E#XDP_RSS_L3_IPV4 | E#XDP_RSS_L4 | E#XDP_RSS_L4_UDP , XDP_RSS_TYPE_L4_IPV4_SCTP = E#XDP_RSS_L3_IPV4 | E#XDP_RSS_L4 | E#XDP_RSS_L4_SCTP , XDP_RSS_TYPE_L4_IPV4_IPSEC = E#XDP_RSS_L3_IPV4 | E#XDP_RSS_L4 | E#XDP_RSS_L4_IPSEC , XDP_RSS_TYPE_L4_IPV4_ICMP = E#XDP_RSS_L3_IPV4 | E#XDP_RSS_L4 | E#XDP_RSS_L4_ICMP , XDP_RSS_TYPE_L4_IPV6_TCP = E#XDP_RSS_L3_IPV6 | E#XDP_RSS_L4 | E#XDP_RSS_L4_TCP , XDP_RSS_TYPE_L4_IPV6_UDP = E#XDP_RSS_L3_IPV6 | E#XDP_RSS_L4 | E#XDP_RSS_L4_UDP , XDP_RSS_TYPE_L4_IPV6_SCTP = E#XDP_RSS_L3_IPV6 | E#XDP_RSS_L4 | E#XDP_RSS_L4_SCTP , XDP_RSS_TYPE_L4_IPV6_IPSEC = E#XDP_RSS_L3_IPV6 | E#XDP_RSS_L4 | E#XDP_RSS_L4_IPSEC , XDP_RSS_TYPE_L4_IPV6_ICMP = E#XDP_RSS_L3_IPV6 | E#XDP_RSS_L4 | E#XDP_RSS_L4_ICMP , XDP_RSS_TYPE_L4_IPV6_TCP_EX = E#XDP_RSS_TYPE_L4_IPV6_TCP | E#XDP_RSS_L3_DYNHDR , XDP_RSS_TYPE_L4_IPV6_UDP_EX = E#XDP_RSS_TYPE_L4_IPV6_UDP | E#XDP_RSS_L3_DYNHDR , XDP_RSS_TYPE_L4_IPV6_SCTP_EX = E#XDP_RSS_TYPE_L4_IPV6_SCTP | E#XDP_RSS_L3_DYNHDR , }
e#xfrm_replay_mode enum xfrm_replay_mode { XFRM_REPLAY_MODE_LEGACY , XFRM_REPLAY_MODE_BMP , XFRM_REPLAY_MODE_ESN , }
e#xprtsec_policies enum xprtsec_policies { RPC_XPRTSEC_NONE = 0 , RPC_XPRTSEC_TLS_ANON , RPC_XPRTSEC_TLS_X509 , }
e#zone_type enum zone_type { ZONE_DMA , ZONE_DMA32 , ZONE_NORMAL , ZONE_MOVABLE , ZONE_DEVICE , __MAX_NR_ZONES }
edv_only_symbol void edv_only_symbol ( char [ 1 ] )
emergency_restart extern void emergency_restart ( void )
empty_zero_page extern unsigned long empty_zero_page [ ( ( 1UL ) << 12 ) / sizeof ( unsigned long ) ]
end_page_writeback void end_page_writeback ( s#page * )
fc_attach_transport s#scsi_transport_template * fc_attach_transport ( s#fc_function_template * )
fc_block_scsi_eh int fc_block_scsi_eh ( s#scsi_cmnd * )
fc_eh_timed_out e#scsi_timeout_action fc_eh_timed_out ( s#scsi_cmnd * )
fc_get_event_number t#u32 fc_get_event_number ( void )
fc_host_post_event void fc_host_post_event ( s#Scsi_Host * , t#u32 , e#fc_host_event_code , t#u32 )
fc_release_transport void fc_release_transport ( s#scsi_transport_template * )
fc_remote_port_add s#fc_rport * fc_remote_port_add ( s#Scsi_Host * , int , s#fc_rport_identifiers * )
fc_remote_port_delete void fc_remote_port_delete ( s#fc_rport * )
fc_remove_host void fc_remove_host ( s#Scsi_Host * )
fdget s#fd fdget ( unsigned int )
fget extern s#file * fget ( unsigned int )
fget_raw extern s#file * fget_raw ( unsigned int )
fiemap_fill_next_extent int fiemap_fill_next_extent ( s#fiemap_extent_info * , t#u64 , t#u64 , t#u64 , t#u32 )
fiemap_prep int fiemap_prep ( s#inode * , s#fiemap_extent_info * , t#u64 , t#u64 * , t#u32 )
file_bdev s#block_device * file_bdev ( s#file * )
filemap_dirty_folio t#bool filemap_dirty_folio ( s#address_space * , s#folio * )
filemap_fault extern t#vm_fault_t filemap_fault ( s#vm_fault * )
filemap_fdatawait_range int filemap_fdatawait_range ( s#address_space * , t#loff_t , t#loff_t )
filemap_fdatawrite int filemap_fdatawrite ( s#address_space * )
filemap_fdatawrite_range int filemap_fdatawrite_range ( s#address_space * , t#loff_t , t#loff_t )
filemap_flush int filemap_flush ( s#address_space * )
filemap_get_folios_tag unsigned filemap_get_folios_tag ( s#address_space * , unsigned long * , unsigned long , t#xa_mark_t , s#folio_batch * )
filemap_splice_read t#ssize_t filemap_splice_read ( s#file * , t#loff_t * , s#pipe_inode_info * , t#size_t , unsigned int )
filemap_write_and_wait_range int filemap_write_and_wait_range ( s#address_space * , t#loff_t , t#loff_t )
filp_close extern int filp_close ( s#file * , t#fl_owner_t )
filp_open extern s#file * filp_open ( const char * , int , t#umode_t )
find_vma extern s#vm_area_struct * find_vma ( s#mm_struct * , unsigned long )
finish_wait void finish_wait ( s#wait_queue_head * , s#wait_queue_entry * )
fixed_size_llseek extern t#loff_t fixed_size_llseek ( s#file * , t#loff_t , int , t#loff_t )
flush_signals extern void flush_signals ( s#task_struct * )
folio_mark_dirty t#bool folio_mark_dirty ( s#folio * )
folio_unlock void folio_unlock ( s#folio * )
folio_wait_bit void folio_wait_bit ( s#folio * , int )
follow_down_one extern int follow_down_one ( s#path * )
fput extern void fput ( s#file * )
free_buffer_head void free_buffer_head ( s#buffer_head * )
free_irq extern const void * free_irq ( unsigned int , void * )
free_pages extern void free_pages ( unsigned long , unsigned int )
free_percpu extern void free_percpu ( void * )
from_kgid extern t#gid_t from_kgid ( s#user_namespace * , t#kgid_t )
from_kuid extern t#uid_t from_kuid ( s#user_namespace * , t#kuid_t )
fs_bio_set extern s#bio_set fs_bio_set
fs_context_for_reconfigure extern s#fs_context * fs_context_for_reconfigure ( s#dentry * , unsigned int , unsigned int )
full_name_hash extern unsigned int __attribute__ ( ( __pure__ ) ) full_name_hash ( const void * , const char * , unsigned int )
generic_file_direct_write extern t#ssize_t generic_file_direct_write ( s#kiocb * , s#iov_iter * )
generic_file_llseek extern t#loff_t generic_file_llseek ( s#file * , t#loff_t , int )
generic_file_open extern int generic_file_open ( s#inode * , s#file * )
generic_file_read_iter extern t#ssize_t generic_file_read_iter ( s#kiocb * , s#iov_iter * )
generic_fillattr void generic_fillattr ( s#mnt_idmap * , t#u32 , s#inode * , s#kstat * )
generic_permission int generic_permission ( s#mnt_idmap * , s#inode * , int )
generic_write_checks extern t#ssize_t generic_write_checks ( s#kiocb * , s#iov_iter * )
get_device s#device * get_device ( s#device * )
get_free_pages_noprof extern unsigned long get_free_pages_noprof ( t#gfp_t , unsigned int )
get_random_bytes void get_random_bytes ( void * , t#size_t )
get_user_pages long get_user_pages ( unsigned long , unsigned long , unsigned int , s#page * * )
grab_cache_page_write_begin s#page * grab_cache_page_write_begin ( s#address_space * , unsigned long )
hugetlb_optimize_vmemmap_key extern s#static_key_false hugetlb_optimize_vmemmap_key
igrab extern s#inode * igrab ( s#inode * )
in_group_p extern int in_group_p ( t#kgid_t )
inc_nlink extern void inc_nlink ( s#inode * )
init_net extern s#net init_net
init_special_inode extern void init_special_inode ( s#inode * , t#umode_t , t#dev_t )
init_task extern s#task_struct init_task
init_timer_key void init_timer_key ( s#timer_list * , void ( * ) ( s#timer_list * ) , unsigned int , const char * , s#lock_class_key * )
init_wait_entry extern void init_wait_entry ( s#wait_queue_entry * , int )
inode_init_once extern void inode_init_once ( s#inode * )
inode_newsize_ok extern int inode_newsize_ok ( const s#inode * , t#loff_t )
int_to_scsilun extern void int_to_scsilun ( t#u64 , s#scsi_lun * )
invalidate_inode_buffers void invalidate_inode_buffers ( s#inode * )
invalidate_mapping_pages unsigned long invalidate_mapping_pages ( s#address_space * , unsigned long , unsigned long )
io_schedule extern void io_schedule ( void )
ioread32 extern unsigned int ioread32 ( const void * )
ioread8 extern unsigned int ioread8 ( const void * )
ioremap void * ioremap ( t#resource_size_t , unsigned long )
iounmap extern void iounmap ( volatile void * )
iov_iter_bvec void iov_iter_bvec ( s#iov_iter * , unsigned int , const s#bio_vec * , unsigned long , t#size_t )
iov_iter_get_pages2 t#ssize_t iov_iter_get_pages2 ( s#iov_iter * , s#page * * , t#size_t , unsigned , t#size_t * )
iov_iter_init void iov_iter_init ( s#iov_iter * , unsigned int , const s#iovec * , unsigned long , t#size_t )
iov_iter_kvec void iov_iter_kvec ( s#iov_iter * , unsigned int , const s#kvec * , unsigned long , t#size_t )
iov_iter_npages int iov_iter_npages ( const s#iov_iter * , int )
iowrite32 extern void iowrite32 ( t#u32 , void * )
iput extern void iput ( s#inode * )
irq_get_irq_data extern s#irq_data * irq_get_irq_data ( unsigned int )
is_vmalloc_addr extern t#bool is_vmalloc_addr ( const void * )
iter_file_splice_write extern t#ssize_t iter_file_splice_write ( s#pipe_inode_info * , s#file * , t#loff_t * , t#size_t , unsigned int )
jiffies extern unsigned long volatile __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) , __section__ ( ".data..cacheline_aligned" ) ) ) jiffies
jiffies_to_msecs extern unsigned int jiffies_to_msecs ( const unsigned long )
jiffies_to_timespec64 extern void jiffies_to_timespec64 ( const unsigned long , s#timespec64 * )
jiffies_to_usecs extern unsigned int jiffies_to_usecs ( const unsigned long )
kblockd_mod_delayed_work_on int kblockd_mod_delayed_work_on ( int , s#delayed_work * , unsigned long )
kern_path extern int kern_path ( const char * , unsigned , s#path * )
kern_path_create extern s#dentry * kern_path_create ( int , const char * , s#path * , unsigned int )
kernel_accept int kernel_accept ( s#socket * , s#socket * * , int )
kernel_read extern t#ssize_t kernel_read ( s#file * , void * , t#size_t , t#loff_t * )
kernel_recvmsg int kernel_recvmsg ( s#socket * , s#msghdr * , s#kvec * , t#size_t , t#size_t , int )
kernel_sendmsg int kernel_sendmsg ( s#socket * , s#msghdr * , s#kvec * , t#size_t , t#size_t )
kernel_write extern t#ssize_t kernel_write ( s#file * , const void * , t#size_t , t#loff_t * )
kfree void kfree ( const void * )
kill_block_super void kill_block_super ( s#super_block * )
kill_pid extern int kill_pid ( s#pid * , int , int )
kmalloc_caches extern t#kmem_buckets kmalloc_caches [ E#NR_KMALLOC_TYPES ]
kmem_cache_alloc_noprof void * kmem_cache_alloc_noprof ( s#kmem_cache * , t#gfp_t )
kmem_cache_destroy void kmem_cache_destroy ( s#kmem_cache * )
kmem_cache_free void kmem_cache_free ( s#kmem_cache * , void * )
kstrtoint int __attribute__ ( ( __warn_unused_result__ ) ) kstrtoint ( const char * , unsigned int , int * )
kstrtou8 int __attribute__ ( ( __warn_unused_result__ ) ) kstrtou8 ( const char * , unsigned int , t#u8 * )
kstrtoull int __attribute__ ( ( __warn_unused_result__ ) ) kstrtoull ( const char * , unsigned int , unsigned long long * )
kthread_complete_and_exit void kthread_complete_and_exit ( s#completion * , long )
kthread_create_on_node __attribute__ ( ( __format__ ( printf , 4 , 5 ) ) ) s#task_struct * kthread_create_on_node ( int ( * ) ( void * ) , void * , int , const char [ ] , ... )
kthread_should_stop t#bool kthread_should_stop ( void )
kthread_stop int kthread_stop ( s#task_struct * )
ktime_get_coarse_real_ts64 extern void ktime_get_coarse_real_ts64 ( s#timespec64 * )
ktime_get_coarse_ts64 extern void ktime_get_coarse_ts64 ( s#timespec64 * )
ktime_get_real_seconds extern t#time64_t ktime_get_real_seconds ( void )
ktime_get_real_ts64 extern void ktime_get_real_ts64 ( s#timespec64 * )
ktime_get_ts64 extern void ktime_get_ts64 ( s#timespec64 * )
lock_rename extern s#dentry * lock_rename ( s#dentry * , s#dentry * )
lockref_get extern void lockref_get ( s#lockref * )
locks_init_lock void locks_init_lock ( s#file_lock * )
locks_lock_inode_wait int locks_lock_inode_wait ( s#inode * , s#file_lock * )
lookup_one_len extern s#dentry * lookup_one_len ( const char * , s#dentry * , int )
make_kgid extern t#kgid_t make_kgid ( s#user_namespace * , t#gid_t )
make_kuid extern t#kuid_t make_kuid ( s#user_namespace * , t#uid_t )
match_token int match_token ( char * , const t#match_table_t , t#substring_t [ ] )
memcmp int memcmp ( const void * , const void * , t#size_t )
memcpy extern void * memcpy ( void * , const void * , t#size_t )
memcpy_fromio void memcpy_fromio ( void * , const volatile void * , t#size_t )
memcpy_toio void memcpy_toio ( volatile void * , const void * , t#size_t )
memmove void * memmove ( void * , const void * , t#size_t )
mempool_alloc_noprof extern void * mempool_alloc_noprof ( t#mempool_t * , t#gfp_t )
mempool_alloc_slab void * mempool_alloc_slab ( t#gfp_t , void * )
mempool_create_node_noprof extern t#mempool_t * mempool_create_node_noprof ( int , t#mempool_alloc_t * , t#mempool_free_t * , void * , t#gfp_t , int )
mempool_destroy extern void mempool_destroy ( t#mempool_t * )
mempool_free extern void mempool_free ( void * , t#mempool_t * )
mempool_free_slab void mempool_free_slab ( void * , void * )
memset void * memset ( void * , int , t#size_t )
mntput extern void mntput ( s#vfsmount * )
mod_timer extern int mod_timer ( s#timer_list * , unsigned long )
module_put extern void module_put ( s#module * )
mount_bdev extern s#dentry * mount_bdev ( s#file_system_type * , int , const char * , void * , int ( * ) ( s#super_block * , void * , int ) )
mpage_read_folio int mpage_read_folio ( s#folio * , t#get_block_t )
mpage_readahead void mpage_readahead ( s#readahead_control * , t#get_block_t )
mpage_writepages int mpage_writepages ( s#address_space * , s#writeback_control * , t#get_block_t )
msleep void msleep ( unsigned int )
msleep_interruptible unsigned long msleep_interruptible ( unsigned int )
mutex_is_locked extern t#bool mutex_is_locked ( s#mutex * )
mutex_lock extern void mutex_lock ( s#mutex * )
mutex_trylock extern int mutex_trylock ( s#mutex * )
mutex_unlock extern void mutex_unlock ( s#mutex * )
names_cachep extern s#kmem_cache * names_cachep
new_inode extern s#inode * new_inode ( s#super_block * )
node_states extern t#nodemask_t node_states [ E#NR_NODE_STATES ]
node_to_cpumask_map extern t#cpumask_var_t node_to_cpumask_map [ ( 1 << 10 ) ]
nr_cpu_ids extern unsigned int nr_cpu_ids
numa_node extern __attribute__ ( ( section ( ".data..percpu" "" ) ) ) __typeof__ ( int ) numa_node
nvme_fc_register_localport int nvme_fc_register_localport ( s#nvme_fc_port_info * , s#nvme_fc_port_template * , s#device * , s#nvme_fc_local_port * * )
nvme_fc_register_remoteport int nvme_fc_register_remoteport ( s#nvme_fc_local_port * , s#nvme_fc_port_info * , s#nvme_fc_remote_port * * )
nvme_fc_set_remoteport_devloss int nvme_fc_set_remoteport_devloss ( s#nvme_fc_remote_port * , t#u32 )
nvme_fc_unregister_localport int nvme_fc_unregister_localport ( s#nvme_fc_local_port * )
nvme_fc_unregister_remoteport int nvme_fc_unregister_remoteport ( s#nvme_fc_remote_port * )
override_creds extern const s#cred * override_creds ( const s#cred * )
page_offset_base extern unsigned long page_offset_base
panic __attribute__ ( ( __format__ ( printf , 1 , 2 ) ) ) void panic ( const char * , ... )
param_ops_charp extern const s#kernel_param_ops param_ops_charp
param_ops_int extern const s#kernel_param_ops param_ops_int
param_ops_long extern const s#kernel_param_ops param_ops_long
param_ops_uint extern const s#kernel_param_ops param_ops_uint
path_get extern void path_get ( const s#path * )
path_put extern void path_put ( const s#path * )
pci_alloc_irq_vectors int pci_alloc_irq_vectors ( s#pci_dev * , unsigned int , unsigned int , unsigned int )
pci_disable_device void pci_disable_device ( s#pci_dev * )
pci_enable_device int __attribute__ ( ( __warn_unused_result__ ) ) pci_enable_device ( s#pci_dev * )
pci_free_irq_vectors void pci_free_irq_vectors ( s#pci_dev * )
pci_iomap extern void * pci_iomap ( s#pci_dev * , int , unsigned long )
pci_irq_vector int pci_irq_vector ( s#pci_dev * , unsigned int )
pci_read_config_word int pci_read_config_word ( const s#pci_dev * , int , t#u16 * )
pci_release_regions void pci_release_regions ( s#pci_dev * )
pci_request_regions int __attribute__ ( ( __warn_unused_result__ ) ) pci_request_regions ( s#pci_dev * , const char * )
pci_set_master void pci_set_master ( s#pci_dev * )
pci_unregister_driver void pci_unregister_driver ( s#pci_driver * )
pcie_capability_clear_and_set_word_unlocked int pcie_capability_clear_and_set_word_unlocked ( s#pci_dev * , int , t#u16 , t#u16 )
pcpu_alloc_noprof extern void * pcpu_alloc_noprof ( t#size_t , t#size_t , t#bool , t#gfp_t )
pcpu_hot extern __attribute__ ( ( section ( ".data..percpu" "..shared_aligned" ) ) ) __typeof__ ( s#pcpu_hot ) pcpu_hot
phys_base extern unsigned long phys_base
physical_mask extern t#phys_addr_t physical_mask
pid_task extern s#task_struct * pid_task ( s#pid * , e#pid_type )
posix_lock_file int posix_lock_file ( s#file * , s#file_lock * , s#file_lock * )
posix_test_lock void posix_test_lock ( s#file * , s#file_lock * )
prepare_creds extern s#cred * prepare_creds ( void )
prepare_kernel_cred extern s#cred * prepare_kernel_cred ( s#task_struct * )
prepare_to_wait void prepare_to_wait ( s#wait_queue_head * , s#wait_queue_entry * , int )
prepare_to_wait_event long prepare_to_wait_event ( s#wait_queue_head * , s#wait_queue_entry * , int )
prepare_to_wait_exclusive t#bool prepare_to_wait_exclusive ( s#wait_queue_head * , s#wait_queue_entry * , int )
proc_create s#proc_dir_entry * proc_create ( const char * , t#umode_t , s#proc_dir_entry * , const s#proc_ops * )
proc_create_data extern s#proc_dir_entry * proc_create_data ( const char * , t#umode_t , s#proc_dir_entry * , const s#proc_ops * , void * )
proc_mkdir extern s#proc_dir_entry * proc_mkdir ( const char * , s#proc_dir_entry * )
put_disk void put_disk ( s#gendisk * )
put_fs_context extern void put_fs_context ( s#fs_context * )
pv_ops extern s#paravirt_patch_template pv_ops
queue_delayed_work_on extern t#bool queue_delayed_work_on ( int , s#workqueue_struct * , s#delayed_work * , unsigned long )
queue_work_on extern t#bool queue_work_on ( int , s#workqueue_struct * , s#work_struct * )
random_kmalloc_seed extern unsigned long random_kmalloc_seed
read_cache_folio s#folio * read_cache_folio ( s#address_space * , unsigned long , t#filler_t * , s#file * )
recalc_sigpending extern void recalc_sigpending ( void )
redirty_page_for_writepage t#bool redirty_page_for_writepage ( s#writeback_control * , s#page * )
register_filesystem extern int register_filesystem ( s#file_system_type * )
register_reboot_notifier extern int register_reboot_notifier ( s#notifier_block * )
release_pages void release_pages ( t#release_pages_arg , int )
remap_pfn_range int remap_pfn_range ( s#vm_area_struct * , unsigned long , unsigned long , unsigned long , t#pgprot_t )
remove_proc_entry extern void remove_proc_entry ( const char * , s#proc_dir_entry * )
remove_wait_queue extern void remove_wait_queue ( s#wait_queue_head * , s#wait_queue_entry * )
rep_movs_alternative __attribute__ ( ( __warn_unused_result__ ) ) unsigned long rep_movs_alternative ( void * , const void * , unsigned )
request_threaded_irq extern int __attribute__ ( ( __warn_unused_result__ ) ) request_threaded_irq ( unsigned int , t#irq_handler_t , t#irq_handler_t , unsigned long , const char * , void * )
reset_devices extern unsigned int reset_devices
revert_creds extern void revert_creds ( const s#cred * )
round_jiffies unsigned long round_jiffies ( unsigned long )
s#Qdisc@ccf40764 struct Qdisc { UNKNOWN }
s#Qdisc@d0f221a6 struct Qdisc { int ( * enqueue ) ( s#sk_buff * , s#Qdisc * , s#sk_buff * * ) ; s#sk_buff * ( * dequeue ) ( s#Qdisc * ) ; unsigned int flags ; t#u32 limit ; const s#Qdisc_ops * ops ; s#qdisc_size_table * stab ; s#hlist_node hash ; t#u32 handle ; t#u32 parent ; s#netdev_queue * dev_queue ; s#net_rate_estimator * rate_est ; s#gnet_stats_basic_sync * cpu_bstats ; s#gnet_stats_queue * cpu_qstats ; int pad ; t#refcount_t refcnt ; s#sk_buff_head gso_skb __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; s#qdisc_skb_head q ; s#gnet_stats_basic_sync bstats ; s#gnet_stats_queue qstats ; int owner ; unsigned long state ; unsigned long state2 ; s#Qdisc * next_sched ; s#sk_buff_head skb_bad_txq ; t#spinlock_t busylock __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; t#spinlock_t seqlock ; s#callback_head rcu ; t#netdevice_tracker dev_tracker ; s#lock_class_key root_lock_key ; long privdata [ ] __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; }
s#Qdisc_class_ops struct Qdisc_class_ops { unsigned int flags ; s#netdev_queue * ( * select_queue ) ( s#Qdisc * , s#tcmsg * ) ; int ( * graft ) ( s#Qdisc * , unsigned long , s#Qdisc * , s#Qdisc * * , s#netlink_ext_ack * ) ; s#Qdisc * ( * leaf ) ( s#Qdisc * , unsigned long ) ; void ( * qlen_notify ) ( s#Qdisc * , unsigned long ) ; unsigned long ( * find ) ( s#Qdisc * , t#u32 ) ; int ( * change ) ( s#Qdisc * , t#u32 , t#u32 , s#nlattr * * , unsigned long * , s#netlink_ext_ack * ) ; int ( * delete ) ( s#Qdisc * , unsigned long , s#netlink_ext_ack * ) ; void ( * walk ) ( s#Qdisc * , s#qdisc_walker * ) ; s#tcf_block * ( * tcf_block ) ( s#Qdisc * , unsigned long , s#netlink_ext_ack * ) ; unsigned long ( * bind_tcf ) ( s#Qdisc * , unsigned long , t#u32 ) ; void ( * unbind_tcf ) ( s#Qdisc * , unsigned long ) ; int ( * dump ) ( s#Qdisc * , unsigned long , s#sk_buff * , s#tcmsg * ) ; int ( * dump_stats ) ( s#Qdisc * , unsigned long , s#gnet_dump * ) ; }
s#Qdisc_ops struct Qdisc_ops { s#Qdisc_ops * next ; const s#Qdisc_class_ops * cl_ops ; char id [ 16 ] ; int priv_size ; unsigned int static_flags ; int ( * enqueue ) ( s#sk_buff * , s#Qdisc * , s#sk_buff * * ) ; s#sk_buff * ( * dequeue ) ( s#Qdisc * ) ; s#sk_buff * ( * peek ) ( s#Qdisc * ) ; int ( * init ) ( s#Qdisc * , s#nlattr * , s#netlink_ext_ack * ) ; void ( * reset ) ( s#Qdisc * ) ; void ( * destroy ) ( s#Qdisc * ) ; int ( * change ) ( s#Qdisc * , s#nlattr * , s#netlink_ext_ack * ) ; void ( * attach ) ( s#Qdisc * ) ; int ( * change_tx_queue_len ) ( s#Qdisc * , unsigned int ) ; void ( * change_real_num_tx ) ( s#Qdisc * , unsigned int ) ; int ( * dump ) ( s#Qdisc * , s#sk_buff * ) ; int ( * dump_stats ) ( s#Qdisc * , s#gnet_dump * ) ; void ( * ingress_block_set ) ( s#Qdisc * , t#u32 ) ; void ( * egress_block_set ) ( s#Qdisc * , t#u32 ) ; t#u32 ( * ingress_block_get ) ( s#Qdisc * ) ; t#u32 ( * egress_block_get ) ( s#Qdisc * ) ; s#module * owner ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#Scsi_Host@4576714a struct Scsi_Host { UNKNOWN }
s#Scsi_Host@b4eb472f struct Scsi_Host { s#list_head __devices ; s#list_head __targets ; s#list_head starved_list ; t#spinlock_t default_lock ; t#spinlock_t * host_lock ; s#mutex scan_mutex ; s#list_head eh_abort_list ; s#list_head eh_cmd_q ; s#task_struct * ehandler ; s#completion * eh_action ; t#wait_queue_head_t host_wait ; const s#scsi_host_template * hostt ; s#scsi_transport_template * transportt ; s#kref tagset_refcnt ; s#completion tagset_freed ; s#blk_mq_tag_set tag_set ; t#atomic_t host_blocked ; unsigned int host_failed ; unsigned int host_eh_scheduled ; unsigned int host_no ; int eh_deadline ; unsigned long last_reset ; unsigned int max_channel ; unsigned int max_id ; t#u64 max_lun ; unsigned int unique_id ; unsigned short max_cmd_len ; int this_id ; int can_queue ; short cmd_per_lun ; short unsigned int sg_tablesize ; short unsigned int sg_prot_tablesize ; unsigned int max_sectors ; unsigned int opt_sectors ; unsigned int max_segment_size ; unsigned int dma_alignment ; unsigned long dma_boundary ; unsigned long virt_boundary_mask ; unsigned nr_hw_queues ; unsigned nr_maps ; unsigned active_mode : 2 ; unsigned host_self_blocked : 1 ; unsigned reverse_ordering : 1 ; unsigned tmf_in_progress : 1 ; unsigned async_scan : 1 ; unsigned eh_noresume : 1 ; unsigned no_write_same : 1 ; unsigned host_tagset : 1 ; unsigned queuecommand_may_block : 1 ; unsigned short_inquiry : 1 ; unsigned no_scsi2_lun_in_cdb : 1 ; unsigned no_highmem : 1 ; s#workqueue_struct * work_q ; s#workqueue_struct * tmf_work_q ; unsigned int max_host_blocked ; unsigned int prot_capabilities ; unsigned char prot_guard_type ; unsigned long base ; unsigned long io_port ; unsigned char n_io_port ; unsigned char dma_channel ; unsigned int irq ; e#scsi_host_state shost_state ; s#device shost_gendev , shost_dev ; void * shost_data ; s#device * dma_dev ; int rpm_autosuspend_delay ; unsigned long hostdata [ ] __attribute__ ( ( aligned ( sizeof ( unsigned long ) ) ) ) ; }
s#__call_single_data struct __call_single_data { s#__call_single_node node ; t#smp_call_func_t func ; void * info ; }
s#__call_single_node struct __call_single_node { s#llist_node llist ; union { unsigned int u_flags ; t#atomic_t a_flags ; } ; t#u16 src , dst ; }
s#__kernel_sockaddr_storage struct __kernel_sockaddr_storage { union { struct { t#__kernel_sa_family_t ss_family ; char __data [ 128 - sizeof ( unsigned short ) ] ; } ; void * __align ; } ; }
s#__kernel_timespec struct __kernel_timespec { t#__kernel_time64_t tv_sec ; long long tv_nsec ; }
s#__kfifo struct __kfifo { unsigned int in ; unsigned int out ; unsigned int mask ; unsigned int esize ; void * data ; }
s#_ddebug struct _ddebug { const char * modname ; const char * function ; const char * filename ; const char * format ; unsigned int lineno : 18 ; unsigned int class_id : 6 ; unsigned int flags : 8 ; union { s#static_key_true dd_key_true ; s#static_key_false dd_key_false ; } key ; }
s#_ddebug_info struct _ddebug_info { s#_ddebug * descs ; s#ddebug_class_map * classes ; unsigned int num_descs ; unsigned int num_classes ; }
s#ack_sample struct ack_sample { t#u32 pkts_acked ; t#s32 rtt_us ; t#u32 in_flight ; }
s#acpi_device_id@893be69a struct acpi_device_id { t#__u8 id [ 16 ] ; t#kernel_ulong_t driver_data ; t#__u32 cls ; t#__u32 cls_msk ; }
s#acpi_device_id@e58a0b4f struct acpi_device_id { UNKNOWN }
s#action_gate_entry@40244239 struct action_gate_entry { UNKNOWN }
s#action_gate_entry@61d4a29a struct action_gate_entry { t#u8 gate_state ; t#u32 interval ; t#s32 ipv ; t#s32 maxoctets ; }
s#address_space@349a6ef4 struct address_space { UNKNOWN }
s#address_space@c94b877f struct address_space { s#inode * host ; s#xarray i_pages ; s#rw_semaphore invalidate_lock ; t#gfp_t gfp_mask ; t#atomic_t i_mmap_writable ; t#atomic_t nr_thps ; s#rb_root_cached i_mmap ; unsigned long nrpages ; unsigned long writeback_index ; const s#address_space_operations * a_ops ; unsigned long flags ; t#errseq_t wb_err ; t#spinlock_t i_private_lock ; s#list_head i_private_list ; s#rw_semaphore i_mmap_rwsem ; void * i_private_data ; }
s#address_space_operations struct address_space_operations { int ( * writepage ) ( s#page * , s#writeback_control * ) ; int ( * read_folio ) ( s#file * , s#folio * ) ; int ( * writepages ) ( s#address_space * , s#writeback_control * ) ; t#bool ( * dirty_folio ) ( s#address_space * , s#folio * ) ; void ( * readahead ) ( s#readahead_control * ) ; int ( * write_begin ) ( s#file * , s#address_space * , t#loff_t , unsigned , s#folio * * , void * * ) ; int ( * write_end ) ( s#file * , s#address_space * , t#loff_t , unsigned , unsigned , s#folio * , void * ) ; t#sector_t ( * bmap ) ( s#address_space * , t#sector_t ) ; void ( * invalidate_folio ) ( s#folio * , t#size_t , t#size_t ) ; t#bool ( * release_folio ) ( s#folio * , t#gfp_t ) ; void ( * free_folio ) ( s#folio * ) ; t#ssize_t ( * direct_IO ) ( s#kiocb * , s#iov_iter * ) ; int ( * migrate_folio ) ( s#address_space * , s#folio * , s#folio * , e#migrate_mode ) ; int ( * launder_folio ) ( s#folio * ) ; t#bool ( * is_partially_uptodate ) ( s#folio * , t#size_t , t#size_t ) ; void ( * is_dirty_writeback ) ( s#folio * , t#bool * , t#bool * ) ; int ( * error_remove_folio ) ( s#address_space * , s#folio * ) ; int ( * swap_activate ) ( s#swap_info_struct * , s#file * , t#sector_t * ) ; void ( * swap_deactivate ) ( s#file * ) ; int ( * swap_rw ) ( s#kiocb * , s#iov_iter * ) ; }
s#aer_stats struct aer_stats { UNKNOWN }
s#affinity_context struct affinity_context { const s#cpumask * new_mask ; s#cpumask * user_mask ; unsigned int flags ; }
s#anon_vma@19f7762e struct anon_vma { s#anon_vma * root ; s#rw_semaphore rwsem ; t#atomic_t refcount ; unsigned long num_children ; unsigned long num_active_vmas ; s#anon_vma * parent ; s#rb_root_cached rb_root ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#anon_vma@ca7d7321 struct anon_vma { UNKNOWN }
s#arch_hw_breakpoint struct arch_hw_breakpoint { unsigned long address ; unsigned long mask ; t#u8 len ; t#u8 type ; }
s#arch_tlbflush_unmap_batch struct arch_tlbflush_unmap_batch { s#cpumask cpumask ; }
s#arch_uprobe struct arch_uprobe { union { t#u8 insn [ 16 ] ; t#u8 ixol [ 16 ] ; } ; const s#uprobe_xol_ops * ops ; union { struct { t#s32 offs ; t#u8 ilen ; t#u8 opc1 ; } branch ; struct { t#u8 fixups ; t#u8 ilen ; } defparam ; struct { t#u8 reg_offset ; t#u8 ilen ; } push ; } ; }
s#arch_uprobe_task struct arch_uprobe_task { unsigned long saved_scratch_register ; unsigned int saved_trap_nr ; unsigned int saved_tf ; }
s#array_buffer@2a586a21 struct array_buffer { s#trace_array * tr ; s#trace_buffer * buffer ; s#trace_array_cpu * data ; t#u64 time_start ; int cpu ; }
s#array_buffer@3614c36d struct array_buffer { UNKNOWN }
s#assoc_array struct assoc_array { s#assoc_array_ptr * root ; unsigned long nr_leaves_on_tree ; }
s#assoc_array_ptr struct assoc_array_ptr { UNKNOWN }
s#async_poll struct async_poll { UNKNOWN }
s#attribute struct attribute { const char * name ; t#umode_t mode ; }
s#attribute_container struct attribute_container { s#list_head node ; s#klist containers ; s#class * class ; const s#attribute_group * grp ; s#device_attribute * * attrs ; int ( * match ) ( s#attribute_container * , s#device * ) ; unsigned long flags ; }
s#attribute_group struct attribute_group { const char * name ; t#umode_t ( * is_visible ) ( s#kobject * , s#attribute * , int ) ; t#umode_t ( * is_bin_visible ) ( s#kobject * , s#bin_attribute * , int ) ; s#attribute * * attrs ; s#bin_attribute * * bin_attrs ; }
s#audit_aux_data struct audit_aux_data { UNKNOWN }
s#audit_cap_data struct audit_cap_data { t#kernel_cap_t permitted ; t#kernel_cap_t inheritable ; union { unsigned int fE ; t#kernel_cap_t effective ; } ; t#kernel_cap_t ambient ; t#kuid_t rootid ; }
s#audit_context@382c83ee struct audit_context { UNKNOWN }
s#audit_context@b8c81a55 struct audit_context { int dummy ; enum { AUDIT_CTX_UNUSED , AUDIT_CTX_SYSCALL , AUDIT_CTX_URING , } context ; e#audit_state state , current_state ; unsigned int serial ; int major ; int uring_op ; s#timespec64 ctime ; unsigned long argv [ 4 ] ; long return_code ; t#u64 prio ; int return_valid ; s#audit_names preallocated_names [ 5 ] ; int name_count ; s#list_head names_list ; char * filterkey ; s#path pwd ; s#audit_aux_data * aux ; s#audit_aux_data * aux_pids ; s#__kernel_sockaddr_storage * sockaddr ; t#size_t sockaddr_len ; t#pid_t ppid ; t#kuid_t uid , euid , suid , fsuid ; t#kgid_t gid , egid , sgid , fsgid ; unsigned long personality ; int arch ; t#pid_t target_pid ; t#kuid_t target_auid ; t#kuid_t target_uid ; unsigned int target_sessionid ; t#u32 target_sid ; char target_comm [ E#TASK_COMM_LEN ] ; s#audit_tree_refs * trees , * first_trees ; s#list_head killed_trees ; int tree_count ; int type ; union { struct { int nargs ; long args [ 6 ] ; } socketcall ; struct { t#kuid_t uid ; t#kgid_t gid ; t#umode_t mode ; t#u32 osid ; int has_perm ; t#uid_t perm_uid ; t#gid_t perm_gid ; t#umode_t perm_mode ; unsigned long qbytes ; } ipc ; struct { t#mqd_t mqdes ; s#mq_attr mqstat ; } mq_getsetattr ; struct { t#mqd_t mqdes ; int sigev_signo ; } mq_notify ; struct { t#mqd_t mqdes ; t#size_t msg_len ; unsigned int msg_prio ; s#timespec64 abs_timeout ; } mq_sendrecv ; struct { int oflag ; t#umode_t mode ; s#mq_attr attr ; } mq_open ; struct { t#pid_t pid ; s#audit_cap_data cap ; } capset ; struct { int fd ; int flags ; } mmap ; s#open_how openat2 ; struct { int argc ; } execve ; struct { char * name ; } module ; struct { s#audit_ntp_data ntp_data ; s#timespec64 tk_injoffset ; } time ; } ; int fds [ 2 ] ; s#audit_proctitle proctitle ; }
s#audit_names@7d86a629 struct audit_names { UNKNOWN }
s#audit_names@aeaa93f5 struct audit_names { s#list_head list ; s#filename * name ; int name_len ; t#bool hidden ; unsigned long ino ; t#dev_t dev ; t#umode_t mode ; t#kuid_t uid ; t#kgid_t gid ; t#dev_t rdev ; t#u32 osid ; s#audit_cap_data fcap ; unsigned int fcap_ver ; unsigned char type ; t#bool should_free ; }
s#audit_ntp_data struct audit_ntp_data { s#audit_ntp_val vals [ E#AUDIT_NTP_NVALS ] ; }
s#audit_ntp_val struct audit_ntp_val { long long oldval , newval ; }
s#audit_proctitle struct audit_proctitle { int len ; char * value ; }
s#audit_tree_refs struct audit_tree_refs { UNKNOWN }
s#auth_cred struct auth_cred { const s#cred * cred ; const char * principal ; }
s#auth_domain struct auth_domain { s#kref ref ; s#hlist_node hash ; char * name ; s#auth_ops * flavour ; s#callback_head callback_head ; }
s#auth_ops struct auth_ops { char * name ; s#module * owner ; int flavour ; e#svc_auth_status ( * accept ) ( s#svc_rqst * ) ; int ( * release ) ( s#svc_rqst * ) ; void ( * domain_release ) ( s#auth_domain * ) ; e#svc_auth_status ( * set_client ) ( s#svc_rqst * ) ; t#rpc_authflavor_t ( * pseudoflavor ) ( s#svc_rqst * ) ; }
s#auto_mode_param struct auto_mode_param { int qp_type ; }
s#backing_dev_info@338fca9c struct backing_dev_info { UNKNOWN }
s#backing_dev_info@bd4ed559 struct backing_dev_info { t#u64 id ; s#rb_node rb_node ; s#list_head bdi_list ; unsigned long ra_pages ; unsigned long io_pages ; s#kref refcnt ; unsigned int capabilities ; unsigned int min_ratio ; unsigned int max_ratio , max_prop_frac ; t#atomic_long_t tot_write_bandwidth ; unsigned long last_bdp_sleep ; s#bdi_writeback wb ; s#list_head wb_list ; s#xarray cgwb_tree ; s#mutex cgwb_release_mutex ; s#rw_semaphore wb_switch_rwsem ; t#wait_queue_head_t wb_waitq ; s#device * dev ; char dev_name [ 64 ] ; s#device * owner ; s#timer_list laptop_mode_wb_timer ; s#dentry * debug_dir ; }
s#backtrack_state struct backtrack_state { s#bpf_verifier_env * env ; t#u32 frame ; t#u32 reg_masks [ 8 ] ; t#u64 stack_masks [ 8 ] ; }
s#badblocks@7e65f071 struct badblocks { UNKNOWN }
s#badblocks@e8137038 struct badblocks { s#device * dev ; int count ; int unacked_exist ; int shift ; t#u64 * page ; int changed ; t#seqlock_t lock ; t#sector_t sector ; t#sector_t size ; }
s#balance_callback struct balance_callback { s#balance_callback * next ; void ( * func ) ( s#rq * ) ; }
s#bdi_writeback@6b721080 struct bdi_writeback { UNKNOWN }
s#bdi_writeback@f123c24b struct bdi_writeback { s#backing_dev_info * bdi ; unsigned long state ; unsigned long last_old_flush ; s#list_head b_dirty ; s#list_head b_io ; s#list_head b_more_io ; s#list_head b_dirty_time ; t#spinlock_t list_lock ; t#atomic_t writeback_inodes ; s#percpu_counter stat [ E#NR_WB_STAT_ITEMS ] ; unsigned long bw_time_stamp ; unsigned long dirtied_stamp ; unsigned long written_stamp ; unsigned long write_bandwidth ; unsigned long avg_write_bandwidth ; unsigned long dirty_ratelimit ; unsigned long balanced_dirty_ratelimit ; s#fprop_local_percpu completions ; int dirty_exceeded ; e#wb_reason start_all_reason ; t#spinlock_t work_lock ; s#list_head work_list ; s#delayed_work dwork ; s#delayed_work bw_dwork ; s#list_head bdi_node ; s#percpu_ref refcnt ; s#fprop_local_percpu memcg_completions ; s#cgroup_subsys_state * memcg_css ; s#cgroup_subsys_state * blkcg_css ; s#list_head memcg_node ; s#list_head blkcg_node ; s#list_head b_attached ; s#list_head offline_node ; union { s#work_struct release_work ; s#callback_head rcu ; } ; }
s#bin_attribute struct bin_attribute { s#attribute attr ; t#size_t size ; void * private ; s#address_space * ( * f_mapping ) ( void ) ; t#ssize_t ( * read ) ( s#file * , s#kobject * , s#bin_attribute * , char * , t#loff_t , t#size_t ) ; t#ssize_t ( * write ) ( s#file * , s#kobject * , s#bin_attribute * , char * , t#loff_t , t#size_t ) ; t#loff_t ( * llseek ) ( s#file * , s#kobject * , s#bin_attribute * , t#loff_t , int ) ; int ( * mmap ) ( s#file * , s#kobject * , s#bin_attribute * , s#vm_area_struct * ) ; }
s#binfmt_misc@14a1c20a struct binfmt_misc { s#list_head entries ; t#rwlock_t entries_lock ; t#bool enabled ; }
s#binfmt_misc@a1efc11e struct binfmt_misc { UNKNOWN }
s#bio struct bio { s#bio * bi_next ; s#block_device * bi_bdev ; t#blk_opf_t bi_opf ; unsigned short bi_flags ; unsigned short bi_ioprio ; e#rw_hint bi_write_hint ; t#blk_status_t bi_status ; t#atomic_t __bi_remaining ; s#bvec_iter bi_iter ; union { t#blk_qc_t bi_cookie ; unsigned int __bi_nr_segments ; } ; t#bio_end_io_t * bi_end_io ; void * bi_private ; s#blkcg_gq * bi_blkg ; s#bio_issue bi_issue ; s#bio_integrity_payload * bi_integrity ; unsigned short bi_vcnt ; unsigned short bi_max_vecs ; t#atomic_t __bi_cnt ; s#bio_vec * bi_io_vec ; s#bio_set * bi_pool ; s#bio_vec bi_inline_vecs [ ] ; }
s#bio_alloc_cache struct bio_alloc_cache { UNKNOWN }
s#bio_integrity_payload@5dd98af2 struct bio_integrity_payload { UNKNOWN }
s#bio_integrity_payload@93c3ca65 struct bio_integrity_payload { s#bio * bip_bio ; s#bvec_iter bip_iter ; unsigned short bip_vcnt ; unsigned short bip_max_vcnt ; unsigned short bip_flags ; t#u16 app_tag ; s#bvec_iter bio_iter ; s#work_struct bip_work ; s#bio_vec * bip_vec ; s#bio_vec bip_inline_vecs [ ] ; }
s#bio_issue struct bio_issue { t#u64 value ; }
s#bio_list@9189344b struct bio_list { UNKNOWN }
s#bio_list@d0a28660 struct bio_list { s#bio * head ; s#bio * tail ; }
s#bio_set struct bio_set { s#kmem_cache * bio_slab ; unsigned int front_pad ; s#bio_alloc_cache * cache ; t#mempool_t bio_pool ; t#mempool_t bvec_pool ; t#mempool_t bio_integrity_pool ; t#mempool_t bvec_integrity_pool ; unsigned int back_pad ; t#spinlock_t rescue_lock ; s#bio_list rescue_list ; s#work_struct rescue_work ; s#workqueue_struct * rescue_workqueue ; s#hlist_node cpuhp_dead ; }
s#bio_vec@a2ebfa8f struct bio_vec { UNKNOWN }
s#bio_vec@e60777b1 struct bio_vec { s#page * bv_page ; unsigned int bv_len ; unsigned int bv_offset ; }
s#blk_flush_queue@4aaf6b7c struct blk_flush_queue { UNKNOWN }
s#blk_flush_queue@73ebe792 struct blk_flush_queue { t#spinlock_t mq_flush_lock ; unsigned int flush_pending_idx : 1 ; unsigned int flush_running_idx : 1 ; t#blk_status_t rq_status ; unsigned long flush_pending_since ; s#list_head flush_queue [ 2 ] ; unsigned long flush_data_in_flight ; s#request * flush_rq ; }
s#blk_holder_ops@3d630586 struct blk_holder_ops { void ( * mark_dead ) ( s#block_device * , t#bool ) ; void ( * sync ) ( s#block_device * ) ; int ( * freeze ) ( s#block_device * ) ; int ( * thaw ) ( s#block_device * ) ; }
s#blk_holder_ops@4f0b2a12 struct blk_holder_ops { UNKNOWN }
s#blk_independent_access_range struct blk_independent_access_range { s#kobject kobj ; t#sector_t sector ; t#sector_t nr_sectors ; }
s#blk_independent_access_ranges struct blk_independent_access_ranges { s#kobject kobj ; t#bool sysfs_registered ; unsigned int nr_ia_ranges ; s#blk_independent_access_range ia_range [ ] ; }
s#blk_integrity struct blk_integrity { unsigned char flags ; e#blk_integrity_checksum csum_type ; unsigned char tuple_size ; unsigned char pi_offset ; unsigned char interval_exp ; unsigned char tag_size ; }
s#blk_mq_alloc_data struct blk_mq_alloc_data { s#request_queue * q ; t#blk_mq_req_flags_t flags ; unsigned int shallow_depth ; t#blk_opf_t cmd_flags ; t#req_flags_t rq_flags ; unsigned int nr_tags ; s#request * * cached_rq ; s#blk_mq_ctx * ctx ; s#blk_mq_hw_ctx * hctx ; }
s#blk_mq_ctx@159718d5 struct blk_mq_ctx { struct { t#spinlock_t lock ; s#list_head rq_lists [ E#HCTX_MAX_TYPES ] ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; unsigned int cpu ; unsigned short index_hw [ E#HCTX_MAX_TYPES ] ; s#blk_mq_hw_ctx * hctxs [ E#HCTX_MAX_TYPES ] ; s#request_queue * queue ; s#blk_mq_ctxs * ctxs ; s#kobject kobj ; }
s#blk_mq_ctx@a9e7a7e1 struct blk_mq_ctx { UNKNOWN }
s#blk_mq_ctxs struct blk_mq_ctxs { s#kobject kobj ; s#blk_mq_ctx * queue_ctx ; }
s#blk_mq_debugfs_attr@26a35b37 struct blk_mq_debugfs_attr { UNKNOWN }
s#blk_mq_debugfs_attr@9913c52c struct blk_mq_debugfs_attr { const char * name ; t#umode_t mode ; int ( * show ) ( void * , s#seq_file * ) ; t#ssize_t ( * write ) ( void * , const char * , t#size_t , t#loff_t * ) ; const s#seq_operations * seq_ops ; }
s#blk_mq_hw_ctx struct blk_mq_hw_ctx { struct { t#spinlock_t lock ; s#list_head dispatch ; unsigned long state ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; s#delayed_work run_work ; t#cpumask_var_t cpumask ; int next_cpu ; int next_cpu_batch ; unsigned long flags ; void * sched_data ; s#request_queue * queue ; s#blk_flush_queue * fq ; void * driver_data ; s#sbitmap ctx_map ; s#blk_mq_ctx * dispatch_from ; unsigned int dispatch_busy ; unsigned short type ; unsigned short nr_ctx ; s#blk_mq_ctx * * ctxs ; t#spinlock_t dispatch_wait_lock ; t#wait_queue_entry_t dispatch_wait ; t#atomic_t wait_index ; s#blk_mq_tags * tags ; s#blk_mq_tags * sched_tags ; unsigned int numa_node ; unsigned int queue_num ; t#atomic_t nr_active ; s#hlist_node cpuhp_online ; s#hlist_node cpuhp_dead ; s#kobject kobj ; s#dentry * debugfs_dir ; s#dentry * sched_debugfs_dir ; s#list_head hctx_list ; }
s#blk_mq_ops@892fbd44 struct blk_mq_ops { t#blk_status_t ( * queue_rq ) ( s#blk_mq_hw_ctx * , const s#blk_mq_queue_data * ) ; void ( * commit_rqs ) ( s#blk_mq_hw_ctx * ) ; void ( * queue_rqs ) ( s#request * * ) ; int ( * get_budget ) ( s#request_queue * ) ; void ( * put_budget ) ( s#request_queue * , int ) ; void ( * set_rq_budget_token ) ( s#request * , int ) ; int ( * get_rq_budget_token ) ( s#request * ) ; e#blk_eh_timer_return ( * timeout ) ( s#request * ) ; int ( * poll ) ( s#blk_mq_hw_ctx * , s#io_comp_batch * ) ; void ( * complete ) ( s#request * ) ; int ( * init_hctx ) ( s#blk_mq_hw_ctx * , void * , unsigned int ) ; void ( * exit_hctx ) ( s#blk_mq_hw_ctx * , unsigned int ) ; int ( * init_request ) ( s#blk_mq_tag_set * , s#request * , unsigned int , unsigned int ) ; void ( * exit_request ) ( s#blk_mq_tag_set * , s#request * , unsigned int ) ; void ( * cleanup_rq ) ( s#request * ) ; t#bool ( * busy ) ( s#request_queue * ) ; void ( * map_queues ) ( s#blk_mq_tag_set * ) ; void ( * show_rq ) ( s#seq_file * , s#request * ) ; }
s#blk_mq_ops@b0c59979 struct blk_mq_ops { UNKNOWN }
s#blk_mq_queue_data struct blk_mq_queue_data { s#request * rq ; t#bool last ; }
s#blk_mq_queue_map struct blk_mq_queue_map { unsigned int * mq_map ; unsigned int nr_queues ; unsigned int queue_offset ; }
s#blk_mq_tag_set@1cc4433c struct blk_mq_tag_set { UNKNOWN }
s#blk_mq_tag_set@a38af0c6 struct blk_mq_tag_set { const s#blk_mq_ops * ops ; s#blk_mq_queue_map map [ E#HCTX_MAX_TYPES ] ; unsigned int nr_maps ; unsigned int nr_hw_queues ; unsigned int queue_depth ; unsigned int reserved_tags ; unsigned int cmd_size ; int numa_node ; unsigned int timeout ; unsigned int flags ; void * driver_data ; s#blk_mq_tags * * tags ; s#blk_mq_tags * shared_tags ; s#mutex tag_list_lock ; s#list_head tag_list ; s#srcu_struct * srcu ; }
s#blk_mq_tags@78ab9fcb struct blk_mq_tags { UNKNOWN }
s#blk_mq_tags@83f6aa16 struct blk_mq_tags { unsigned int nr_tags ; unsigned int nr_reserved_tags ; unsigned int active_queues ; s#sbitmap_queue bitmap_tags ; s#sbitmap_queue breserved_tags ; s#request * * rqs ; s#request * * static_rqs ; s#list_head page_list ; t#spinlock_t lock ; }
s#blk_plug@7d226752 struct blk_plug { s#request * mq_list ; s#request * cached_rq ; t#u64 cur_ktime ; unsigned short nr_ios ; unsigned short rq_count ; t#bool multiple_queues ; t#bool has_elevator ; s#list_head cb_list ; }
s#blk_plug@e2161b61 struct blk_plug { UNKNOWN }
s#blk_queue_stats struct blk_queue_stats { UNKNOWN }
s#blk_trace@e03dedc0 struct blk_trace { int trace_state ; s#rchan * rchan ; unsigned long * sequence ; unsigned char * msg_data ; t#u16 act_mask ; t#u64 start_lba ; t#u64 end_lba ; t#u32 pid ; t#u32 dev ; s#dentry * dir ; s#list_head running_list ; t#atomic_t dropped ; }
s#blk_trace@ed399ad7 struct blk_trace { UNKNOWN }
s#blk_zone struct blk_zone { t#__u64 start ; t#__u64 len ; t#__u64 wp ; t#__u8 type ; t#__u8 cond ; t#__u8 non_seq ; t#__u8 reset ; t#__u8 resv [ 4 ] ; t#__u64 capacity ; t#__u8 reserved [ 24 ] ; }
s#blkcg struct blkcg { s#cgroup_subsys_state css ; t#spinlock_t lock ; t#refcount_t online_pin ; t#atomic_t congestion_count ; s#xarray blkg_tree ; s#blkcg_gq * blkg_hint ; s#hlist_head blkg_list ; s#blkcg_policy_data * cpd [ 6 ] ; s#list_head all_blkcgs_node ; s#llist_head * lhead ; char fc_app_id [ 129 ] ; s#list_head cgwb_list ; unsigned long uek_reserved1 ; }
s#blkcg_gq@0386a888 struct blkcg_gq { s#request_queue * q ; s#list_head q_node ; s#hlist_node blkcg_node ; s#blkcg * blkcg ; s#blkcg_gq * parent ; s#percpu_ref refcnt ; t#bool online ; s#blkg_iostat_set * iostat_cpu ; s#blkg_iostat_set iostat ; s#blkg_policy_data * pd [ 6 ] ; t#spinlock_t async_bio_lock ; s#bio_list async_bios ; union { s#work_struct async_bio_work ; s#work_struct free_work ; } ; t#atomic_t use_delay ; t#atomic64_t delay_nsec ; t#atomic64_t delay_start ; t#u64 last_delay ; int last_use ; s#callback_head callback_head ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#blkcg_gq@5d57e740 struct blkcg_gq { UNKNOWN }
s#blkcg_policy_data struct blkcg_policy_data { s#blkcg * blkcg ; int plid ; }
s#blkg_iostat struct blkg_iostat { t#u64 bytes [ E#BLKG_IOSTAT_NR ] ; t#u64 ios [ E#BLKG_IOSTAT_NR ] ; }
s#blkg_iostat_set struct blkg_iostat_set { s#u64_stats_sync sync ; s#blkcg_gq * blkg ; s#llist_node lnode ; int lqueued ; s#blkg_iostat cur ; s#blkg_iostat last ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#blkg_policy_data struct blkg_policy_data { s#blkcg_gq * blkg ; int plid ; t#bool online ; }
s#block_device@3ea0352f struct block_device { UNKNOWN }
s#block_device@8db9437c struct block_device { t#sector_t bd_start_sect ; t#sector_t bd_nr_sectors ; s#gendisk * bd_disk ; s#request_queue * bd_queue ; s#disk_stats * bd_stats ; unsigned long bd_stamp ; t#atomic_t __bd_flags ; t#dev_t bd_dev ; s#address_space * bd_mapping ; t#atomic_t bd_openers ; t#spinlock_t bd_size_lock ; void * bd_claiming ; void * bd_holder ; const s#blk_holder_ops * bd_holder_ops ; s#mutex bd_holder_lock ; int bd_holders ; s#kobject * bd_holder_dir ; t#atomic_t bd_fsfreeze_count ; s#mutex bd_fsfreeze_mutex ; s#partition_meta_info * bd_meta_info ; int bd_writers ; void * bd_security ; s#device bd_device ; unsigned long uek_reserved1 ; }
s#block_device_operations struct block_device_operations { void ( * submit_bio ) ( s#bio * ) ; int ( * poll_bio ) ( s#bio * , s#io_comp_batch * , unsigned int ) ; int ( * open ) ( s#gendisk * , t#blk_mode_t ) ; void ( * release ) ( s#gendisk * ) ; int ( * ioctl ) ( s#block_device * , t#blk_mode_t , unsigned , unsigned long ) ; int ( * compat_ioctl ) ( s#block_device * , t#blk_mode_t , unsigned , unsigned long ) ; unsigned int ( * check_events ) ( s#gendisk * , unsigned int ) ; void ( * unlock_native_capacity ) ( s#gendisk * ) ; int ( * getgeo ) ( s#block_device * , s#hd_geometry * ) ; int ( * set_read_only ) ( s#block_device * , t#bool ) ; void ( * free_disk ) ( s#gendisk * ) ; void ( * swap_slot_free_notify ) ( s#block_device * , unsigned long ) ; int ( * report_zones ) ( s#gendisk * , t#sector_t , unsigned int , t#report_zones_cb , void * ) ; char * ( * devnode ) ( s#gendisk * , t#umode_t * ) ; int ( * get_unique_id ) ( s#gendisk * , t#u8 [ 16 ] , e#blk_unique_id ) ; s#module * owner ; const s#pr_ops * pr_ops ; int ( * alternative_gpt_sector ) ( s#gendisk * , t#sector_t * ) ; }
s#blocking_notifier_head struct blocking_notifier_head { s#rw_semaphore rwsem ; s#notifier_block * head ; }
s#bpf_active_lock struct bpf_active_lock { void * ptr ; t#u32 id ; }
s#bpf_arena struct bpf_arena { UNKNOWN }
s#bpf_cgroup_storage@080bca65 struct bpf_cgroup_storage { UNKNOWN }
s#bpf_cgroup_storage@f169a0d9 struct bpf_cgroup_storage { union { s#bpf_storage_buffer * buf ; void * percpu_buf ; } ; s#bpf_cgroup_storage_map * map ; s#bpf_cgroup_storage_key key ; s#list_head list_map ; s#list_head list_cg ; s#rb_node node ; s#callback_head rcu ; }
s#bpf_cgroup_storage_key struct bpf_cgroup_storage_key { t#__u64 cgroup_inode_id ; t#__u32 attach_type ; }
s#bpf_cgroup_storage_map struct bpf_cgroup_storage_map { UNKNOWN }
s#bpf_ctx_arg_aux struct bpf_ctx_arg_aux { t#u32 offset ; e#bpf_reg_type reg_type ; s#btf * btf ; t#u32 btf_id ; }
s#bpf_func_info struct bpf_func_info { t#__u32 insn_off ; t#__u32 type_id ; }
s#bpf_func_info_aux struct bpf_func_info_aux { t#u16 linkage ; t#bool unreliable ; t#bool called : 1 ; t#bool verified : 1 ; }
s#bpf_func_proto struct bpf_func_proto { t#u64 ( * func ) ( t#u64 , t#u64 , t#u64 , t#u64 , t#u64 ) ; t#bool gpl_only ; t#bool pkt_access ; t#bool might_sleep ; t#bool allow_fastcall ; e#bpf_return_type ret_type ; union { struct { e#bpf_arg_type arg1_type ; e#bpf_arg_type arg2_type ; e#bpf_arg_type arg3_type ; e#bpf_arg_type arg4_type ; e#bpf_arg_type arg5_type ; } ; e#bpf_arg_type arg_type [ 5 ] ; } ; union { struct { t#u32 * arg1_btf_id ; t#u32 * arg2_btf_id ; t#u32 * arg3_btf_id ; t#u32 * arg4_btf_id ; t#u32 * arg5_btf_id ; } ; t#u32 * arg_btf_id [ 5 ] ; struct { t#size_t arg1_size ; t#size_t arg2_size ; t#size_t arg3_size ; t#size_t arg4_size ; t#size_t arg5_size ; } ; t#size_t arg_size [ 5 ] ; } ; int * ret_btf_id ; t#bool ( * allowed ) ( const s#bpf_prog * ) ; }
s#bpf_func_state@447aa7ab struct bpf_func_state { UNKNOWN }
s#bpf_func_state@f750fb9e struct bpf_func_state { s#bpf_reg_state regs [ E#__MAX_BPF_REG ] ; int callsite ; t#u32 frameno ; t#u32 subprogno ; t#u32 async_entry_cnt ; s#bpf_retval_range callback_ret_range ; t#bool in_callback_fn ; t#bool in_async_callback_fn ; t#bool in_exception_callback_fn ; t#u32 callback_depth ; int acquired_refs ; s#bpf_reference_state * refs ; s#bpf_stack_state * stack ; int allocated_stack ; }
s#bpf_id_pair struct bpf_id_pair { t#u32 old ; t#u32 cur ; }
s#bpf_idmap struct bpf_idmap { t#u32 tmp_id_gen ; s#bpf_id_pair map [ ( ( E#__MAX_BPF_REG + 512 / 8 ) * 8 ) ] ; }
s#bpf_idset struct bpf_idset { t#u32 count ; t#u32 ids [ ( ( E#__MAX_BPF_REG + 512 / 8 ) * 8 ) ] ; }
s#bpf_insn struct bpf_insn { t#__u8 code ; t#__u8 dst_reg : 4 ; t#__u8 src_reg : 4 ; t#__s16 off ; t#__s32 imm ; }
s#bpf_insn_access_aux struct bpf_insn_access_aux { e#bpf_reg_type reg_type ; t#bool is_ldsx ; union { int ctx_field_size ; struct { s#btf * btf ; t#u32 btf_id ; } ; } ; s#bpf_verifier_log * log ; t#bool is_retval ; }
s#bpf_insn_aux_data struct bpf_insn_aux_data { union { e#bpf_reg_type ptr_type ; s#bpf_map_ptr_state map_ptr_state ; t#s32 call_imm ; t#u32 alu_limit ; struct { t#u32 map_index ; t#u32 map_off ; } ; struct { e#bpf_reg_type reg_type ; union { struct { s#btf * btf ; t#u32 btf_id ; } ; t#u32 mem_size ; } ; } btf_var ; s#bpf_loop_inline_state loop_inline_state ; } ; union { t#u64 obj_new_size ; t#u64 insert_off ; } ; s#btf_struct_meta * kptr_struct_meta ; t#u64 map_key_state ; int ctx_field_size ; t#u32 seen ; t#bool sanitize_stack_spill ; t#bool zext_dst ; t#bool needs_zext ; t#bool storage_get_func_atomic ; t#bool is_iter_next ; t#bool call_with_percpu_alloc_ptr ; t#u8 alu_state ; t#u8 fastcall_pattern : 1 ; t#u8 fastcall_spills_num : 3 ; unsigned int orig_idx ; t#bool jmp_point ; t#bool prune_point ; t#bool force_checkpoint ; t#bool calls_callback ; }
s#bpf_iter_aux_info struct bpf_iter_aux_info { s#bpf_map * map ; struct { s#cgroup * start ; e#bpf_cgroup_iter_order order ; } cgroup ; struct { e#bpf_iter_task_type type ; t#u32 pid ; } task ; }
s#bpf_iter_seq_info struct bpf_iter_seq_info { const s#seq_operations * seq_ops ; t#bpf_iter_init_seq_priv_t init_seq_private ; t#bpf_iter_fini_seq_priv_t fini_seq_private ; t#u32 seq_priv_size ; }
s#bpf_jit_poke_descriptor struct bpf_jit_poke_descriptor { void * tailcall_target ; void * tailcall_bypass ; void * bypass_addr ; void * aux ; union { struct { s#bpf_map * map ; t#u32 key ; } tail_call ; } ; t#bool tailcall_target_stable ; t#u8 adj_off ; t#u16 reason ; t#u32 insn_idx ; }
s#bpf_jmp_history_entry struct bpf_jmp_history_entry { t#u32 idx ; t#u32 prev_idx : 22 ; t#u32 flags : 10 ; t#u64 linked_regs ; }
s#bpf_kfunc_btf_tab struct bpf_kfunc_btf_tab { UNKNOWN }
s#bpf_kfunc_desc_tab struct bpf_kfunc_desc_tab { UNKNOWN }
s#bpf_ksym struct bpf_ksym { unsigned long start ; unsigned long end ; char name [ 512 ] ; s#list_head lnode ; s#latch_tree_node tnode ; t#bool prog ; }
s#bpf_line_info struct bpf_line_info { t#__u32 insn_off ; t#__u32 file_name_off ; t#__u32 line_off ; t#__u32 line_col ; }
s#bpf_link struct bpf_link { t#atomic64_t refcnt ; t#u32 id ; e#bpf_link_type type ; const s#bpf_link_ops * ops ; s#bpf_prog * prog ; union { s#callback_head rcu ; s#work_struct work ; } ; }
s#bpf_link_info struct bpf_link_info { t#__u32 type ; t#__u32 id ; t#__u32 prog_id ; union { struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) tp_name ; t#__u32 tp_name_len ; } raw_tracepoint ; struct { t#__u32 attach_type ; t#__u32 target_obj_id ; t#__u32 target_btf_id ; } tracing ; struct { t#__u64 cgroup_id ; t#__u32 attach_type ; } cgroup ; struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) target_name ; t#__u32 target_name_len ; union { struct { t#__u32 map_id ; } map ; } ; union { struct { t#__u64 cgroup_id ; t#__u32 order ; } cgroup ; struct { t#__u32 tid ; t#__u32 pid ; } task ; } ; } iter ; struct { t#__u32 netns_ino ; t#__u32 attach_type ; } netns ; struct { t#__u32 ifindex ; } xdp ; struct { t#__u32 map_id ; } struct_ops ; struct { t#__u32 pf ; t#__u32 hooknum ; t#__s32 priority ; t#__u32 flags ; } netfilter ; struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) addrs ; t#__u32 count ; t#__u32 flags ; t#__u64 missed ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) cookies ; } kprobe_multi ; struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) path ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) offsets ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) ref_ctr_offsets ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) cookies ; t#__u32 path_size ; t#__u32 count ; t#__u32 flags ; t#__u32 pid ; } uprobe_multi ; struct { t#__u32 type ; t#__u32 : 32 ; union { struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) file_name ; t#__u32 name_len ; t#__u32 offset ; t#__u64 cookie ; } uprobe ; struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) func_name ; t#__u32 name_len ; t#__u32 offset ; t#__u64 addr ; t#__u64 missed ; t#__u64 cookie ; } kprobe ; struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) tp_name ; t#__u32 name_len ; t#__u32 : 32 ; t#__u64 cookie ; } tracepoint ; struct { t#__u64 config ; t#__u32 type ; t#__u32 : 32 ; t#__u64 cookie ; } event ; } ; } perf_event ; struct { t#__u32 ifindex ; t#__u32 attach_type ; } tcx ; struct { t#__u32 ifindex ; t#__u32 attach_type ; } netkit ; struct { t#__u32 map_id ; t#__u32 attach_type ; } sockmap ; } ; }
s#bpf_link_ops struct bpf_link_ops { void ( * release ) ( s#bpf_link * ) ; void ( * dealloc ) ( s#bpf_link * ) ; void ( * dealloc_deferred ) ( s#bpf_link * ) ; int ( * detach ) ( s#bpf_link * ) ; int ( * update_prog ) ( s#bpf_link * , s#bpf_prog * , s#bpf_prog * ) ; void ( * show_fdinfo ) ( const s#bpf_link * , s#seq_file * ) ; int ( * fill_link_info ) ( const s#bpf_link * , s#bpf_link_info * ) ; int ( * update_map ) ( s#bpf_link * , s#bpf_map * , s#bpf_map * ) ; t#__poll_t ( * poll ) ( s#file * , s#poll_table_struct * ) ; }
s#bpf_local_storage@0f78b271 struct bpf_local_storage { UNKNOWN }
s#bpf_local_storage@d5cd3a20 struct bpf_local_storage { s#bpf_local_storage_data * cache [ 16 ] ; s#bpf_local_storage_map * smap ; s#hlist_head list ; void * owner ; s#callback_head rcu ; t#raw_spinlock_t lock ; }
s#bpf_local_storage_data struct bpf_local_storage_data { s#bpf_local_storage_map * smap ; t#u8 data [ ] __attribute__ ( ( __aligned__ ( 8 ) ) ) ; }
s#bpf_local_storage_map@0560b78d struct bpf_local_storage_map { s#bpf_map map ; s#bpf_local_storage_map_bucket * buckets ; t#u32 bucket_log ; t#u16 elem_size ; t#u16 cache_idx ; s#bpf_mem_alloc selem_ma ; s#bpf_mem_alloc storage_ma ; t#bool bpf_ma ; }
s#bpf_local_storage_map@17d09388 struct bpf_local_storage_map { UNKNOWN }
s#bpf_local_storage_map_bucket struct bpf_local_storage_map_bucket { s#hlist_head list ; t#raw_spinlock_t lock ; }
s#bpf_loop_inline_state struct bpf_loop_inline_state { unsigned int initialized : 1 ; unsigned int fit_for_inline : 1 ; t#u32 callback_subprogno ; }
s#bpf_map struct bpf_map { const s#bpf_map_ops * ops ; s#bpf_map * inner_map_meta ; void * security ; e#bpf_map_type map_type ; t#u32 key_size ; t#u32 value_size ; t#u32 max_entries ; t#u64 map_extra ; t#u32 map_flags ; t#u32 id ; s#btf_record * record ; int numa_node ; t#u32 btf_key_type_id ; t#u32 btf_value_type_id ; t#u32 btf_vmlinux_value_type_id ; s#btf * btf ; s#obj_cgroup * objcg ; char name [ 16U ] ; s#mutex freeze_mutex ; t#atomic64_t refcnt ; t#atomic64_t usercnt ; union { s#work_struct work ; s#callback_head rcu ; } ; t#atomic64_t writecnt ; struct { const s#btf_type * attach_func_proto ; t#spinlock_t lock ; e#bpf_prog_type type ; t#bool jited ; t#bool xdp_has_frags ; } owner ; t#bool bypass_spec_v1 ; t#bool frozen ; t#bool free_after_mult_rcu_gp ; t#bool free_after_rcu_gp ; t#atomic64_t sleepable_refcnt ; t#s64 * elem_count ; unsigned long uek_reserved1 ; }
s#bpf_map_dev_ops struct bpf_map_dev_ops { int ( * map_get_next_key ) ( s#bpf_offloaded_map * , void * , void * ) ; int ( * map_lookup_elem ) ( s#bpf_offloaded_map * , void * , void * ) ; int ( * map_update_elem ) ( s#bpf_offloaded_map * , void * , void * , t#u64 ) ; int ( * map_delete_elem ) ( s#bpf_offloaded_map * , void * ) ; }
s#bpf_map_ops struct bpf_map_ops { int ( * map_alloc_check ) ( u#bpf_attr * ) ; s#bpf_map * ( * map_alloc ) ( u#bpf_attr * ) ; void ( * map_release ) ( s#bpf_map * , s#file * ) ; void ( * map_free ) ( s#bpf_map * ) ; int ( * map_get_next_key ) ( s#bpf_map * , void * , void * ) ; void ( * map_release_uref ) ( s#bpf_map * ) ; void * ( * map_lookup_elem_sys_only ) ( s#bpf_map * , void * ) ; int ( * map_lookup_batch ) ( s#bpf_map * , const u#bpf_attr * , u#bpf_attr * ) ; int ( * map_lookup_and_delete_elem ) ( s#bpf_map * , void * , void * , t#u64 ) ; int ( * map_lookup_and_delete_batch ) ( s#bpf_map * , const u#bpf_attr * , u#bpf_attr * ) ; int ( * map_update_batch ) ( s#bpf_map * , s#file * , const u#bpf_attr * , u#bpf_attr * ) ; int ( * map_delete_batch ) ( s#bpf_map * , const u#bpf_attr * , u#bpf_attr * ) ; void * ( * map_lookup_elem ) ( s#bpf_map * , void * ) ; long ( * map_update_elem ) ( s#bpf_map * , void * , void * , t#u64 ) ; long ( * map_delete_elem ) ( s#bpf_map * , void * ) ; long ( * map_push_elem ) ( s#bpf_map * , void * , t#u64 ) ; long ( * map_pop_elem ) ( s#bpf_map * , void * ) ; long ( * map_peek_elem ) ( s#bpf_map * , void * ) ; void * ( * map_lookup_percpu_elem ) ( s#bpf_map * , void * , t#u32 ) ; void * ( * map_fd_get_ptr ) ( s#bpf_map * , s#file * , int ) ; void ( * map_fd_put_ptr ) ( s#bpf_map * , void * , t#bool ) ; int ( * map_gen_lookup ) ( s#bpf_map * , s#bpf_insn * ) ; t#u32 ( * map_fd_sys_lookup_elem ) ( void * ) ; void ( * map_seq_show_elem ) ( s#bpf_map * , void * , s#seq_file * ) ; int ( * map_check_btf ) ( const s#bpf_map * , const s#btf * , const s#btf_type * , const s#btf_type * ) ; int ( * map_poke_track ) ( s#bpf_map * , s#bpf_prog_aux * ) ; void ( * map_poke_untrack ) ( s#bpf_map * , s#bpf_prog_aux * ) ; void ( * map_poke_run ) ( s#bpf_map * , t#u32 , s#bpf_prog * , s#bpf_prog * ) ; int ( * map_direct_value_addr ) ( const s#bpf_map * , t#u64 * , t#u32 ) ; int ( * map_direct_value_meta ) ( const s#bpf_map * , t#u64 , t#u32 * ) ; int ( * map_mmap ) ( s#bpf_map * , s#vm_area_struct * ) ; t#__poll_t ( * map_poll ) ( s#bpf_map * , s#file * , s#poll_table_struct * ) ; unsigned long ( * map_get_unmapped_area ) ( s#file * , unsigned long , unsigned long , unsigned long , unsigned long ) ; int ( * map_local_storage_charge ) ( s#bpf_local_storage_map * , void * , t#u32 ) ; void ( * map_local_storage_uncharge ) ( s#bpf_local_storage_map * , void * , t#u32 ) ; s#bpf_local_storage * * ( * map_owner_storage_ptr ) ( void * ) ; long ( * map_redirect ) ( s#bpf_map * , t#u64 , t#u64 ) ; t#bool ( * map_meta_equal ) ( const s#bpf_map * , const s#bpf_map * ) ; int ( * map_set_for_each_callback_args ) ( s#bpf_verifier_env * , s#bpf_func_state * , s#bpf_func_state * ) ; long ( * map_for_each_callback ) ( s#bpf_map * , t#bpf_callback_t , void * , t#u64 ) ; t#u64 ( * map_mem_usage ) ( const s#bpf_map * ) ; int * map_btf_id ; const s#bpf_iter_seq_info * iter_seq_info ; unsigned long uek_reserved1 ; }
s#bpf_map_ptr_state struct bpf_map_ptr_state { s#bpf_map * map_ptr ; t#bool poison ; t#bool unpriv ; }
s#bpf_mem_alloc struct bpf_mem_alloc { s#bpf_mem_caches * caches ; s#bpf_mem_cache * cache ; s#obj_cgroup * objcg ; t#bool percpu ; s#work_struct work ; }
s#bpf_mem_cache struct bpf_mem_cache { UNKNOWN }
s#bpf_mem_caches struct bpf_mem_caches { UNKNOWN }
s#bpf_mprog_bundle struct bpf_mprog_bundle { s#bpf_mprog_entry a ; s#bpf_mprog_entry b ; s#bpf_mprog_cp cp_items [ 64 ] ; s#bpf_prog * ref ; t#atomic64_t revision ; t#u32 count ; }
s#bpf_mprog_cp struct bpf_mprog_cp { s#bpf_link * link ; }
s#bpf_mprog_entry@27c1eca2 struct bpf_mprog_entry { s#bpf_mprog_fp fp_items [ 64 ] ; s#bpf_mprog_bundle * parent ; }
s#bpf_mprog_entry@74c9db46 struct bpf_mprog_entry { UNKNOWN }
s#bpf_mprog_fp struct bpf_mprog_fp { s#bpf_prog * prog ; }
s#bpf_net_context@9b7e8a68 struct bpf_net_context { UNKNOWN }
s#bpf_net_context@d59fc2a3 struct bpf_net_context { s#bpf_redirect_info ri ; s#list_head cpu_map_flush_list ; s#list_head dev_map_flush_list ; s#list_head xskmap_map_flush_list ; }
s#bpf_nh_params struct bpf_nh_params { t#u32 nh_family ; union { t#u32 ipv4_nh ; s#in6_addr ipv6_nh ; } ; }
s#bpf_offload_dev struct bpf_offload_dev { UNKNOWN }
s#bpf_offloaded_map struct bpf_offloaded_map { s#bpf_map map ; s#net_device * netdev ; const s#bpf_map_dev_ops * dev_ops ; void * dev_priv ; s#list_head offloads ; }
s#bpf_prog@3425efb4 struct bpf_prog { UNKNOWN }
s#bpf_prog@abd92cca struct bpf_prog { t#u16 pages ; t#u16 jited : 1 , jit_requested : 1 , gpl_compatible : 1 , cb_access : 1 , dst_needed : 1 , blinding_requested : 1 , blinded : 1 , is_func : 1 , kprobe_override : 1 , has_callchain_buf : 1 , enforce_expected_attach_type : 1 , call_get_stack : 1 , call_get_func_ip : 1 , tstamp_type_access : 1 , sleepable : 1 ; e#bpf_prog_type type ; e#bpf_attach_type expected_attach_type ; t#u32 len ; t#u32 jited_len ; t#u8 tag [ 8 ] ; s#bpf_prog_stats * stats ; int * active ; unsigned int ( * bpf_func ) ( const void * , const s#bpf_insn * ) ; s#bpf_prog_aux * aux ; s#sock_fprog_kern * orig_prog ; union { struct { struct { } __empty_insns ; s#sock_filter insns [ ] ; } ; struct { struct { } __empty_insnsi ; s#bpf_insn insnsi [ ] ; } ; } ; }
s#bpf_prog_array@b5d94ddc struct bpf_prog_array { UNKNOWN }
s#bpf_prog_array@c2d10354 struct bpf_prog_array { s#callback_head rcu ; s#bpf_prog_array_item items [ ] ; }
s#bpf_prog_array_item struct bpf_prog_array_item { s#bpf_prog * prog ; union { s#bpf_cgroup_storage * cgroup_storage [ E#__BPF_CGROUP_STORAGE_MAX ] ; t#u64 bpf_cookie ; } ; }
s#bpf_prog_aux struct bpf_prog_aux { t#atomic64_t refcnt ; t#u32 used_map_cnt ; t#u32 used_btf_cnt ; t#u32 max_ctx_offset ; t#u32 max_pkt_offset ; t#u32 max_tp_access ; t#u32 stack_depth ; t#u32 id ; t#u32 func_cnt ; t#u32 real_func_cnt ; t#u32 func_idx ; t#u32 attach_btf_id ; t#u32 ctx_arg_info_size ; t#u32 max_rdonly_access ; t#u32 max_rdwr_access ; s#btf * attach_btf ; const s#bpf_ctx_arg_aux * ctx_arg_info ; s#mutex dst_mutex ; s#bpf_prog * dst_prog ; s#bpf_trampoline * dst_trampoline ; e#bpf_prog_type saved_dst_prog_type ; e#bpf_attach_type saved_dst_attach_type ; t#bool verifier_zext ; t#bool dev_bound ; t#bool offload_requested ; t#bool attach_btf_trace ; t#bool attach_tracing_prog ; t#bool func_proto_unreliable ; t#bool tail_call_reachable ; t#bool xdp_has_frags ; t#bool exception_cb ; t#bool exception_boundary ; t#bool is_extended ; t#u64 prog_array_member_cnt ; s#mutex ext_mutex ; s#bpf_arena * arena ; const s#btf_type * attach_func_proto ; const char * attach_func_name ; s#bpf_prog * * func ; void * jit_data ; s#bpf_jit_poke_descriptor * poke_tab ; s#bpf_kfunc_desc_tab * kfunc_tab ; s#bpf_kfunc_btf_tab * kfunc_btf_tab ; t#u32 size_poke_tab ; s#bpf_ksym ksym ; const s#bpf_prog_ops * ops ; s#bpf_map * * used_maps ; s#mutex used_maps_mutex ; s#btf_mod_pair * used_btfs ; s#bpf_prog * prog ; s#user_struct * user ; t#u64 load_time ; t#u32 verified_insns ; int cgroup_atype ; s#bpf_map * cgroup_storage [ E#__BPF_CGROUP_STORAGE_MAX ] ; char name [ 16U ] ; t#u64 ( * bpf_exception_cb ) ( t#u64 , t#u64 , t#u64 , t#u64 , t#u64 ) ; void * security ; s#bpf_token * token ; s#bpf_prog_offload * offload ; s#btf * btf ; s#bpf_func_info * func_info ; s#bpf_func_info_aux * func_info_aux ; s#bpf_line_info * linfo ; void * * jited_linfo ; t#u32 func_info_cnt ; t#u32 nr_linfo ; t#u32 linfo_idx ; s#module * mod ; t#u32 num_exentries ; s#exception_table_entry * extable ; union { s#work_struct work ; s#callback_head rcu ; } ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#bpf_prog_offload struct bpf_prog_offload { s#bpf_prog * prog ; s#net_device * netdev ; s#bpf_offload_dev * offdev ; void * dev_priv ; s#list_head offloads ; t#bool dev_state ; t#bool opt_failed ; void * jited_image ; t#u32 jited_len ; }
s#bpf_prog_ops struct bpf_prog_ops { int ( * test_run ) ( s#bpf_prog * , const u#bpf_attr * , u#bpf_attr * ) ; }
s#bpf_prog_stats@6734514e struct bpf_prog_stats { UNKNOWN }
s#bpf_prog_stats@d55a211d struct bpf_prog_stats { t#u64_stats_t cnt ; t#u64_stats_t nsecs ; t#u64_stats_t misses ; s#u64_stats_sync syncp ; }
s#bpf_raw_event_map struct bpf_raw_event_map { s#tracepoint * tp ; void * bpf_func ; t#u32 num_args ; t#u32 writable_size ; }
s#bpf_redirect_info struct bpf_redirect_info { t#u64 tgt_index ; void * tgt_value ; s#bpf_map * map ; t#u32 flags ; t#u32 map_id ; e#bpf_map_type map_type ; s#bpf_nh_params nh ; t#u32 kern_flags ; }
s#bpf_reference_state struct bpf_reference_state { int id ; int insn_idx ; int callback_ref ; }
s#bpf_reg_state struct bpf_reg_state { e#bpf_reg_type type ; t#s32 off ; union { int range ; struct { s#bpf_map * map_ptr ; t#u32 map_uid ; } ; struct { s#btf * btf ; t#u32 btf_id ; } ; struct { t#u32 mem_size ; t#u32 dynptr_id ; } ; struct { e#bpf_dynptr_type type ; t#bool first_slot ; } dynptr ; struct { s#btf * btf ; t#u32 btf_id ; e#bpf_iter_state state : 2 ; int depth : 30 ; } iter ; struct { unsigned long raw1 ; unsigned long raw2 ; } raw ; t#u32 subprogno ; } ; s#tnum var_off ; t#s64 smin_value ; t#s64 smax_value ; t#u64 umin_value ; t#u64 umax_value ; t#s32 s32_min_value ; t#s32 s32_max_value ; t#u32 u32_min_value ; t#u32 u32_max_value ; t#u32 id ; t#u32 ref_obj_id ; s#bpf_reg_state * parent ; t#u32 frameno ; t#s32 subreg_def ; e#bpf_reg_liveness live ; t#bool precise ; }
s#bpf_retval_range struct bpf_retval_range { t#s32 minval ; t#s32 maxval ; }
s#bpf_run_ctx@2d1ee41d struct bpf_run_ctx { UNKNOWN }
s#bpf_run_ctx@ef4d0a5d struct bpf_run_ctx { }
s#bpf_stack_state struct bpf_stack_state { s#bpf_reg_state spilled_ptr ; t#u8 slot_type [ 8 ] ; }
s#bpf_storage_buffer struct bpf_storage_buffer { s#callback_head rcu ; char data [ ] ; }
s#bpf_subprog_arg_info struct bpf_subprog_arg_info { e#bpf_arg_type arg_type ; union { t#u32 mem_size ; t#u32 btf_id ; } ; }
s#bpf_subprog_info struct bpf_subprog_info { t#u32 start ; t#u32 linfo_idx ; t#u16 stack_depth ; t#u16 stack_extra ; t#s16 fastcall_stack_off ; t#bool has_tail_call : 1 ; t#bool tail_call_reachable : 1 ; t#bool has_ld_abs : 1 ; t#bool is_cb : 1 ; t#bool is_async_cb : 1 ; t#bool is_exception_cb : 1 ; t#bool args_cached : 1 ; t#bool keep_fastcall_stack : 1 ; t#u8 arg_cnt ; s#bpf_subprog_arg_info args [ 5 ] ; }
s#bpf_token struct bpf_token { s#work_struct work ; t#atomic64_t refcnt ; s#user_namespace * userns ; t#u64 allowed_cmds ; t#u64 allowed_maps ; t#u64 allowed_progs ; t#u64 allowed_attachs ; void * security ; }
s#bpf_tramp_image struct bpf_tramp_image { void * image ; int size ; s#bpf_ksym ksym ; s#percpu_ref pcref ; void * ip_after_call ; void * ip_epilogue ; union { s#callback_head rcu ; s#work_struct work ; } ; }
s#bpf_trampoline struct bpf_trampoline { s#hlist_node hlist ; s#ftrace_ops * fops ; s#mutex mutex ; t#refcount_t refcnt ; t#u32 flags ; t#u64 key ; struct { s#btf_func_model model ; void * addr ; t#bool ftrace_managed ; } func ; s#bpf_prog * extension_prog ; s#hlist_head progs_hlist [ E#BPF_TRAMP_MAX ] ; int progs_cnt [ E#BPF_TRAMP_MAX ] ; s#bpf_tramp_image * cur_image ; }
s#bpf_verifier_env@5cd2267a struct bpf_verifier_env { UNKNOWN }
s#bpf_verifier_env@97cc9d6a struct bpf_verifier_env { t#u32 insn_idx ; t#u32 prev_insn_idx ; s#bpf_prog * prog ; const s#bpf_verifier_ops * ops ; s#module * attach_btf_mod ; s#bpf_verifier_stack_elem * head ; int stack_size ; t#bool strict_alignment ; t#bool test_state_freq ; t#bool test_reg_invariants ; s#bpf_verifier_state * cur_state ; s#bpf_verifier_state_list * * explored_states ; s#bpf_verifier_state_list * free_list ; s#bpf_map * used_maps [ 64 ] ; s#btf_mod_pair used_btfs [ 64 ] ; t#u32 used_map_cnt ; t#u32 used_btf_cnt ; t#u32 id_gen ; t#u32 hidden_subprog_cnt ; int exception_callback_subprog ; t#bool explore_alu_limits ; t#bool allow_ptr_leaks ; t#bool allow_uninit_stack ; t#bool bpf_capable ; t#bool bypass_spec_v1 ; t#bool bypass_spec_v4 ; t#bool seen_direct_write ; t#bool seen_exception ; s#bpf_insn_aux_data * insn_aux_data ; const s#bpf_line_info * prev_linfo ; s#bpf_verifier_log log ; s#bpf_subprog_info subprog_info [ 256 + 2 ] ; union { s#bpf_idmap idmap_scratch ; s#bpf_idset idset_scratch ; } ; struct { int * insn_state ; int * insn_stack ; int cur_stack ; } cfg ; s#backtrack_state bt ; s#bpf_jmp_history_entry * cur_hist_ent ; t#u32 pass_cnt ; t#u32 subprog_cnt ; t#u32 prev_insn_processed , insn_processed ; t#u32 prev_jmps_processed , jmps_processed ; t#u64 verification_time ; t#u32 max_states_per_insn ; t#u32 total_states ; t#u32 peak_states ; t#u32 longest_mark_read_walk ; t#bpfptr_t fd_array ; t#u32 scratched_regs ; t#u64 scratched_stack_slots ; t#u64 prev_log_pos , prev_insn_print_pos ; s#bpf_reg_state fake_reg [ 2 ] ; char tmp_str_buf [ 320 ] ; s#bpf_insn insn_buf [ 32 ] ; s#bpf_insn epilogue_buf [ 32 ] ; }
s#bpf_verifier_log struct bpf_verifier_log { t#u64 start_pos ; t#u64 end_pos ; char * ubuf ; t#u32 level ; t#u32 len_total ; t#u32 len_max ; char kbuf [ 1024 ] ; }
s#bpf_verifier_ops struct bpf_verifier_ops { const s#bpf_func_proto * ( * get_func_proto ) ( e#bpf_func_id , const s#bpf_prog * ) ; t#bool ( * is_valid_access ) ( int , int , e#bpf_access_type , const s#bpf_prog * , s#bpf_insn_access_aux * ) ; int ( * gen_prologue ) ( s#bpf_insn * , t#bool , const s#bpf_prog * ) ; int ( * gen_epilogue ) ( s#bpf_insn * , const s#bpf_prog * , t#s16 ) ; int ( * gen_ld_abs ) ( const s#bpf_insn * , s#bpf_insn * ) ; t#u32 ( * convert_ctx_access ) ( e#bpf_access_type , const s#bpf_insn * , s#bpf_insn * , s#bpf_prog * , t#u32 * ) ; int ( * btf_struct_access ) ( s#bpf_verifier_log * , const s#bpf_reg_state * , int , int ) ; }
s#bpf_verifier_stack_elem struct bpf_verifier_stack_elem { UNKNOWN }
s#bpf_verifier_state struct bpf_verifier_state { s#bpf_func_state * frame [ 8 ] ; s#bpf_verifier_state * parent ; t#u32 branches ; t#u32 insn_idx ; t#u32 curframe ; s#bpf_active_lock active_lock ; t#bool speculative ; t#bool active_rcu_lock ; t#u32 active_preempt_lock ; t#bool used_as_loop_entry ; t#bool in_sleepable ; t#u32 first_insn_idx ; t#u32 last_insn_idx ; s#bpf_verifier_state * loop_entry ; s#bpf_jmp_history_entry * jmp_history ; t#u32 jmp_history_cnt ; t#u32 dfs_depth ; t#u32 callback_unroll_depth ; t#u32 may_goto_depth ; }
s#bpf_verifier_state_list struct bpf_verifier_state_list { s#bpf_verifier_state state ; s#bpf_verifier_state_list * next ; int miss_cnt , hit_cnt ; }
s#bpf_xdp_entity struct bpf_xdp_entity { s#bpf_prog * prog ; s#bpf_xdp_link * link ; }
s#bpf_xdp_link struct bpf_xdp_link { UNKNOWN }
s#bsg_buffer struct bsg_buffer { unsigned int payload_len ; int sg_cnt ; s#scatterlist * sg_list ; }
s#bsg_device struct bsg_device { UNKNOWN }
s#bsg_job@9d4baa3e struct bsg_job { UNKNOWN }
s#bsg_job@e8161648 struct bsg_job { s#device * dev ; s#kref kref ; unsigned int timeout ; void * request ; void * reply ; unsigned int request_len ; unsigned int reply_len ; s#bsg_buffer request_payload ; s#bsg_buffer reply_payload ; int result ; unsigned int reply_payload_rcv_len ; s#request * bidi_rq ; s#bio * bidi_bio ; void * dd_data ; }
s#btf struct btf { UNKNOWN }
s#btf_field struct btf_field { t#u32 offset ; t#u32 size ; e#btf_field_type type ; union { s#btf_field_kptr kptr ; s#btf_field_graph_root graph_root ; } ; }
s#btf_field_graph_root struct btf_field_graph_root { s#btf * btf ; t#u32 value_btf_id ; t#u32 node_offset ; s#btf_record * value_rec ; }
s#btf_field_kptr struct btf_field_kptr { s#btf * btf ; s#module * module ; t#btf_dtor_kfunc_t dtor ; t#u32 btf_id ; }
s#btf_func_model struct btf_func_model { t#u8 ret_size ; t#u8 ret_flags ; t#u8 nr_args ; t#u8 arg_size [ 12 ] ; t#u8 arg_flags [ 12 ] ; }
s#btf_mod_pair struct btf_mod_pair { s#btf * btf ; s#module * module ; }
s#btf_record struct btf_record { t#u32 cnt ; t#u32 field_mask ; int spin_lock_off ; int timer_off ; int wq_off ; int refcount_off ; s#btf_field fields [ ] ; }
s#btf_struct_meta struct btf_struct_meta { t#u32 btf_id ; s#btf_record * record ; }
s#btf_type struct btf_type { t#__u32 name_off ; t#__u32 info ; union { t#__u32 size ; t#__u32 type ; } ; }
s#bucket_table@6a272079 struct bucket_table { UNKNOWN }
s#bucket_table@c560ef84 struct bucket_table { unsigned int size ; unsigned int nest ; t#u32 hash_rnd ; s#list_head walkers ; s#callback_head rcu ; s#bucket_table * future_tbl ; s#lockdep_map dep_map ; s#rhash_lock_head * buckets [ ] __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; }
s#buffer_head struct buffer_head { unsigned long b_state ; s#buffer_head * b_this_page ; union { s#page * b_page ; s#folio * b_folio ; } ; t#sector_t b_blocknr ; t#size_t b_size ; char * b_data ; s#block_device * b_bdev ; t#bh_end_io_t * b_end_io ; void * b_private ; s#list_head b_assoc_buffers ; s#address_space * b_assoc_map ; t#atomic_t b_count ; t#spinlock_t b_uptodate_lock ; }
s#bug_entry struct bug_entry { signed int bug_addr_disp ; signed int file_disp ; unsigned short line ; unsigned short flags ; }
s#bus_dma_region@2684f1cf struct bus_dma_region { UNKNOWN }
s#bus_dma_region@2e19c8ab struct bus_dma_region { t#phys_addr_t cpu_start ; t#dma_addr_t dma_start ; t#u64 size ; }
s#bus_type struct bus_type { const char * name ; const char * dev_name ; const s#attribute_group * * bus_groups ; const s#attribute_group * * dev_groups ; const s#attribute_group * * drv_groups ; int ( * match ) ( s#device * , const s#device_driver * ) ; int ( * uevent ) ( const s#device * , s#kobj_uevent_env * ) ; int ( * probe ) ( s#device * ) ; void ( * sync_state ) ( s#device * ) ; void ( * remove ) ( s#device * ) ; void ( * shutdown ) ( s#device * ) ; int ( * online ) ( s#device * ) ; int ( * offline ) ( s#device * ) ; int ( * suspend ) ( s#device * , t#pm_message_t ) ; int ( * resume ) ( s#device * ) ; int ( * num_vf ) ( s#device * ) ; int ( * dma_configure ) ( s#device * ) ; void ( * dma_cleanup ) ( s#device * ) ; const s#dev_pm_ops * pm ; t#bool need_parent_lock ; }
s#bvec_iter struct bvec_iter { t#sector_t bi_sector ; unsigned int bi_size ; unsigned int bi_idx ; unsigned int bi_bvec_done ; }
s#cache_deferred_req struct cache_deferred_req { s#hlist_node hash ; s#list_head recent ; s#cache_head * item ; void * owner ; void ( * revisit ) ( s#cache_deferred_req * , int ) ; }
s#cache_head struct cache_head { s#hlist_node cache_list ; t#time64_t expiry_time ; t#time64_t last_refresh ; s#kref ref ; unsigned long flags ; }
s#cache_req struct cache_req { s#cache_deferred_req * ( * defer ) ( s#cache_req * ) ; unsigned long thread_wait ; }
s#cacheline_padding struct cacheline_padding { char x [ 0 ] ; }
s#callback_head struct callback_head { s#callback_head * next ; void ( * func ) ( s#callback_head * ) ; }
s#can_dev_rcv_lists@3263b8e3 struct can_dev_rcv_lists { s#hlist_head rx [ E#RX_MAX ] ; s#hlist_head rx_sff [ ( 1 << 11 ) ] ; s#hlist_head rx_eff [ ( 1 << 10 ) ] ; int entries ; }
s#can_dev_rcv_lists@f9a3495b struct can_dev_rcv_lists { UNKNOWN }
s#can_pkg_stats@88f99a3e struct can_pkg_stats { unsigned long jiffies_init ; unsigned long rx_frames ; unsigned long tx_frames ; unsigned long matches ; unsigned long total_rx_rate ; unsigned long total_tx_rate ; unsigned long total_rx_match_ratio ; unsigned long current_rx_rate ; unsigned long current_tx_rate ; unsigned long current_rx_match_ratio ; unsigned long max_rx_rate ; unsigned long max_tx_rate ; unsigned long max_rx_match_ratio ; unsigned long rx_frames_delta ; unsigned long tx_frames_delta ; unsigned long matches_delta ; }
s#can_pkg_stats@b6fbe87d struct can_pkg_stats { UNKNOWN }
s#can_rcv_lists_stats@666de8e2 struct can_rcv_lists_stats { unsigned long stats_reset ; unsigned long user_reset ; unsigned long rcv_entries ; unsigned long rcv_entries_max ; }
s#can_rcv_lists_stats@7dc788d5 struct can_rcv_lists_stats { UNKNOWN }
s#capture_control@6270f693 struct capture_control { s#compact_control * cc ; s#page * page ; }
s#capture_control@e8ae89d1 struct capture_control { UNKNOWN }
s#cdev@581f6d64 struct cdev { s#kobject kobj ; s#module * owner ; const s#file_operations * ops ; s#list_head list ; t#dev_t dev ; unsigned int count ; }
s#cdev@69ffcaf2 struct cdev { UNKNOWN }
s#cdrom_device_info@e6f8c1d8 struct cdrom_device_info { const s#cdrom_device_ops * ops ; s#list_head list ; s#gendisk * disk ; void * handle ; int mask ; int speed ; int capacity ; unsigned int options : 30 ; unsigned mc_flags : 2 ; unsigned int vfs_events ; unsigned int ioctl_events ; int use_count ; char name [ 20 ] ; t#__u8 sanyo_slot : 2 ; t#__u8 keeplocked : 1 ; t#__u8 reserved : 5 ; int cdda_method ; t#__u8 last_sense ; t#__u8 media_written ; unsigned short mmc3_profile ; int ( * exit ) ( s#cdrom_device_info * ) ; int mrw_mode_page ; t#bool opened_for_data ; t#__s64 last_media_change_ms ; }
s#cdrom_device_info@edfd2f7d struct cdrom_device_info { UNKNOWN }
s#cdrom_device_ops struct cdrom_device_ops { int ( * open ) ( s#cdrom_device_info * , int ) ; void ( * release ) ( s#cdrom_device_info * ) ; int ( * drive_status ) ( s#cdrom_device_info * , int ) ; unsigned int ( * check_events ) ( s#cdrom_device_info * , unsigned int , int ) ; int ( * tray_move ) ( s#cdrom_device_info * , int ) ; int ( * lock_door ) ( s#cdrom_device_info * , int ) ; int ( * select_speed ) ( s#cdrom_device_info * , unsigned long ) ; int ( * get_last_session ) ( s#cdrom_device_info * , s#cdrom_multisession * ) ; int ( * get_mcn ) ( s#cdrom_device_info * , s#cdrom_mcn * ) ; int ( * reset ) ( s#cdrom_device_info * ) ; int ( * audio_ioctl ) ( s#cdrom_device_info * , unsigned int , void * ) ; int ( * generic_packet ) ( s#cdrom_device_info * , s#packet_command * ) ; int ( * read_cdda_bpc ) ( s#cdrom_device_info * , void * , t#u32 , t#u32 , t#u8 * ) ; const int capability ; }
s#cdrom_mcn struct cdrom_mcn { t#__u8 medium_catalog_number [ 14 ] ; }
s#cdrom_msf0 struct cdrom_msf0 { t#__u8 minute ; t#__u8 second ; t#__u8 frame ; }
s#cdrom_multisession struct cdrom_multisession { u#cdrom_addr addr ; t#__u8 xa_flag ; t#__u8 addr_format ; }
s#cee_pfc struct cee_pfc { t#__u8 willing ; t#__u8 error ; t#__u8 pfc_en ; t#__u8 tcs_supported ; }
s#cee_pg struct cee_pg { t#__u8 willing ; t#__u8 error ; t#__u8 pg_en ; t#__u8 tcs_supported ; t#__u8 pg_bw [ 8 ] ; t#__u8 prio_pg [ 8 ] ; }
s#cfg80211_bss struct cfg80211_bss { s#ieee80211_channel * channel ; const s#cfg80211_bss_ies * ies ; const s#cfg80211_bss_ies * beacon_ies ; const s#cfg80211_bss_ies * proberesp_ies ; s#cfg80211_bss * hidden_beacon_bss ; s#cfg80211_bss * transmitted_bss ; s#list_head nontrans_list ; t#s32 signal ; t#u16 beacon_interval ; t#u16 capability ; t#u8 bssid [ 6 ] ; t#u8 chains ; t#s8 chain_signal [ 4 ] ; t#u8 proberesp_ecsa_stuck : 1 ; t#u8 bssid_index ; t#u8 max_bssid_indicator ; t#u8 use_for ; t#u8 cannot_use_reasons ; t#u8 priv [ ] __attribute__ ( ( __aligned__ ( sizeof ( void * ) ) ) ) ; }
s#cfg80211_bss_ies struct cfg80211_bss_ies { t#u64 tsf ; s#callback_head callback_head ; int len ; t#bool from_beacon ; t#u8 data [ ] ; }
s#cfg80211_bss_select_adjust struct cfg80211_bss_select_adjust { e#nl80211_band band ; t#s8 delta ; }
s#cfg80211_bss_selection struct cfg80211_bss_selection { e#nl80211_bss_select_attr behaviour ; union { e#nl80211_band band_pref ; s#cfg80211_bss_select_adjust adjust ; } param ; }
s#cfg80211_cached_keys@8d6b3ce0 struct cfg80211_cached_keys { UNKNOWN }
s#cfg80211_cached_keys@dc6ed8ac struct cfg80211_cached_keys { s#key_params params [ 4 ] ; t#u8 data [ 4 ] [ E#WLAN_KEY_LEN_WEP104 ] ; int def ; }
s#cfg80211_chan_def struct cfg80211_chan_def { s#ieee80211_channel * chan ; e#nl80211_chan_width width ; t#u32 center_freq1 ; t#u32 center_freq2 ; s#ieee80211_edmg edmg ; t#u16 freq1_offset ; t#u16 punctured ; }
s#cfg80211_conn struct cfg80211_conn { UNKNOWN }
s#cfg80211_connect_params struct cfg80211_connect_params { s#ieee80211_channel * channel ; s#ieee80211_channel * channel_hint ; const t#u8 * bssid ; const t#u8 * bssid_hint ; const t#u8 * ssid ; t#size_t ssid_len ; e#nl80211_auth_type auth_type ; const t#u8 * ie ; t#size_t ie_len ; t#bool privacy ; e#nl80211_mfp mfp ; s#cfg80211_crypto_settings crypto ; const t#u8 * key ; t#u8 key_len , key_idx ; t#u32 flags ; int bg_scan_period ; s#ieee80211_ht_cap ht_capa ; s#ieee80211_ht_cap ht_capa_mask ; s#ieee80211_vht_cap vht_capa ; s#ieee80211_vht_cap vht_capa_mask ; t#bool pbss ; s#cfg80211_bss_selection bss_select ; const t#u8 * prev_bssid ; const t#u8 * fils_erp_username ; t#size_t fils_erp_username_len ; const t#u8 * fils_erp_realm ; t#size_t fils_erp_realm_len ; t#u16 fils_erp_next_seq_num ; const t#u8 * fils_erp_rrk ; t#size_t fils_erp_rrk_len ; t#bool want_1x ; s#ieee80211_edmg edmg ; }
s#cfg80211_cqm_config@051c039c struct cfg80211_cqm_config { s#callback_head callback_head ; t#u32 rssi_hyst ; t#s32 last_rssi_event_value ; e#nl80211_cqm_rssi_threshold_event last_rssi_event_type ; t#bool use_range_api ; int n_rssi_thresholds ; t#s32 rssi_thresholds [ ] ; }
s#cfg80211_cqm_config@cac5e26f struct cfg80211_cqm_config { UNKNOWN }
s#cfg80211_crypto_settings struct cfg80211_crypto_settings { t#u32 wpa_versions ; t#u32 cipher_group ; int n_ciphers_pairwise ; t#u32 ciphers_pairwise [ 5 ] ; int n_akm_suites ; t#u32 akm_suites [ 10 ] ; t#bool control_port ; t#__be16 control_port_ethertype ; t#bool control_port_no_encrypt ; t#bool control_port_over_nl80211 ; t#bool control_port_no_preauth ; const t#u8 * psk ; const t#u8 * sae_pwd ; t#u8 sae_pwd_len ; e#nl80211_sae_pwe_mechanism sae_pwe ; }
s#cfg80211_ibss_params struct cfg80211_ibss_params { const t#u8 * ssid ; const t#u8 * bssid ; s#cfg80211_chan_def chandef ; const t#u8 * ie ; t#u8 ssid_len , ie_len ; t#u16 beacon_interval ; t#u32 basic_rates ; t#bool channel_fixed ; t#bool privacy ; t#bool control_port ; t#bool control_port_over_nl80211 ; t#bool userspace_handles_dfs ; int mcast_rate [ E#NUM_NL80211_BANDS ] ; s#ieee80211_ht_cap ht_capa ; s#ieee80211_ht_cap ht_capa_mask ; s#key_params * wep_keys ; int wep_tx_key ; }
s#cfg80211_internal_bss@a2f7b12b struct cfg80211_internal_bss { s#list_head list ; s#list_head hidden_list ; s#rb_node rbn ; t#u64 ts_boottime ; unsigned long ts ; unsigned long refcount ; t#atomic_t hold ; t#u64 parent_tsf ; t#u8 parent_bssid [ 6 ] __attribute__ ( ( __aligned__ ( 2 ) ) ) ; e#bss_source_type bss_source ; s#cfg80211_bss pub ; }
s#cfg80211_internal_bss@aa6240ed struct cfg80211_internal_bss { UNKNOWN }
s#cfg80211_match_set struct cfg80211_match_set { s#cfg80211_ssid ssid ; t#u8 bssid [ 6 ] ; t#s32 rssi_thold ; }
s#cfg80211_pkt_pattern struct cfg80211_pkt_pattern { const t#u8 * mask , * pattern ; int pattern_len ; int pkt_offset ; }
s#cfg80211_pmsr_capabilities struct cfg80211_pmsr_capabilities { unsigned int max_peers ; t#u8 report_ap_tsf : 1 , randomize_mac_addr : 1 ; struct { t#u32 preambles ; t#u32 bandwidths ; t#s8 max_bursts_exponent ; t#u8 max_ftms_per_burst ; t#u8 supported : 1 , asap : 1 , non_asap : 1 , request_lci : 1 , request_civicloc : 1 , trigger_based : 1 , non_trigger_based : 1 ; } ftm ; }
s#cfg80211_sar_capa struct cfg80211_sar_capa { e#nl80211_sar_type type ; t#u32 num_freq_ranges ; const s#cfg80211_sar_freq_ranges * freq_ranges ; }
s#cfg80211_sar_freq_ranges struct cfg80211_sar_freq_ranges { t#u32 start_freq ; t#u32 end_freq ; }
s#cfg80211_sched_scan_plan struct cfg80211_sched_scan_plan { t#u32 interval ; t#u32 iterations ; }
s#cfg80211_sched_scan_request struct cfg80211_sched_scan_request { t#u64 reqid ; s#cfg80211_ssid * ssids ; int n_ssids ; t#u32 n_channels ; const t#u8 * ie ; t#size_t ie_len ; t#u32 flags ; s#cfg80211_match_set * match_sets ; int n_match_sets ; t#s32 min_rssi_thold ; t#u32 delay ; s#cfg80211_sched_scan_plan * scan_plans ; int n_scan_plans ; t#u8 mac_addr [ 6 ] __attribute__ ( ( __aligned__ ( 2 ) ) ) ; t#u8 mac_addr_mask [ 6 ] __attribute__ ( ( __aligned__ ( 2 ) ) ) ; t#bool relative_rssi_set ; t#s8 relative_rssi ; s#cfg80211_bss_select_adjust rssi_adjust ; s#wiphy * wiphy ; s#net_device * dev ; unsigned long scan_start ; t#bool report_results ; s#callback_head callback_head ; t#u32 owner_nlportid ; t#bool nl_owner_dead ; s#list_head list ; s#ieee80211_channel * channels [ ] ; }
s#cfg80211_ssid struct cfg80211_ssid { t#u8 ssid [ 32 ] ; t#u8 ssid_len ; }
s#cfg80211_wowlan struct cfg80211_wowlan { t#bool any , disconnect , magic_pkt , gtk_rekey_failure , eap_identity_req , four_way_handshake , rfkill_release ; s#cfg80211_pkt_pattern * patterns ; s#cfg80211_wowlan_tcp * tcp ; int n_patterns ; s#cfg80211_sched_scan_request * nd_config ; }
s#cfg80211_wowlan_tcp struct cfg80211_wowlan_tcp { s#socket * sock ; t#__be32 src , dst ; t#u16 src_port , dst_port ; t#u8 dst_mac [ 6 ] ; int payload_len ; const t#u8 * payload ; s#nl80211_wowlan_tcp_data_seq payload_seq ; t#u32 data_interval ; t#u32 wake_len ; const t#u8 * wake_data , * wake_mask ; t#u32 tokens_size ; s#nl80211_wowlan_tcp_data_token payload_tok ; }
s#cfs_bandwidth struct cfs_bandwidth { t#raw_spinlock_t lock ; t#ktime_t period ; t#u64 quota ; t#u64 runtime ; t#u64 burst ; t#u64 runtime_snap ; t#s64 hierarchical_quota ; t#u8 idle ; t#u8 period_active ; t#u8 slack_started ; s#hrtimer period_timer ; s#hrtimer slack_timer ; s#list_head throttled_cfs_rq ; int nr_periods ; int nr_throttled ; int nr_burst ; t#u64 throttled_time ; t#u64 burst_time ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#cfs_rq@b985a5b8 struct cfs_rq { UNKNOWN }
s#cfs_rq@e9ea2393 struct cfs_rq { s#load_weight load ; unsigned int nr_running ; unsigned int h_nr_running ; unsigned int idle_nr_running ; unsigned int idle_h_nr_running ; unsigned int h_nr_delayed ; t#s64 avg_vruntime ; t#u64 avg_load ; t#u64 min_vruntime ; unsigned int forceidle_seq ; t#u64 min_vruntime_fi ; s#rb_root_cached tasks_timeline ; s#sched_entity * curr ; s#sched_entity * next ; s#sched_avg avg ; struct { t#raw_spinlock_t lock __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; int nr ; unsigned long load_avg ; unsigned long util_avg ; unsigned long runnable_avg ; } removed ; t#u64 last_update_tg_load_avg ; unsigned long tg_load_avg_contrib ; long propagate ; long prop_runnable_sum ; unsigned long h_load ; t#u64 last_h_load_update ; s#sched_entity * h_load_next ; s#rq * rq ; int on_list ; s#list_head leaf_cfs_rq_list ; s#task_group * tg ; int idle ; int runtime_enabled ; t#s64 runtime_remaining ; t#u64 throttled_pelt_idle ; t#u64 throttled_clock ; t#u64 throttled_clock_pelt ; t#u64 throttled_clock_pelt_time ; t#u64 throttled_clock_self ; t#u64 throttled_clock_self_time ; int throttled ; int throttle_count ; s#list_head throttled_list ; s#list_head throttled_csd_list ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#cftype struct cftype { char name [ 64 ] ; unsigned long private ; t#size_t max_write_len ; unsigned int flags ; unsigned int file_offset ; s#cgroup_subsys * ss ; s#list_head node ; s#kernfs_ops * kf_ops ; int ( * open ) ( s#kernfs_open_file * ) ; void ( * release ) ( s#kernfs_open_file * ) ; t#u64 ( * read_u64 ) ( s#cgroup_subsys_state * , s#cftype * ) ; t#s64 ( * read_s64 ) ( s#cgroup_subsys_state * , s#cftype * ) ; int ( * seq_show ) ( s#seq_file * , void * ) ; void * ( * seq_start ) ( s#seq_file * , t#loff_t * ) ; void * ( * seq_next ) ( s#seq_file * , void * , t#loff_t * ) ; void ( * seq_stop ) ( s#seq_file * , void * ) ; int ( * write_u64 ) ( s#cgroup_subsys_state * , s#cftype * , t#u64 ) ; int ( * write_s64 ) ( s#cgroup_subsys_state * , s#cftype * , t#s64 ) ; t#ssize_t ( * write ) ( s#kernfs_open_file * , char * , t#size_t , t#loff_t ) ; t#__poll_t ( * poll ) ( s#kernfs_open_file * , s#poll_table_struct * ) ; s#lock_class_key lockdep_key ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#cgroup@49126c15 struct cgroup { s#cgroup_subsys_state self ; unsigned long flags ; int level ; int max_depth ; int nr_descendants ; int nr_dying_descendants ; int max_descendants ; int nr_populated_csets ; int nr_populated_domain_children ; int nr_populated_threaded_children ; int nr_threaded_children ; unsigned int kill_seq ; s#kernfs_node * kn ; s#cgroup_file procs_file ; s#cgroup_file events_file ; s#cgroup_file psi_files [ E#NR_PSI_RESOURCES ] ; t#u16 subtree_control ; t#u16 subtree_ss_mask ; t#u16 old_subtree_control ; t#u16 old_subtree_ss_mask ; s#cgroup_subsys_state * subsys [ E#CGROUP_SUBSYS_COUNT ] ; int nr_dying_subsys [ E#CGROUP_SUBSYS_COUNT ] ; s#cgroup_root * root ; s#list_head cset_links ; s#list_head e_csets [ E#CGROUP_SUBSYS_COUNT ] ; s#cgroup * dom_cgrp ; s#cgroup * old_dom_cgrp ; s#cgroup_rstat_cpu * rstat_cpu ; s#list_head rstat_css_list ; s#cacheline_padding _pad_ ; s#cgroup * rstat_flush_next ; s#cgroup_base_stat last_bstat ; s#cgroup_base_stat bstat ; s#prev_cputime prev_cputime ; s#list_head pidlists ; s#mutex pidlist_mutex ; t#wait_queue_head_t offline_waitq ; s#work_struct release_agent_work ; s#psi_group * psi ; s#cgroup_bpf bpf ; s#cgroup_freezer_state freezer ; s#bpf_local_storage * bpf_cgrp_storage ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; s#cgroup * ancestors [ ] ; }
s#cgroup@ec9d5f7b struct cgroup { UNKNOWN }
s#cgroup_base_stat struct cgroup_base_stat { s#task_cputime cputime ; t#u64 forceidle_sum ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#cgroup_bpf struct cgroup_bpf { s#bpf_prog_array * effective [ E#MAX_CGROUP_BPF_ATTACH_TYPE ] ; s#hlist_head progs [ E#MAX_CGROUP_BPF_ATTACH_TYPE ] ; t#u8 flags [ E#MAX_CGROUP_BPF_ATTACH_TYPE ] ; s#list_head storages ; s#bpf_prog_array * inactive ; s#percpu_ref refcnt ; s#work_struct release_work ; }
s#cgroup_file struct cgroup_file { s#kernfs_node * kn ; unsigned long notified_at ; s#timer_list notify_timer ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#cgroup_freezer_state struct cgroup_freezer_state { t#bool freeze ; int e_freeze ; int nr_frozen_descendants ; int nr_frozen_tasks ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#cgroup_namespace@5ac1c800 struct cgroup_namespace { s#ns_common ns ; s#user_namespace * user_ns ; s#ucounts * ucounts ; s#css_set * root_cset ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#cgroup_namespace@b9b52aeb struct cgroup_namespace { UNKNOWN }
s#cgroup_root struct cgroup_root { s#kernfs_root * kf_root ; unsigned int subsys_mask ; int hierarchy_id ; s#list_head root_list ; s#callback_head rcu ; s#cgroup cgrp ; s#cgroup * cgrp_ancestor_storage ; t#atomic_t nr_cgrps ; unsigned int flags ; char release_agent_path [ 4096 ] ; char name [ 64 ] ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#cgroup_rstat_cpu struct cgroup_rstat_cpu { s#u64_stats_sync bsync ; s#cgroup_base_stat bstat ; s#cgroup_base_stat last_bstat ; s#cgroup_base_stat subtree_bstat ; s#cgroup_base_stat last_subtree_bstat ; s#cgroup * updated_children ; s#cgroup * updated_next ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#cgroup_subsys struct cgroup_subsys { s#cgroup_subsys_state * ( * css_alloc ) ( s#cgroup_subsys_state * ) ; int ( * css_online ) ( s#cgroup_subsys_state * ) ; void ( * css_offline ) ( s#cgroup_subsys_state * ) ; void ( * css_released ) ( s#cgroup_subsys_state * ) ; void ( * css_free ) ( s#cgroup_subsys_state * ) ; void ( * css_reset ) ( s#cgroup_subsys_state * ) ; void ( * css_rstat_flush ) ( s#cgroup_subsys_state * , int ) ; int ( * css_extra_stat_show ) ( s#seq_file * , s#cgroup_subsys_state * ) ; int ( * css_local_stat_show ) ( s#seq_file * , s#cgroup_subsys_state * ) ; int ( * can_attach ) ( s#cgroup_taskset * ) ; void ( * cancel_attach ) ( s#cgroup_taskset * ) ; void ( * attach ) ( s#cgroup_taskset * ) ; void ( * post_attach ) ( void ) ; int ( * can_fork ) ( s#task_struct * , s#css_set * ) ; void ( * cancel_fork ) ( s#task_struct * , s#css_set * ) ; void ( * fork ) ( s#task_struct * ) ; void ( * exit ) ( s#task_struct * ) ; void ( * release ) ( s#task_struct * ) ; void ( * bind ) ( s#cgroup_subsys_state * ) ; t#bool early_init : 1 ; t#bool implicit_on_dfl : 1 ; t#bool threaded : 1 ; int id ; const char * name ; const char * legacy_name ; s#cgroup_root * root ; s#idr css_idr ; s#list_head cfts ; s#cftype * dfl_cftypes ; s#cftype * legacy_cftypes ; unsigned int depends_on ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#cgroup_subsys_state@9592e946 struct cgroup_subsys_state { UNKNOWN }
s#cgroup_subsys_state@ffe2cd4b struct cgroup_subsys_state { s#cgroup * cgroup ; s#cgroup_subsys * ss ; s#percpu_ref refcnt ; s#list_head sibling ; s#list_head children ; s#list_head rstat_css_node ; int id ; unsigned int flags ; t#u64 serial_nr ; t#atomic_t online_cnt ; s#work_struct destroy_work ; s#rcu_work destroy_rwork ; s#cgroup_subsys_state * parent ; int nr_descendants ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#cgroup_taskset@1a4c4a87 struct cgroup_taskset { UNKNOWN }
s#cgroup_taskset@da8a1a89 struct cgroup_taskset { s#list_head src_csets ; s#list_head dst_csets ; int nr_tasks ; int ssid ; s#list_head * csets ; s#css_set * cur_cset ; s#task_struct * cur_task ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#ch_sched_params struct ch_sched_params { t#u8 type ; union { struct { t#u8 level ; t#u8 mode ; t#u8 rateunit ; t#u8 ratemode ; t#u8 channel ; t#u8 class ; t#u32 minrate ; t#u32 maxrate ; t#u16 weight ; t#u16 pktsize ; t#u16 burstsize ; } params ; } u ; }
s#cipher_alg struct cipher_alg { unsigned int cia_min_keysize ; unsigned int cia_max_keysize ; int ( * cia_setkey ) ( s#crypto_tfm * , const t#u8 * , unsigned int ) ; void ( * cia_encrypt ) ( s#crypto_tfm * , t#u8 * , const t#u8 * ) ; void ( * cia_decrypt ) ( s#crypto_tfm * , t#u8 * , const t#u8 * ) ; }
s#cipher_context struct cipher_context { char iv [ 16 + 4 ] ; char rec_seq [ 8 ] ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#class struct class { const char * name ; const s#attribute_group * * class_groups ; const s#attribute_group * * dev_groups ; int ( * dev_uevent ) ( const s#device * , s#kobj_uevent_env * ) ; char * ( * devnode ) ( const s#device * , t#umode_t * ) ; void ( * class_release ) ( const s#class * ) ; void ( * dev_release ) ( s#device * ) ; int ( * shutdown_pre ) ( s#device * ) ; const s#kobj_ns_type_operations * ns_type ; const void * ( * namespace ) ( const s#device * ) ; void ( * get_ownership ) ( const s#device * , t#kuid_t * , t#kgid_t * ) ; const s#dev_pm_ops * pm ; }
s#cma struct cma { UNKNOWN }
s#compact_control struct compact_control { s#list_head freepages [ ( 10 + 1 ) ] ; s#list_head migratepages ; unsigned int nr_freepages ; unsigned int nr_migratepages ; unsigned long free_pfn ; unsigned long migrate_pfn ; unsigned long fast_start_pfn ; s#zone * zone ; unsigned long total_migrate_scanned ; unsigned long total_free_scanned ; unsigned short fast_search_fail ; short search_order ; const t#gfp_t gfp_mask ; int order ; int migratetype ; const unsigned int alloc_flags ; const int highest_zoneidx ; e#migrate_mode mode ; t#bool ignore_skip_hint ; t#bool no_set_skip_hint ; t#bool ignore_block_suitable ; t#bool direct_compaction ; t#bool proactive_compaction ; t#bool whole_zone ; t#bool contended ; t#bool finish_pageblock ; t#bool alloc_contig ; }
s#compat_robust_list struct compat_robust_list { t#compat_uptr_t next ; }
s#compat_robust_list_head@320188e6 struct compat_robust_list_head { s#compat_robust_list list ; t#compat_long_t futex_offset ; t#compat_uptr_t list_op_pending ; }
s#compat_robust_list_head@d2202b4f struct compat_robust_list_head { UNKNOWN }
s#completion@0667153d struct completion { UNKNOWN }
s#completion@136faf3e struct completion { unsigned int done ; s#swait_queue_head wait ; }
s#compress_alg struct compress_alg { int ( * coa_compress ) ( s#crypto_tfm * , const t#u8 * , unsigned int , t#u8 * , unsigned int * ) ; int ( * coa_decompress ) ( s#crypto_tfm * , const t#u8 * , unsigned int , t#u8 * , unsigned int * ) ; }
s#cond_snapshot struct cond_snapshot { void * cond_data ; t#cond_update_fn_t update ; }
s#core_state struct core_state { t#atomic_t nr_threads ; s#core_thread dumper ; s#completion startup ; }
s#core_thread struct core_thread { s#task_struct * task ; s#core_thread * next ; }
s#core_vma_metadata struct core_vma_metadata { unsigned long start , end ; unsigned long flags ; unsigned long dump_size ; unsigned long pgoff ; s#file * file ; }
s#coredump_params@c0ae74d4 struct coredump_params { UNKNOWN }
s#coredump_params@fb813bbf struct coredump_params { const t#kernel_siginfo_t * siginfo ; s#file * file ; unsigned long limit ; unsigned long mm_flags ; int cpu ; t#loff_t written ; t#loff_t pos ; t#loff_t to_skip ; int vma_count ; t#size_t vma_data_size ; s#core_vma_metadata * vma_meta ; unsigned long uek_reserved1 ; }
s#cpu_itimer struct cpu_itimer { t#u64 expires ; t#u64 incr ; }
s#cpu_rmap@6ceb081f struct cpu_rmap { s#kref refcount ; t#u16 size ; void * * obj ; struct { t#u16 index ; t#u16 dist ; } near [ ] ; }
s#cpu_rmap@912b6b64 struct cpu_rmap { UNKNOWN }
s#cpu_stop_done struct cpu_stop_done { UNKNOWN }
s#cpu_stop_work struct cpu_stop_work { s#list_head list ; t#cpu_stop_fn_t fn ; unsigned long caller ; void * arg ; s#cpu_stop_done * done ; }
s#cpudl struct cpudl { t#raw_spinlock_t lock ; int size ; t#cpumask_var_t free_cpus ; s#cpudl_item * elements ; }
s#cpudl_item struct cpudl_item { t#u64 dl ; int cpu ; int idx ; }
s#cpuidle_device struct cpuidle_device { unsigned int registered : 1 ; unsigned int enabled : 1 ; unsigned int poll_time_limit : 1 ; unsigned int cpu ; t#ktime_t next_hrtimer ; int last_state_idx ; t#u64 last_residency_ns ; t#u64 poll_limit_ns ; t#u64 forced_idle_latency_limit_ns ; s#cpuidle_state_usage states_usage [ 10 ] ; s#cpuidle_state_kobj * kobjs [ 10 ] ; s#cpuidle_driver_kobj * kobj_driver ; s#cpuidle_device_kobj * kobj_dev ; s#list_head device_list ; }
s#cpuidle_device_kobj struct cpuidle_device_kobj { UNKNOWN }
s#cpuidle_driver struct cpuidle_driver { const char * name ; s#module * owner ; unsigned int bctimer : 1 ; s#cpuidle_state states [ 10 ] ; int state_count ; int safe_state_index ; s#cpumask * cpumask ; const char * governor ; }
s#cpuidle_driver_kobj struct cpuidle_driver_kobj { UNKNOWN }
s#cpuidle_state@0db9253f struct cpuidle_state { UNKNOWN }
s#cpuidle_state@db91e22a struct cpuidle_state { char name [ 16 ] ; char desc [ 32 ] ; t#s64 exit_latency_ns ; t#s64 target_residency_ns ; unsigned int flags ; unsigned int exit_latency ; int power_usage ; unsigned int target_residency ; int ( * enter ) ( s#cpuidle_device * , s#cpuidle_driver * , int ) ; int ( * enter_dead ) ( s#cpuidle_device * , int ) ; int ( * enter_s2idle ) ( s#cpuidle_device * , s#cpuidle_driver * , int ) ; }
s#cpuidle_state_kobj struct cpuidle_state_kobj { UNKNOWN }
s#cpuidle_state_usage struct cpuidle_state_usage { unsigned long long disable ; unsigned long long usage ; t#u64 time_ns ; unsigned long long above ; unsigned long long below ; unsigned long long rejected ; unsigned long long s2idle_usage ; unsigned long long s2idle_time ; }
s#cpuinfo_topology struct cpuinfo_topology { t#u32 apicid ; t#u32 initial_apicid ; t#u32 pkg_id ; t#u32 die_id ; t#u32 cu_id ; t#u32 core_id ; t#u32 logical_pkg_id ; t#u32 logical_die_id ; t#u32 amd_node_id ; t#u32 llc_id ; t#u32 l2c_id ; }
s#cpuinfo_x86 struct cpuinfo_x86 { union { struct { t#__u8 x86_model ; t#__u8 x86 ; t#__u8 x86_vendor ; t#__u8 x86_reserved ; } ; t#__u32 x86_vfm ; } ; t#__u8 x86_stepping ; int x86_tlbsize ; t#__u32 vmx_capability [ 5 ] ; t#__u8 x86_virt_bits ; t#__u8 x86_phys_bits ; t#__u32 extended_cpuid_level ; int cpuid_level ; union { t#__u32 x86_capability [ 24 + 3 ] ; unsigned long x86_capability_alignment ; } ; char x86_vendor_id [ 16 ] ; char x86_model_id [ 64 ] ; s#cpuinfo_topology topo ; unsigned int x86_cache_size ; int x86_cache_alignment ; int x86_cache_max_rmid ; int x86_cache_occ_scale ; int x86_cache_mbm_width_offset ; int x86_power ; unsigned long loops_per_jiffy ; t#u64 ppin ; t#u16 x86_clflush_size ; t#u16 booted_cores ; t#u16 cpu_index ; t#bool smt_active ; t#u32 microcode ; t#u8 x86_cache_bits ; unsigned initialized : 1 ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; }
s#cpumask struct cpumask { unsigned long bits [ ( ( ( 8192 ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; }
s#cpupri struct cpupri { s#cpupri_vec pri_to_cpu [ ( 100 + 1 ) ] ; int * cpu_to_pri ; }
s#cpupri_vec struct cpupri_vec { t#atomic_t count ; t#cpumask_var_t mask ; }
s#cred@94bccd5d struct cred { t#atomic_long_t usage ; t#kuid_t uid ; t#kgid_t gid ; t#kuid_t suid ; t#kgid_t sgid ; t#kuid_t euid ; t#kgid_t egid ; t#kuid_t fsuid ; t#kgid_t fsgid ; unsigned securebits ; t#kernel_cap_t cap_inheritable ; t#kernel_cap_t cap_permitted ; t#kernel_cap_t cap_effective ; t#kernel_cap_t cap_bset ; t#kernel_cap_t cap_ambient ; unsigned char jit_keyring ; s#key * session_keyring ; s#key * process_keyring ; s#key * thread_keyring ; s#key * request_key_auth ; void * security ; s#user_struct * user ; s#user_namespace * user_ns ; s#ucounts * ucounts ; s#group_info * group_info ; union { int non_rcu ; s#callback_head rcu ; } ; }
s#cred@f160657f struct cred { UNKNOWN }
s#crypto_aead@6fc7813e struct crypto_aead { UNKNOWN }
s#crypto_aead@e7047741 struct crypto_aead { unsigned int authsize ; unsigned int reqsize ; s#crypto_tfm base ; }
s#crypto_alg struct crypto_alg { s#list_head cra_list ; s#list_head cra_users ; t#u32 cra_flags ; unsigned int cra_blocksize ; unsigned int cra_ctxsize ; unsigned int cra_alignmask ; int cra_priority ; t#refcount_t cra_refcnt ; char cra_name [ 128 ] ; char cra_driver_name [ 128 ] ; const s#crypto_type * cra_type ; union { s#cipher_alg cipher ; s#compress_alg compress ; } cra_u ; int ( * cra_init ) ( s#crypto_tfm * ) ; void ( * cra_exit ) ( s#crypto_tfm * ) ; void ( * cra_destroy ) ( s#crypto_alg * ) ; s#module * cra_module ; }
s#crypto_instance struct crypto_instance { s#crypto_alg alg ; s#crypto_template * tmpl ; union { s#hlist_node list ; s#crypto_spawn * spawns ; } ; s#work_struct free_work ; void * __ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; }
s#crypto_shash@7e73aaa1 struct crypto_shash { UNKNOWN }
s#crypto_shash@8cbca1df struct crypto_shash { unsigned int descsize ; s#crypto_tfm base ; }
s#crypto_skcipher@5b727d26 struct crypto_skcipher { UNKNOWN }
s#crypto_skcipher@83561995 struct crypto_skcipher { unsigned int reqsize ; s#crypto_tfm base ; }
s#crypto_spawn struct crypto_spawn { s#list_head list ; s#crypto_alg * alg ; union { s#crypto_instance * inst ; s#crypto_spawn * next ; } ; const s#crypto_type * frontend ; t#u32 mask ; t#bool dead ; t#bool registered ; }
s#crypto_template struct crypto_template { s#list_head list ; s#hlist_head instances ; s#module * module ; int ( * create ) ( s#crypto_template * , s#rtattr * * ) ; char name [ 128 ] ; }
s#crypto_tfm struct crypto_tfm { t#refcount_t refcnt ; t#u32 crt_flags ; int node ; void ( * exit ) ( s#crypto_tfm * ) ; s#crypto_alg * __crt_alg ; void * __crt_ctx [ ] __attribute__ ( ( __aligned__ ( __alignof__ ( unsigned long long ) ) ) ) ; }
s#crypto_type@4a721d01 struct crypto_type { unsigned int ( * ctxsize ) ( s#crypto_alg * , t#u32 , t#u32 ) ; unsigned int ( * extsize ) ( s#crypto_alg * ) ; int ( * init_tfm ) ( s#crypto_tfm * ) ; void ( * show ) ( s#seq_file * , s#crypto_alg * ) ; int ( * report ) ( s#sk_buff * , s#crypto_alg * ) ; void ( * free ) ( s#crypto_instance * ) ; unsigned int type ; unsigned int maskclear ; unsigned int maskset ; unsigned int tfmsize ; }
s#crypto_type@8ac414c2 struct crypto_type { UNKNOWN }
s#css_set@6c95c1f1 struct css_set { s#cgroup_subsys_state * subsys [ E#CGROUP_SUBSYS_COUNT ] ; t#refcount_t refcount ; s#css_set * dom_cset ; s#cgroup * dfl_cgrp ; int nr_tasks ; s#list_head tasks ; s#list_head mg_tasks ; s#list_head dying_tasks ; s#list_head task_iters ; s#list_head e_cset_node [ E#CGROUP_SUBSYS_COUNT ] ; s#list_head threaded_csets ; s#list_head threaded_csets_node ; s#hlist_node hlist ; s#list_head cgrp_links ; s#list_head mg_src_preload_node ; s#list_head mg_dst_preload_node ; s#list_head mg_node ; s#cgroup * mg_src_cgrp ; s#cgroup * mg_dst_cgrp ; s#css_set * mg_dst_cset ; t#bool dead ; s#callback_head callback_head ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#css_set@90aef3e2 struct css_set { UNKNOWN }
s#ctl_dir struct ctl_dir { s#ctl_table_header header ; s#rb_root root ; }
s#ctl_node struct ctl_node { s#rb_node node ; s#ctl_table_header * header ; }
s#ctl_table struct ctl_table { const char * procname ; void * data ; int maxlen ; t#umode_t mode ; t#proc_handler * proc_handler ; s#ctl_table_poll * poll ; void * extra1 ; void * extra2 ; }
s#ctl_table_header struct ctl_table_header { union { struct { s#ctl_table * ctl_table ; int ctl_table_size ; int used ; int count ; int nreg ; } ; s#callback_head rcu ; } ; s#completion * unregistering ; const s#ctl_table * ctl_table_arg ; s#ctl_table_root * root ; s#ctl_table_set * set ; s#ctl_dir * parent ; s#ctl_node * node ; s#hlist_head inodes ; enum { SYSCTL_TABLE_TYPE_DEFAULT , SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY , } type ; }
s#ctl_table_poll struct ctl_table_poll { t#atomic_t event ; t#wait_queue_head_t wait ; }
s#ctl_table_root struct ctl_table_root { s#ctl_table_set default_set ; s#ctl_table_set * ( * lookup ) ( s#ctl_table_root * ) ; void ( * set_ownership ) ( s#ctl_table_header * , t#kuid_t * , t#kgid_t * ) ; int ( * permissions ) ( s#ctl_table_header * , const s#ctl_table * ) ; }
s#ctl_table_set struct ctl_table_set { int ( * is_seen ) ( s#ctl_table_set * ) ; s#ctl_dir dir ; }
s#dax_device struct dax_device { UNKNOWN }
s#dcb_app struct dcb_app { t#__u8 selector ; t#__u8 priority ; t#__u16 protocol ; }
s#dcb_peer_app_info struct dcb_peer_app_info { t#__u8 willing ; t#__u8 error ; }
s#dcbnl_buffer struct dcbnl_buffer { t#__u8 prio2buffer [ 8 ] ; t#__u32 buffer_size [ 8 ] ; t#__u32 total_size ; }
s#dcbnl_rtnl_ops struct dcbnl_rtnl_ops { int ( * ieee_getets ) ( s#net_device * , s#ieee_ets * ) ; int ( * ieee_setets ) ( s#net_device * , s#ieee_ets * ) ; int ( * ieee_getmaxrate ) ( s#net_device * , s#ieee_maxrate * ) ; int ( * ieee_setmaxrate ) ( s#net_device * , s#ieee_maxrate * ) ; int ( * ieee_getqcn ) ( s#net_device * , s#ieee_qcn * ) ; int ( * ieee_setqcn ) ( s#net_device * , s#ieee_qcn * ) ; int ( * ieee_getqcnstats ) ( s#net_device * , s#ieee_qcn_stats * ) ; int ( * ieee_getpfc ) ( s#net_device * , s#ieee_pfc * ) ; int ( * ieee_setpfc ) ( s#net_device * , s#ieee_pfc * ) ; int ( * ieee_getapp ) ( s#net_device * , s#dcb_app * ) ; int ( * ieee_setapp ) ( s#net_device * , s#dcb_app * ) ; int ( * ieee_delapp ) ( s#net_device * , s#dcb_app * ) ; int ( * ieee_peer_getets ) ( s#net_device * , s#ieee_ets * ) ; int ( * ieee_peer_getpfc ) ( s#net_device * , s#ieee_pfc * ) ; t#u8 ( * getstate ) ( s#net_device * ) ; t#u8 ( * setstate ) ( s#net_device * , t#u8 ) ; void ( * getpermhwaddr ) ( s#net_device * , t#u8 * ) ; void ( * setpgtccfgtx ) ( s#net_device * , int , t#u8 , t#u8 , t#u8 , t#u8 ) ; void ( * setpgbwgcfgtx ) ( s#net_device * , int , t#u8 ) ; void ( * setpgtccfgrx ) ( s#net_device * , int , t#u8 , t#u8 , t#u8 , t#u8 ) ; void ( * setpgbwgcfgrx ) ( s#net_device * , int , t#u8 ) ; void ( * getpgtccfgtx ) ( s#net_device * , int , t#u8 * , t#u8 * , t#u8 * , t#u8 * ) ; void ( * getpgbwgcfgtx ) ( s#net_device * , int , t#u8 * ) ; void ( * getpgtccfgrx ) ( s#net_device * , int , t#u8 * , t#u8 * , t#u8 * , t#u8 * ) ; void ( * getpgbwgcfgrx ) ( s#net_device * , int , t#u8 * ) ; void ( * setpfccfg ) ( s#net_device * , int , t#u8 ) ; void ( * getpfccfg ) ( s#net_device * , int , t#u8 * ) ; t#u8 ( * setall ) ( s#net_device * ) ; t#u8 ( * getcap ) ( s#net_device * , int , t#u8 * ) ; int ( * getnumtcs ) ( s#net_device * , int , t#u8 * ) ; int ( * setnumtcs ) ( s#net_device * , int , t#u8 ) ; t#u8 ( * getpfcstate ) ( s#net_device * ) ; void ( * setpfcstate ) ( s#net_device * , t#u8 ) ; void ( * getbcncfg ) ( s#net_device * , int , t#u32 * ) ; void ( * setbcncfg ) ( s#net_device * , int , t#u32 ) ; void ( * getbcnrp ) ( s#net_device * , int , t#u8 * ) ; void ( * setbcnrp ) ( s#net_device * , int , t#u8 ) ; int ( * setapp ) ( s#net_device * , t#u8 , t#u16 , t#u8 ) ; int ( * getapp ) ( s#net_device * , t#u8 , t#u16 ) ; t#u8 ( * getfeatcfg ) ( s#net_device * , int , t#u8 * ) ; t#u8 ( * setfeatcfg ) ( s#net_device * , int , t#u8 ) ; t#u8 ( * getdcbx ) ( s#net_device * ) ; t#u8 ( * setdcbx ) ( s#net_device * , t#u8 ) ; int ( * peer_getappinfo ) ( s#net_device * , s#dcb_peer_app_info * , t#u16 * ) ; int ( * peer_getapptable ) ( s#net_device * , s#dcb_app * ) ; int ( * cee_peer_getpg ) ( s#net_device * , s#cee_pg * ) ; int ( * cee_peer_getpfc ) ( s#net_device * , s#cee_pfc * ) ; int ( * dcbnl_getbuffer ) ( s#net_device * , s#dcbnl_buffer * ) ; int ( * dcbnl_setbuffer ) ( s#net_device * , s#dcbnl_buffer * ) ; int ( * dcbnl_setapptrust ) ( s#net_device * , t#u8 * , int ) ; int ( * dcbnl_getapptrust ) ( s#net_device * , t#u8 * , int * ) ; int ( * dcbnl_setrewr ) ( s#net_device * , s#dcb_app * ) ; int ( * dcbnl_delrewr ) ( s#net_device * , s#dcb_app * ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#ddebug_class_map struct ddebug_class_map { s#list_head link ; s#module * mod ; const char * mod_name ; const char * * class_names ; const int length ; const int base ; e#class_map_type map_type ; }
s#deferred_split struct deferred_split { t#spinlock_t split_queue_lock ; s#list_head split_queue ; unsigned long split_queue_len ; }
s#delayed_call struct delayed_call { void ( * fn ) ( void * ) ; void * arg ; }
s#delayed_work struct delayed_work { s#work_struct work ; s#timer_list timer ; s#workqueue_struct * wq ; int cpu ; }
s#dentry@1963d644 struct dentry { unsigned int d_flags ; t#seqcount_spinlock_t d_seq ; s#hlist_bl_node d_hash ; s#dentry * d_parent ; s#qstr d_name ; s#inode * d_inode ; unsigned char d_iname [ 40 ] ; const s#dentry_operations * d_op ; s#super_block * d_sb ; unsigned long d_time ; void * d_fsdata ; s#lockref d_lockref ; union { s#list_head d_lru ; t#wait_queue_head_t * d_wait ; } ; s#hlist_node d_sib ; s#hlist_head d_children ; union { s#hlist_node d_alias ; s#hlist_bl_node d_in_lookup_hash ; s#callback_head d_rcu ; } d_u ; }
s#dentry@d91cc150 struct dentry { UNKNOWN }
s#dentry_operations struct dentry_operations { int ( * d_revalidate ) ( s#dentry * , unsigned int ) ; int ( * d_weak_revalidate ) ( s#dentry * , unsigned int ) ; int ( * d_hash ) ( const s#dentry * , s#qstr * ) ; int ( * d_compare ) ( const s#dentry * , unsigned int , const char * , const s#qstr * ) ; int ( * d_delete ) ( const s#dentry * ) ; int ( * d_init ) ( s#dentry * ) ; void ( * d_release ) ( s#dentry * ) ; void ( * d_prune ) ( s#dentry * ) ; void ( * d_iput ) ( s#dentry * , s#inode * ) ; char * ( * d_dname ) ( s#dentry * , char * , int ) ; s#vfsmount * ( * d_automount ) ( s#path * ) ; int ( * d_manage ) ( const s#path * , t#bool ) ; s#dentry * ( * d_real ) ( s#dentry * , e#d_real_type ) ; }
s#desc_ptr struct desc_ptr { unsigned short size ; unsigned long address ; }
s#desc_struct struct desc_struct { t#u16 limit0 ; t#u16 base0 ; t#u16 base1 : 8 , type : 4 , s : 1 , dpl : 2 , p : 1 ; t#u16 limit1 : 4 , avl : 1 , l : 1 , d : 1 , g : 1 , base2 : 8 ; }
s#dev_archdata struct dev_archdata { }
s#dev_ifalias struct dev_ifalias { s#callback_head rcuhead ; char ifalias [ ] ; }
s#dev_iommu@6b28d4e3 struct dev_iommu { UNKNOWN }
s#dev_iommu@96cc726c struct dev_iommu { s#mutex lock ; s#iommu_fault_param * fault_param ; s#iommu_fwspec * fwspec ; s#iommu_device * iommu_dev ; void * priv ; t#u32 max_pasids ; t#u32 attach_deferred : 1 ; t#u32 pci_32bit_workaround : 1 ; t#u32 require_direct : 1 ; t#u32 shadow_on_flush : 1 ; }
s#dev_links_info struct dev_links_info { s#list_head suppliers ; s#list_head consumers ; s#list_head defer_sync ; e#dl_dev_state status ; }
s#dev_msi_info struct dev_msi_info { s#irq_domain * domain ; s#msi_device_data * data ; }
s#dev_pagemap@ad17fee0 struct dev_pagemap { UNKNOWN }
s#dev_pagemap@b8b78600 struct dev_pagemap { s#vmem_altmap altmap ; s#percpu_ref ref ; s#completion done ; e#memory_type type ; unsigned int flags ; unsigned long vmemmap_shift ; const s#dev_pagemap_ops * ops ; void * owner ; int nr_range ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; union { s#range range ; struct { struct { } __empty_ranges ; s#range ranges [ ] ; } ; } ; }
s#dev_pagemap_ops struct dev_pagemap_ops { void ( * page_free ) ( s#page * ) ; t#vm_fault_t ( * migrate_to_ram ) ( s#vm_fault * ) ; int ( * memory_failure ) ( s#dev_pagemap * , unsigned long , unsigned long , int ) ; }
s#dev_pin_info@5aaeca8c struct dev_pin_info { s#pinctrl * p ; s#pinctrl_state * default_state ; s#pinctrl_state * init_state ; s#pinctrl_state * sleep_state ; s#pinctrl_state * idle_state ; }
s#dev_pin_info@74d04f18 struct dev_pin_info { UNKNOWN }
s#dev_pm_domain struct dev_pm_domain { s#dev_pm_ops ops ; int ( * start ) ( s#device * ) ; void ( * detach ) ( s#device * , t#bool ) ; int ( * activate ) ( s#device * ) ; void ( * sync ) ( s#device * ) ; void ( * dismiss ) ( s#device * ) ; int ( * set_performance_state ) ( s#device * , unsigned int ) ; }
s#dev_pm_info struct dev_pm_info { t#pm_message_t power_state ; t#bool can_wakeup : 1 ; t#bool async_suspend : 1 ; t#bool in_dpm_list : 1 ; t#bool is_prepared : 1 ; t#bool is_suspended : 1 ; t#bool is_noirq_suspended : 1 ; t#bool is_late_suspended : 1 ; t#bool no_pm : 1 ; t#bool early_init : 1 ; t#bool direct_complete : 1 ; t#u32 driver_flags ; t#spinlock_t lock ; s#list_head entry ; s#completion completion ; s#wakeup_source * wakeup ; t#bool wakeup_path : 1 ; t#bool syscore : 1 ; t#bool no_pm_callbacks : 1 ; t#bool async_in_progress : 1 ; t#bool must_resume : 1 ; t#bool may_skip_resume : 1 ; s#hrtimer suspend_timer ; t#u64 timer_expires ; s#work_struct work ; t#wait_queue_head_t wait_queue ; s#wake_irq * wakeirq ; t#atomic_t usage_count ; t#atomic_t child_count ; unsigned int disable_depth : 3 ; t#bool idle_notification : 1 ; t#bool request_pending : 1 ; t#bool deferred_resume : 1 ; t#bool needs_force_resume : 1 ; t#bool runtime_auto : 1 ; t#bool ignore_children : 1 ; t#bool no_callbacks : 1 ; t#bool irq_safe : 1 ; t#bool use_autosuspend : 1 ; t#bool timer_autosuspends : 1 ; t#bool memalloc_noio : 1 ; unsigned int links_count ; e#rpm_request request ; e#rpm_status runtime_status ; e#rpm_status last_status ; int runtime_error ; int autosuspend_delay ; t#u64 last_busy ; t#u64 active_time ; t#u64 suspended_time ; t#u64 accounting_timestamp ; s#pm_subsys_data * subsys_data ; void ( * set_latency_tolerance ) ( s#device * , t#s32 ) ; s#dev_pm_qos * qos ; }
s#dev_pm_ops struct dev_pm_ops { int ( * prepare ) ( s#device * ) ; void ( * complete ) ( s#device * ) ; int ( * suspend ) ( s#device * ) ; int ( * resume ) ( s#device * ) ; int ( * freeze ) ( s#device * ) ; int ( * thaw ) ( s#device * ) ; int ( * poweroff ) ( s#device * ) ; int ( * restore ) ( s#device * ) ; int ( * suspend_late ) ( s#device * ) ; int ( * resume_early ) ( s#device * ) ; int ( * freeze_late ) ( s#device * ) ; int ( * thaw_early ) ( s#device * ) ; int ( * poweroff_late ) ( s#device * ) ; int ( * restore_early ) ( s#device * ) ; int ( * suspend_noirq ) ( s#device * ) ; int ( * resume_noirq ) ( s#device * ) ; int ( * freeze_noirq ) ( s#device * ) ; int ( * thaw_noirq ) ( s#device * ) ; int ( * poweroff_noirq ) ( s#device * ) ; int ( * restore_noirq ) ( s#device * ) ; int ( * runtime_suspend ) ( s#device * ) ; int ( * runtime_resume ) ( s#device * ) ; int ( * runtime_idle ) ( s#device * ) ; }
s#dev_pm_qos@4a00fc73 struct dev_pm_qos { UNKNOWN }
s#dev_pm_qos@5250564c struct dev_pm_qos { s#pm_qos_constraints resume_latency ; s#pm_qos_constraints latency_tolerance ; s#freq_constraints freq ; s#pm_qos_flags flags ; s#dev_pm_qos_request * resume_latency_req ; s#dev_pm_qos_request * latency_tolerance_req ; s#dev_pm_qos_request * flags_req ; }
s#dev_pm_qos_request struct dev_pm_qos_request { e#dev_pm_qos_req_type type ; union { s#plist_node pnode ; s#pm_qos_flags_request flr ; s#freq_qos_request freq ; } data ; s#device * dev ; }
s#device@92fea4ff struct device { UNKNOWN }
s#device@d0b2836c struct device { s#kobject kobj ; s#device * parent ; s#device_private * p ; const char * init_name ; const s#device_type * type ; const s#bus_type * bus ; s#device_driver * driver ; void * platform_data ; void * driver_data ; s#mutex mutex ; s#dev_links_info links ; s#dev_pm_info power ; s#dev_pm_domain * pm_domain ; s#dev_pin_info * pins ; s#dev_msi_info msi ; const s#dma_map_ops * dma_ops ; t#u64 * dma_mask ; t#u64 coherent_dma_mask ; t#u64 bus_dma_limit ; const s#bus_dma_region * dma_range_map ; s#device_dma_parameters * dma_parms ; s#list_head dma_pools ; s#cma * cma_area ; s#io_tlb_mem * dma_io_tlb_mem ; s#list_head dma_io_tlb_pools ; t#spinlock_t dma_io_tlb_lock ; t#bool dma_uses_io_tlb ; s#dev_archdata archdata ; s#device_node * of_node ; s#fwnode_handle * fwnode ; int numa_node ; t#dev_t devt ; t#u32 id ; t#spinlock_t devres_lock ; s#list_head devres_head ; const s#class * class ; const s#attribute_group * * groups ; void ( * release ) ( s#device * ) ; s#iommu_group * iommu_group ; s#dev_iommu * iommu ; s#device_physical_location * physical_location ; e#device_removable removable ; t#bool offline_disabled : 1 ; t#bool offline : 1 ; t#bool of_node_reused : 1 ; t#bool state_synced : 1 ; t#bool can_match : 1 ; t#bool dma_skip_sync : 1 ; t#bool dma_iommu : 1 ; unsigned long uek_reserved1 ; }
s#device_attribute struct device_attribute { s#attribute attr ; t#ssize_t ( * show ) ( s#device * , s#device_attribute * , char * ) ; t#ssize_t ( * store ) ( s#device * , s#device_attribute * , const char * , t#size_t ) ; }
s#device_dma_parameters struct device_dma_parameters { unsigned int max_segment_size ; unsigned int min_align_mask ; unsigned long segment_boundary_mask ; }
s#device_driver struct device_driver { const char * name ; const s#bus_type * bus ; s#module * owner ; const char * mod_name ; t#bool suppress_bind_attrs ; e#probe_type probe_type ; const s#of_device_id * of_match_table ; const s#acpi_device_id * acpi_match_table ; int ( * probe ) ( s#device * ) ; void ( * sync_state ) ( s#device * ) ; int ( * remove ) ( s#device * ) ; void ( * shutdown ) ( s#device * ) ; int ( * suspend ) ( s#device * , t#pm_message_t ) ; int ( * resume ) ( s#device * ) ; const s#attribute_group * * groups ; const s#attribute_group * * dev_groups ; const s#dev_pm_ops * pm ; void ( * coredump ) ( s#device * ) ; s#driver_private * p ; }
s#device_link struct device_link { s#device * supplier ; s#list_head s_node ; s#device * consumer ; s#list_head c_node ; s#device link_dev ; e#device_link_state status ; t#u32 flags ; t#refcount_t rpm_active ; s#kref kref ; s#work_struct rm_work ; t#bool supplier_preactivated ; }
s#device_node@26a212ba struct device_node { UNKNOWN }
s#device_node@346471e3 struct device_node { const char * name ; t#phandle t#phandle ; const char * full_name ; s#fwnode_handle fwnode ; s#property * properties ; s#property * deadprops ; s#device_node * parent ; s#device_node * child ; s#device_node * sibling ; unsigned long _flags ; void * data ; }
s#device_physical_location struct device_physical_location { e#device_physical_location_panel panel ; e#device_physical_location_vertical_position vertical_position ; e#device_physical_location_horizontal_position horizontal_position ; t#bool dock ; t#bool lid ; }
s#device_private@38a41b15 struct device_private { s#klist klist_children ; s#klist_node knode_parent ; s#klist_node knode_driver ; s#klist_node knode_bus ; s#klist_node knode_class ; s#list_head deferred_probe ; const s#device_driver * async_driver ; char * deferred_probe_reason ; s#device * device ; t#u8 dead : 1 ; }
s#device_private@95088762 struct device_private { UNKNOWN }
s#device_type struct device_type { const char * name ; const s#attribute_group * * groups ; int ( * uevent ) ( const s#device * , s#kobj_uevent_env * ) ; char * ( * devnode ) ( const s#device * , t#umode_t * , t#kuid_t * , t#kgid_t * ) ; void ( * release ) ( s#device * ) ; const s#dev_pm_ops * pm ; }
s#devlink@dc375cbf struct devlink { t#u32 index ; s#xarray ports ; s#list_head rate_list ; s#list_head sb_list ; s#list_head dpipe_table_list ; s#list_head resource_list ; s#xarray params ; s#list_head region_list ; s#list_head reporter_list ; s#devlink_dpipe_headers * dpipe_headers ; s#list_head trap_list ; s#list_head trap_group_list ; s#list_head trap_policer_list ; s#list_head linecard_list ; const s#devlink_ops * ops ; s#xarray snapshot_ids ; s#devlink_dev_stats stats ; s#device * dev ; t#possible_net_t _net ; s#mutex lock ; s#lock_class_key lock_key ; t#u8 reload_failed : 1 ; t#refcount_t refcount ; s#rcu_work rwork ; s#devlink_rel * rel ; s#xarray nested_rels ; char priv [ ] __attribute__ ( ( __aligned__ ( 32 ) ) ) ; }
s#devlink@ea84cedc struct devlink { UNKNOWN }
s#devlink_dev_stats struct devlink_dev_stats { t#u32 reload_stats [ ( E#__DEVLINK_RELOAD_LIMIT_MAX * E#__DEVLINK_RELOAD_ACTION_MAX ) ] ; t#u32 remote_reload_stats [ ( E#__DEVLINK_RELOAD_LIMIT_MAX * E#__DEVLINK_RELOAD_ACTION_MAX ) ] ; }
s#devlink_dpipe_field struct devlink_dpipe_field { const char * name ; unsigned int id ; unsigned int bitwidth ; e#devlink_dpipe_field_mapping_type mapping_type ; }
s#devlink_dpipe_header struct devlink_dpipe_header { const char * name ; unsigned int id ; s#devlink_dpipe_field * fields ; unsigned int fields_count ; t#bool global ; }
s#devlink_dpipe_headers struct devlink_dpipe_headers { s#devlink_dpipe_header * * headers ; unsigned int headers_count ; }
s#devlink_flash_update_params struct devlink_flash_update_params { const s#firmware * fw ; const char * component ; t#u32 overwrite_mask ; }
s#devlink_info_req struct devlink_info_req { UNKNOWN }
s#devlink_linecard struct devlink_linecard { UNKNOWN }
s#devlink_ops struct devlink_ops { t#u32 supported_flash_update_params ; unsigned long reload_actions ; unsigned long reload_limits ; int ( * reload_down ) ( s#devlink * , t#bool , e#devlink_reload_action , e#devlink_reload_limit , s#netlink_ext_ack * ) ; int ( * reload_up ) ( s#devlink * , e#devlink_reload_action , e#devlink_reload_limit , t#u32 * , s#netlink_ext_ack * ) ; int ( * sb_pool_get ) ( s#devlink * , unsigned int , t#u16 , s#devlink_sb_pool_info * ) ; int ( * sb_pool_set ) ( s#devlink * , unsigned int , t#u16 , t#u32 , e#devlink_sb_threshold_type , s#netlink_ext_ack * ) ; int ( * sb_port_pool_get ) ( s#devlink_port * , unsigned int , t#u16 , t#u32 * ) ; int ( * sb_port_pool_set ) ( s#devlink_port * , unsigned int , t#u16 , t#u32 , s#netlink_ext_ack * ) ; int ( * sb_tc_pool_bind_get ) ( s#devlink_port * , unsigned int , t#u16 , e#devlink_sb_pool_type , t#u16 * , t#u32 * ) ; int ( * sb_tc_pool_bind_set ) ( s#devlink_port * , unsigned int , t#u16 , e#devlink_sb_pool_type , t#u16 , t#u32 , s#netlink_ext_ack * ) ; int ( * sb_occ_snapshot ) ( s#devlink * , unsigned int ) ; int ( * sb_occ_max_clear ) ( s#devlink * , unsigned int ) ; int ( * sb_occ_port_pool_get ) ( s#devlink_port * , unsigned int , t#u16 , t#u32 * , t#u32 * ) ; int ( * sb_occ_tc_port_bind_get ) ( s#devlink_port * , unsigned int , t#u16 , e#devlink_sb_pool_type , t#u32 * , t#u32 * ) ; int ( * eswitch_mode_get ) ( s#devlink * , t#u16 * ) ; int ( * eswitch_mode_set ) ( s#devlink * , t#u16 , s#netlink_ext_ack * ) ; int ( * eswitch_inline_mode_get ) ( s#devlink * , t#u8 * ) ; int ( * eswitch_inline_mode_set ) ( s#devlink * , t#u8 , s#netlink_ext_ack * ) ; int ( * eswitch_encap_mode_get ) ( s#devlink * , e#devlink_eswitch_encap_mode * ) ; int ( * eswitch_encap_mode_set ) ( s#devlink * , e#devlink_eswitch_encap_mode , s#netlink_ext_ack * ) ; int ( * info_get ) ( s#devlink * , s#devlink_info_req * , s#netlink_ext_ack * ) ; int ( * flash_update ) ( s#devlink * , s#devlink_flash_update_params * , s#netlink_ext_ack * ) ; int ( * trap_init ) ( s#devlink * , const s#devlink_trap * , void * ) ; void ( * trap_fini ) ( s#devlink * , const s#devlink_trap * , void * ) ; int ( * trap_action_set ) ( s#devlink * , const s#devlink_trap * , e#devlink_trap_action , s#netlink_ext_ack * ) ; int ( * trap_group_init ) ( s#devlink * , const s#devlink_trap_group * ) ; int ( * trap_group_set ) ( s#devlink * , const s#devlink_trap_group * , const s#devlink_trap_policer * , s#netlink_ext_ack * ) ; int ( * trap_group_action_set ) ( s#devlink * , const s#devlink_trap_group * , e#devlink_trap_action , s#netlink_ext_ack * ) ; int ( * trap_drop_counter_get ) ( s#devlink * , const s#devlink_trap * , t#u64 * ) ; int ( * trap_policer_init ) ( s#devlink * , const s#devlink_trap_policer * ) ; void ( * trap_policer_fini ) ( s#devlink * , const s#devlink_trap_policer * ) ; int ( * trap_policer_set ) ( s#devlink * , const s#devlink_trap_policer * , t#u64 , t#u64 , s#netlink_ext_ack * ) ; int ( * trap_policer_counter_get ) ( s#devlink * , const s#devlink_trap_policer * , t#u64 * ) ; int ( * port_new ) ( s#devlink * , const s#devlink_port_new_attrs * , s#netlink_ext_ack * , s#devlink_port * * ) ; int ( * rate_leaf_tx_share_set ) ( s#devlink_rate * , void * , t#u64 , s#netlink_ext_ack * ) ; int ( * rate_leaf_tx_max_set ) ( s#devlink_rate * , void * , t#u64 , s#netlink_ext_ack * ) ; int ( * rate_leaf_tx_priority_set ) ( s#devlink_rate * , void * , t#u32 , s#netlink_ext_ack * ) ; int ( * rate_leaf_tx_weight_set ) ( s#devlink_rate * , void * , t#u32 , s#netlink_ext_ack * ) ; int ( * rate_node_tx_share_set ) ( s#devlink_rate * , void * , t#u64 , s#netlink_ext_ack * ) ; int ( * rate_node_tx_max_set ) ( s#devlink_rate * , void * , t#u64 , s#netlink_ext_ack * ) ; int ( * rate_node_tx_priority_set ) ( s#devlink_rate * , void * , t#u32 , s#netlink_ext_ack * ) ; int ( * rate_node_tx_weight_set ) ( s#devlink_rate * , void * , t#u32 , s#netlink_ext_ack * ) ; int ( * rate_node_new ) ( s#devlink_rate * , void * * , s#netlink_ext_ack * ) ; int ( * rate_node_del ) ( s#devlink_rate * , void * , s#netlink_ext_ack * ) ; int ( * rate_leaf_parent_set ) ( s#devlink_rate * , s#devlink_rate * , void * , void * , s#netlink_ext_ack * ) ; int ( * rate_node_parent_set ) ( s#devlink_rate * , s#devlink_rate * , void * , void * , s#netlink_ext_ack * ) ; t#bool ( * selftest_check ) ( s#devlink * , unsigned int , s#netlink_ext_ack * ) ; e#devlink_selftest_status ( * selftest_run ) ( s#devlink * , unsigned int , s#netlink_ext_ack * ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#devlink_param_gset_ctx struct devlink_param_gset_ctx { u#devlink_param_value val ; e#devlink_param_cmode cmode ; }
s#devlink_port@6903067d struct devlink_port { s#list_head list ; s#list_head region_list ; s#devlink * devlink ; const s#devlink_port_ops * ops ; unsigned int index ; t#spinlock_t type_lock ; e#devlink_port_type type ; e#devlink_port_type desired_type ; union { struct { s#net_device * netdev ; int ifindex ; char ifname [ 16 ] ; } type_eth ; struct { s#ib_device * ibdev ; } type_ib ; } ; s#devlink_port_attrs attrs ; t#u8 attrs_set : 1 , switch_port : 1 , registered : 1 , initialized : 1 ; s#delayed_work type_warn_dw ; s#list_head reporter_list ; s#devlink_rate * devlink_rate ; s#devlink_linecard * linecard ; t#u32 rel_index ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#devlink_port@90deb245 struct devlink_port { UNKNOWN }
s#devlink_port_attrs struct devlink_port_attrs { t#u8 split : 1 , splittable : 1 ; t#u32 lanes ; e#devlink_port_flavour flavour ; s#netdev_phys_item_id switch_id ; union { s#devlink_port_phys_attrs phys ; s#devlink_port_pci_pf_attrs pci_pf ; s#devlink_port_pci_vf_attrs pci_vf ; s#devlink_port_pci_sf_attrs pci_sf ; } ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#devlink_port_new_attrs struct devlink_port_new_attrs { e#devlink_port_flavour flavour ; unsigned int port_index ; t#u32 controller ; t#u32 sfnum ; t#u16 pfnum ; t#u8 port_index_valid : 1 , controller_valid : 1 , sfnum_valid : 1 ; }
s#devlink_port_ops struct devlink_port_ops { int ( * port_split ) ( s#devlink * , s#devlink_port * , unsigned int , s#netlink_ext_ack * ) ; int ( * port_unsplit ) ( s#devlink * , s#devlink_port * , s#netlink_ext_ack * ) ; int ( * port_type_set ) ( s#devlink_port * , e#devlink_port_type ) ; int ( * port_del ) ( s#devlink * , s#devlink_port * , s#netlink_ext_ack * ) ; int ( * port_fn_hw_addr_get ) ( s#devlink_port * , t#u8 * , int * , s#netlink_ext_ack * ) ; int ( * port_fn_hw_addr_set ) ( s#devlink_port * , const t#u8 * , int , s#netlink_ext_ack * ) ; int ( * port_fn_roce_get ) ( s#devlink_port * , t#bool * , s#netlink_ext_ack * ) ; int ( * port_fn_roce_set ) ( s#devlink_port * , t#bool , s#netlink_ext_ack * ) ; int ( * port_fn_migratable_get ) ( s#devlink_port * , t#bool * , s#netlink_ext_ack * ) ; int ( * port_fn_migratable_set ) ( s#devlink_port * , t#bool , s#netlink_ext_ack * ) ; int ( * port_fn_state_get ) ( s#devlink_port * , e#devlink_port_fn_state * , e#devlink_port_fn_opstate * , s#netlink_ext_ack * ) ; int ( * port_fn_state_set ) ( s#devlink_port * , e#devlink_port_fn_state , s#netlink_ext_ack * ) ; int ( * port_fn_ipsec_crypto_get ) ( s#devlink_port * , t#bool * , s#netlink_ext_ack * ) ; int ( * port_fn_ipsec_crypto_set ) ( s#devlink_port * , t#bool , s#netlink_ext_ack * ) ; int ( * port_fn_ipsec_packet_get ) ( s#devlink_port * , t#bool * , s#netlink_ext_ack * ) ; int ( * port_fn_ipsec_packet_set ) ( s#devlink_port * , t#bool , s#netlink_ext_ack * ) ; int ( * port_fn_max_io_eqs_get ) ( s#devlink_port * , t#u32 * , s#netlink_ext_ack * ) ; int ( * port_fn_max_io_eqs_set ) ( s#devlink_port * , t#u32 , s#netlink_ext_ack * ) ; }
s#devlink_port_pci_pf_attrs struct devlink_port_pci_pf_attrs { t#u32 controller ; t#u16 pf ; t#u8 external : 1 ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#devlink_port_pci_sf_attrs struct devlink_port_pci_sf_attrs { t#u32 controller ; t#u32 sf ; t#u16 pf ; t#u8 external : 1 ; }
s#devlink_port_pci_vf_attrs struct devlink_port_pci_vf_attrs { t#u32 controller ; t#u16 pf ; t#u16 vf ; t#u8 external : 1 ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#devlink_port_phys_attrs struct devlink_port_phys_attrs { t#u32 port_number ; t#u32 split_subport_number ; }
s#devlink_rate struct devlink_rate { s#list_head list ; e#devlink_rate_type type ; s#devlink * devlink ; void * priv ; t#u64 tx_share ; t#u64 tx_max ; s#devlink_rate * parent ; union { s#devlink_port * devlink_port ; struct { char * name ; t#refcount_t refcnt ; } ; } ; t#u32 tx_priority ; t#u32 tx_weight ; }
s#devlink_rel struct devlink_rel { UNKNOWN }
s#devlink_sb_pool_info struct devlink_sb_pool_info { e#devlink_sb_pool_type pool_type ; t#u32 size ; e#devlink_sb_threshold_type threshold_type ; t#u32 cell_size ; }
s#devlink_trap struct devlink_trap { e#devlink_trap_type type ; e#devlink_trap_action init_action ; t#bool generic ; t#u16 id ; const char * name ; t#u16 init_group_id ; t#u32 metadata_cap ; }
s#devlink_trap_group struct devlink_trap_group { const char * name ; t#u16 id ; t#bool generic ; t#u32 init_policer_id ; }
s#devlink_trap_policer struct devlink_trap_policer { t#u32 id ; t#u64 init_rate ; t#u64 init_burst ; t#u64 max_rate ; t#u64 min_rate ; t#u64 max_burst ; t#u64 min_burst ; }
s#dim struct dim { t#u8 state ; s#dim_stats prev_stats ; s#dim_sample start_sample ; s#dim_sample measuring_sample ; s#work_struct work ; void * priv ; t#u8 profile_ix ; t#u8 mode ; t#u8 tune_state ; t#u8 steps_right ; t#u8 steps_left ; t#u8 tired ; }
s#dim_cq_moder struct dim_cq_moder { t#u16 usec ; t#u16 pkts ; t#u16 comps ; t#u8 cq_period_mode ; s#callback_head rcu ; }
s#dim_irq_moder@17f95173 struct dim_irq_moder { t#u8 profile_flags ; t#u8 coal_flags ; t#u8 dim_rx_mode ; t#u8 dim_tx_mode ; s#dim_cq_moder * rx_profile ; s#dim_cq_moder * tx_profile ; void ( * rx_dim_work ) ( s#work_struct * ) ; void ( * tx_dim_work ) ( s#work_struct * ) ; }
s#dim_irq_moder@73772ab2 struct dim_irq_moder { UNKNOWN }
s#dim_sample struct dim_sample { t#ktime_t time ; t#u32 pkt_ctr ; t#u32 byte_ctr ; t#u16 event_ctr ; t#u32 comp_ctr ; }
s#dim_stats struct dim_stats { int ppms ; int bpms ; int epms ; int cpms ; int cpe_ratio ; }
s#dir_context struct dir_context { t#filldir_t actor ; t#loff_t pos ; }
s#disk_events struct disk_events { UNKNOWN }
s#disk_stats@4b99ea9b struct disk_stats { t#u64 nsecs [ E#NR_STAT_GROUPS ] ; unsigned long sectors [ E#NR_STAT_GROUPS ] ; unsigned long ios [ E#NR_STAT_GROUPS ] ; unsigned long merges [ E#NR_STAT_GROUPS ] ; unsigned long io_ticks ; t#local_t in_flight [ 2 ] ; }
s#disk_stats@fa55c981 struct disk_stats { UNKNOWN }
s#dl_bw struct dl_bw { t#raw_spinlock_t lock ; t#u64 bw ; t#u64 total_bw ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#dl_rq struct dl_rq { s#rb_root_cached root ; unsigned int dl_nr_running ; struct { t#u64 curr ; t#u64 next ; } earliest_dl ; t#bool overloaded ; s#rb_root_cached pushable_dl_tasks_root ; t#u64 running_bw ; t#u64 this_bw ; t#u64 extra_bw ; t#u64 max_bw ; t#u64 bw_ratio ; }
s#dm_hw_stat_delta struct dm_hw_stat_delta { UNKNOWN }
s#dma_map_ops@299c8cb1 struct dma_map_ops { void * ( * alloc ) ( s#device * , t#size_t , t#dma_addr_t * , t#gfp_t , unsigned long ) ; void ( * free ) ( s#device * , t#size_t , void * , t#dma_addr_t , unsigned long ) ; s#page * ( * alloc_pages_op ) ( s#device * , t#size_t , t#dma_addr_t * , e#dma_data_direction , t#gfp_t ) ; void ( * free_pages ) ( s#device * , t#size_t , s#page * , t#dma_addr_t , e#dma_data_direction ) ; int ( * mmap ) ( s#device * , s#vm_area_struct * , void * , t#dma_addr_t , t#size_t , unsigned long ) ; int ( * get_sgtable ) ( s#device * , s#sg_table * , void * , t#dma_addr_t , t#size_t , unsigned long ) ; t#dma_addr_t ( * map_page ) ( s#device * , s#page * , unsigned long , t#size_t , e#dma_data_direction , unsigned long ) ; void ( * unmap_page ) ( s#device * , t#dma_addr_t , t#size_t , e#dma_data_direction , unsigned long ) ; int ( * map_sg ) ( s#device * , s#scatterlist * , int , e#dma_data_direction , unsigned long ) ; void ( * unmap_sg ) ( s#device * , s#scatterlist * , int , e#dma_data_direction , unsigned long ) ; t#dma_addr_t ( * map_resource ) ( s#device * , t#phys_addr_t , t#size_t , e#dma_data_direction , unsigned long ) ; void ( * unmap_resource ) ( s#device * , t#dma_addr_t , t#size_t , e#dma_data_direction , unsigned long ) ; void ( * sync_single_for_cpu ) ( s#device * , t#dma_addr_t , t#size_t , e#dma_data_direction ) ; void ( * sync_single_for_device ) ( s#device * , t#dma_addr_t , t#size_t , e#dma_data_direction ) ; void ( * sync_sg_for_cpu ) ( s#device * , s#scatterlist * , int , e#dma_data_direction ) ; void ( * sync_sg_for_device ) ( s#device * , s#scatterlist * , int , e#dma_data_direction ) ; void ( * cache_sync ) ( s#device * , void * , t#size_t , e#dma_data_direction ) ; int ( * dma_supported ) ( s#device * , t#u64 ) ; t#u64 ( * get_required_mask ) ( s#device * ) ; t#size_t ( * max_mapping_size ) ( s#device * ) ; t#size_t ( * opt_mapping_size ) ( void ) ; unsigned long ( * get_merge_boundary ) ( s#device * ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#dma_map_ops@b53ba484 struct dma_map_ops { UNKNOWN }
s#dpll_pin@2b16be81 struct dpll_pin { UNKNOWN }
s#dpll_pin@9936e248 struct dpll_pin { t#u32 id ; t#u32 pin_idx ; t#u64 clock_id ; s#module * module ; s#xarray dpll_refs ; s#xarray parent_refs ; s#dpll_pin_properties prop ; t#refcount_t refcount ; s#callback_head rcu ; }
s#dpll_pin_frequency struct dpll_pin_frequency { t#u64 min ; t#u64 max ; }
s#dpll_pin_phase_adjust_range struct dpll_pin_phase_adjust_range { t#s32 min ; t#s32 max ; }
s#dpll_pin_properties struct dpll_pin_properties { const char * board_label ; const char * panel_label ; const char * package_label ; e#dpll_pin_type type ; unsigned long capabilities ; t#u32 freq_supported_num ; s#dpll_pin_frequency * freq_supported ; s#dpll_pin_phase_adjust_range phase_range ; }
s#dql struct dql { unsigned int num_queued ; unsigned int adj_limit ; unsigned int last_obj_cnt ; unsigned short stall_thrs ; unsigned long history_head ; unsigned long history [ 4 ] ; unsigned int limit __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; unsigned int num_completed ; unsigned int prev_ovlimit ; unsigned int prev_num_queued ; unsigned int prev_last_obj_cnt ; unsigned int lowest_slack ; unsigned long slack_start_time ; unsigned int max_limit ; unsigned int min_limit ; unsigned int slack_hold_time ; unsigned short stall_max ; unsigned long last_reap ; unsigned long stall_cnt ; }
s#dquot struct dquot { s#hlist_node dq_hash ; s#list_head dq_inuse ; s#list_head dq_free ; s#list_head dq_dirty ; s#mutex dq_lock ; t#spinlock_t dq_dqb_lock ; t#atomic_t dq_count ; s#super_block * dq_sb ; s#kqid dq_id ; t#loff_t dq_off ; unsigned long dq_flags ; s#mem_dqblk dq_dqb ; }
s#dquot_operations struct dquot_operations { int ( * write_dquot ) ( s#dquot * ) ; s#dquot * ( * alloc_dquot ) ( s#super_block * , int ) ; void ( * destroy_dquot ) ( s#dquot * ) ; int ( * acquire_dquot ) ( s#dquot * ) ; int ( * release_dquot ) ( s#dquot * ) ; int ( * mark_dirty ) ( s#dquot * ) ; int ( * write_info ) ( s#super_block * , int ) ; t#qsize_t * ( * get_reserved_space ) ( s#inode * ) ; int ( * get_projid ) ( s#inode * , t#kprojid_t * ) ; int ( * get_inode_usage ) ( s#inode * , t#qsize_t * ) ; int ( * get_next_id ) ( s#super_block * , s#kqid * ) ; }
s#driver_private@408764e2 struct driver_private { s#kobject kobj ; s#klist klist_devices ; s#klist_node knode_bus ; s#module_kobject * mkobj ; s#device_driver * driver ; }
s#driver_private@80bd9a0c struct driver_private { UNKNOWN }
s#dsa_8021q_context struct dsa_8021q_context { UNKNOWN }
s#dsa_bridge struct dsa_bridge { s#net_device * dev ; unsigned int num ; t#bool tx_fwd_offload ; t#refcount_t refcount ; }
s#dsa_chip_data struct dsa_chip_data { s#device * host_dev ; int sw_addr ; s#device * netdev [ 12 ] ; int eeprom_len ; s#device_node * of_node ; char * port_names [ 12 ] ; s#device_node * port_dn [ 12 ] ; t#s8 rtable [ 4 ] ; }
s#dsa_db struct dsa_db { e#dsa_db_type type ; union { const s#dsa_port * dp ; s#dsa_lag lag ; s#dsa_bridge bridge ; } ; }
s#dsa_device_ops struct dsa_device_ops { s#sk_buff * ( * xmit ) ( s#sk_buff * , s#net_device * ) ; s#sk_buff * ( * rcv ) ( s#sk_buff * , s#net_device * ) ; void ( * flow_dissect ) ( const s#sk_buff * , t#__be16 * , int * ) ; int ( * connect ) ( s#dsa_switch * ) ; void ( * disconnect ) ( s#dsa_switch * ) ; unsigned int needed_headroom ; unsigned int needed_tailroom ; const char * name ; e#dsa_tag_protocol proto ; t#bool promisc_on_conduit ; }
s#dsa_lag struct dsa_lag { s#net_device * dev ; unsigned int id ; s#mutex fdb_lock ; s#list_head fdbs ; t#refcount_t refcount ; }
s#dsa_mall_mirror_tc_entry struct dsa_mall_mirror_tc_entry { t#u8 to_local_port ; t#bool ingress ; }
s#dsa_mall_policer_tc_entry struct dsa_mall_policer_tc_entry { t#u32 burst ; t#u64 rate_bytes_per_sec ; }
s#dsa_platform_data struct dsa_platform_data { s#device * netdev ; s#net_device * of_netdev ; int nr_chips ; s#dsa_chip_data * chip ; }
s#dsa_port@258bc0e4 struct dsa_port { UNKNOWN }
s#dsa_port@a8251a6a struct dsa_port { union { s#net_device * conduit ; s#net_device * user ; } ; const s#dsa_device_ops * tag_ops ; s#dsa_switch_tree * dst ; s#sk_buff * ( * rcv ) ( s#sk_buff * , s#net_device * ) ; s#dsa_switch * ds ; unsigned int index ; enum { DSA_PORT_TYPE_UNUSED = 0 , DSA_PORT_TYPE_CPU , DSA_PORT_TYPE_DSA , DSA_PORT_TYPE_USER , } type ; const char * name ; s#dsa_port * cpu_dp ; t#u8 mac [ 6 ] ; t#u8 stp_state ; t#u8 vlan_filtering : 1 ; t#u8 learning : 1 ; t#u8 lag_tx_enabled : 1 ; t#u8 conduit_admin_up : 1 ; t#u8 conduit_oper_up : 1 ; t#u8 cpu_port_in_lag : 1 ; t#u8 setup : 1 ; s#device_node * dn ; unsigned int ageing_time ; s#dsa_bridge * bridge ; s#devlink_port devlink_port ; s#phylink * pl ; s#phylink_config pl_config ; s#dsa_lag * lag ; s#net_device * hsr_dev ; s#list_head list ; const s#ethtool_ops * orig_ethtool_ops ; s#mutex addr_lists_lock ; s#list_head fdbs ; s#list_head mdbs ; s#mutex vlans_lock ; union { s#list_head vlans ; s#list_head user_vlans ; } ; }
s#dsa_switch struct dsa_switch { s#device * dev ; s#dsa_switch_tree * dst ; unsigned int index ; t#u32 setup : 1 ; t#u32 vlan_filtering_is_global : 1 ; t#u32 needs_standalone_vlan_filtering : 1 ; t#u32 configure_vlan_while_not_filtering : 1 ; t#u32 untag_bridge_pvid : 1 ; t#u32 untag_vlan_aware_bridge_pvid : 1 ; t#u32 assisted_learning_on_cpu_port : 1 ; t#u32 vlan_filtering : 1 ; t#u32 mtu_enforcement_ingress : 1 ; t#u32 fdb_isolation : 1 ; t#u32 dscp_prio_mapping_is_global : 1 ; s#notifier_block nb ; void * priv ; void * tagger_data ; s#dsa_chip_data * cd ; const s#dsa_switch_ops * ops ; const s#phylink_mac_ops * phylink_mac_ops ; t#u32 phys_mii_mask ; s#mii_bus * user_mii_bus ; unsigned int ageing_time_min ; unsigned int ageing_time_max ; s#dsa_8021q_context * tag_8021q_ctx ; s#devlink * devlink ; unsigned int num_tx_queues ; unsigned int num_lag_ids ; unsigned int max_num_bridges ; unsigned int num_ports ; }
s#dsa_switch_ops struct dsa_switch_ops { e#dsa_tag_protocol ( * get_tag_protocol ) ( s#dsa_switch * , int , e#dsa_tag_protocol ) ; int ( * change_tag_protocol ) ( s#dsa_switch * , e#dsa_tag_protocol ) ; int ( * connect_tag_protocol ) ( s#dsa_switch * , e#dsa_tag_protocol ) ; int ( * port_change_conduit ) ( s#dsa_switch * , int , s#net_device * , s#netlink_ext_ack * ) ; int ( * setup ) ( s#dsa_switch * ) ; void ( * teardown ) ( s#dsa_switch * ) ; int ( * port_setup ) ( s#dsa_switch * , int ) ; void ( * port_teardown ) ( s#dsa_switch * , int ) ; t#u32 ( * get_phy_flags ) ( s#dsa_switch * , int ) ; int ( * phy_read ) ( s#dsa_switch * , int , int ) ; int ( * phy_write ) ( s#dsa_switch * , int , int , t#u16 ) ; void ( * phylink_get_caps ) ( s#dsa_switch * , int , s#phylink_config * ) ; s#phylink_pcs * ( * phylink_mac_select_pcs ) ( s#dsa_switch * , int , t#phy_interface_t ) ; void ( * phylink_mac_config ) ( s#dsa_switch * , int , unsigned int , const s#phylink_link_state * ) ; void ( * phylink_mac_link_down ) ( s#dsa_switch * , int , unsigned int , t#phy_interface_t ) ; void ( * phylink_mac_link_up ) ( s#dsa_switch * , int , unsigned int , t#phy_interface_t , s#phy_device * , int , int , t#bool , t#bool ) ; void ( * phylink_fixed_state ) ( s#dsa_switch * , int , s#phylink_link_state * ) ; void ( * get_strings ) ( s#dsa_switch * , int , t#u32 , t#uint8_t * ) ; void ( * get_ethtool_stats ) ( s#dsa_switch * , int , t#uint64_t * ) ; int ( * get_sset_count ) ( s#dsa_switch * , int , int ) ; void ( * get_ethtool_phy_stats ) ( s#dsa_switch * , int , t#uint64_t * ) ; void ( * get_eth_phy_stats ) ( s#dsa_switch * , int , s#ethtool_eth_phy_stats * ) ; void ( * get_eth_mac_stats ) ( s#dsa_switch * , int , s#ethtool_eth_mac_stats * ) ; void ( * get_eth_ctrl_stats ) ( s#dsa_switch * , int , s#ethtool_eth_ctrl_stats * ) ; void ( * get_rmon_stats ) ( s#dsa_switch * , int , s#ethtool_rmon_stats * , const s#ethtool_rmon_hist_range * * ) ; void ( * get_stats64 ) ( s#dsa_switch * , int , s#rtnl_link_stats64 * ) ; void ( * get_pause_stats ) ( s#dsa_switch * , int , s#ethtool_pause_stats * ) ; void ( * self_test ) ( s#dsa_switch * , int , s#ethtool_test * , t#u64 * ) ; void ( * get_wol ) ( s#dsa_switch * , int , s#ethtool_wolinfo * ) ; int ( * set_wol ) ( s#dsa_switch * , int , s#ethtool_wolinfo * ) ; int ( * get_ts_info ) ( s#dsa_switch * , int , s#kernel_ethtool_ts_info * ) ; int ( * get_mm ) ( s#dsa_switch * , int , s#ethtool_mm_state * ) ; int ( * set_mm ) ( s#dsa_switch * , int , s#ethtool_mm_cfg * , s#netlink_ext_ack * ) ; void ( * get_mm_stats ) ( s#dsa_switch * , int , s#ethtool_mm_stats * ) ; int ( * port_get_default_prio ) ( s#dsa_switch * , int ) ; int ( * port_set_default_prio ) ( s#dsa_switch * , int , t#u8 ) ; int ( * port_get_dscp_prio ) ( s#dsa_switch * , int , t#u8 ) ; int ( * port_add_dscp_prio ) ( s#dsa_switch * , int , t#u8 , t#u8 ) ; int ( * port_del_dscp_prio ) ( s#dsa_switch * , int , t#u8 , t#u8 ) ; int ( * port_set_apptrust ) ( s#dsa_switch * , int , const t#u8 * , int ) ; int ( * port_get_apptrust ) ( s#dsa_switch * , int , t#u8 * , int * ) ; int ( * suspend ) ( s#dsa_switch * ) ; int ( * resume ) ( s#dsa_switch * ) ; int ( * port_enable ) ( s#dsa_switch * , int , s#phy_device * ) ; void ( * port_disable ) ( s#dsa_switch * , int ) ; int ( * port_set_mac_address ) ( s#dsa_switch * , int , const unsigned char * ) ; s#dsa_port * ( * preferred_default_local_cpu_port ) ( s#dsa_switch * ) ; int ( * set_mac_eee ) ( s#dsa_switch * , int , s#ethtool_keee * ) ; int ( * get_mac_eee ) ( s#dsa_switch * , int , s#ethtool_keee * ) ; int ( * get_eeprom_len ) ( s#dsa_switch * ) ; int ( * get_eeprom ) ( s#dsa_switch * , s#ethtool_eeprom * , t#u8 * ) ; int ( * set_eeprom ) ( s#dsa_switch * , s#ethtool_eeprom * , t#u8 * ) ; int ( * get_regs_len ) ( s#dsa_switch * , int ) ; void ( * get_regs ) ( s#dsa_switch * , int , s#ethtool_regs * , void * ) ; int ( * port_prechangeupper ) ( s#dsa_switch * , int , s#netdev_notifier_changeupper_info * ) ; int ( * set_ageing_time ) ( s#dsa_switch * , unsigned int ) ; int ( * port_bridge_join ) ( s#dsa_switch * , int , s#dsa_bridge , t#bool * , s#netlink_ext_ack * ) ; void ( * port_bridge_leave ) ( s#dsa_switch * , int , s#dsa_bridge ) ; void ( * port_stp_state_set ) ( s#dsa_switch * , int , t#u8 ) ; int ( * port_mst_state_set ) ( s#dsa_switch * , int , const s#switchdev_mst_state * ) ; void ( * port_fast_age ) ( s#dsa_switch * , int ) ; int ( * port_vlan_fast_age ) ( s#dsa_switch * , int , t#u16 ) ; int ( * port_pre_bridge_flags ) ( s#dsa_switch * , int , s#switchdev_brport_flags , s#netlink_ext_ack * ) ; int ( * port_bridge_flags ) ( s#dsa_switch * , int , s#switchdev_brport_flags , s#netlink_ext_ack * ) ; void ( * port_set_host_flood ) ( s#dsa_switch * , int , t#bool , t#bool ) ; int ( * port_vlan_filtering ) ( s#dsa_switch * , int , t#bool , s#netlink_ext_ack * ) ; int ( * port_vlan_add ) ( s#dsa_switch * , int , const s#switchdev_obj_port_vlan * , s#netlink_ext_ack * ) ; int ( * port_vlan_del ) ( s#dsa_switch * , int , const s#switchdev_obj_port_vlan * ) ; int ( * vlan_msti_set ) ( s#dsa_switch * , s#dsa_bridge , const s#switchdev_vlan_msti * ) ; int ( * port_fdb_add ) ( s#dsa_switch * , int , const unsigned char * , t#u16 , s#dsa_db ) ; int ( * port_fdb_del ) ( s#dsa_switch * , int , const unsigned char * , t#u16 , s#dsa_db ) ; int ( * port_fdb_dump ) ( s#dsa_switch * , int , t#dsa_fdb_dump_cb_t * , void * ) ; int ( * lag_fdb_add ) ( s#dsa_switch * , s#dsa_lag , const unsigned char * , t#u16 , s#dsa_db ) ; int ( * lag_fdb_del ) ( s#dsa_switch * , s#dsa_lag , const unsigned char * , t#u16 , s#dsa_db ) ; int ( * port_mdb_add ) ( s#dsa_switch * , int , const s#switchdev_obj_port_mdb * , s#dsa_db ) ; int ( * port_mdb_del ) ( s#dsa_switch * , int , const s#switchdev_obj_port_mdb * , s#dsa_db ) ; int ( * get_rxnfc ) ( s#dsa_switch * , int , s#ethtool_rxnfc * , t#u32 * ) ; int ( * set_rxnfc ) ( s#dsa_switch * , int , s#ethtool_rxnfc * ) ; int ( * cls_flower_add ) ( s#dsa_switch * , int , s#flow_cls_offload * , t#bool ) ; int ( * cls_flower_del ) ( s#dsa_switch * , int , s#flow_cls_offload * , t#bool ) ; int ( * cls_flower_stats ) ( s#dsa_switch * , int , s#flow_cls_offload * , t#bool ) ; int ( * port_mirror_add ) ( s#dsa_switch * , int , s#dsa_mall_mirror_tc_entry * , t#bool , s#netlink_ext_ack * ) ; void ( * port_mirror_del ) ( s#dsa_switch * , int , s#dsa_mall_mirror_tc_entry * ) ; int ( * port_policer_add ) ( s#dsa_switch * , int , s#dsa_mall_policer_tc_entry * ) ; void ( * port_policer_del ) ( s#dsa_switch * , int ) ; int ( * port_setup_tc ) ( s#dsa_switch * , int , e#tc_setup_type , void * ) ; int ( * crosschip_bridge_join ) ( s#dsa_switch * , int , int , int , s#dsa_bridge , s#netlink_ext_ack * ) ; void ( * crosschip_bridge_leave ) ( s#dsa_switch * , int , int , int , s#dsa_bridge ) ; int ( * crosschip_lag_change ) ( s#dsa_switch * , int , int ) ; int ( * crosschip_lag_join ) ( s#dsa_switch * , int , int , s#dsa_lag , s#netdev_lag_upper_info * , s#netlink_ext_ack * ) ; int ( * crosschip_lag_leave ) ( s#dsa_switch * , int , int , s#dsa_lag ) ; int ( * port_hwtstamp_get ) ( s#dsa_switch * , int , s#ifreq * ) ; int ( * port_hwtstamp_set ) ( s#dsa_switch * , int , s#ifreq * ) ; void ( * port_txtstamp ) ( s#dsa_switch * , int , s#sk_buff * ) ; t#bool ( * port_rxtstamp ) ( s#dsa_switch * , int , s#sk_buff * , unsigned int ) ; int ( * devlink_param_get ) ( s#dsa_switch * , t#u32 , s#devlink_param_gset_ctx * ) ; int ( * devlink_param_set ) ( s#dsa_switch * , t#u32 , s#devlink_param_gset_ctx * ) ; int ( * devlink_info_get ) ( s#dsa_switch * , s#devlink_info_req * , s#netlink_ext_ack * ) ; int ( * devlink_sb_pool_get ) ( s#dsa_switch * , unsigned int , t#u16 , s#devlink_sb_pool_info * ) ; int ( * devlink_sb_pool_set ) ( s#dsa_switch * , unsigned int , t#u16 , t#u32 , e#devlink_sb_threshold_type , s#netlink_ext_ack * ) ; int ( * devlink_sb_port_pool_get ) ( s#dsa_switch * , int , unsigned int , t#u16 , t#u32 * ) ; int ( * devlink_sb_port_pool_set ) ( s#dsa_switch * , int , unsigned int , t#u16 , t#u32 , s#netlink_ext_ack * ) ; int ( * devlink_sb_tc_pool_bind_get ) ( s#dsa_switch * , int , unsigned int , t#u16 , e#devlink_sb_pool_type , t#u16 * , t#u32 * ) ; int ( * devlink_sb_tc_pool_bind_set ) ( s#dsa_switch * , int , unsigned int , t#u16 , e#devlink_sb_pool_type , t#u16 , t#u32 , s#netlink_ext_ack * ) ; int ( * devlink_sb_occ_snapshot ) ( s#dsa_switch * , unsigned int ) ; int ( * devlink_sb_occ_max_clear ) ( s#dsa_switch * , unsigned int ) ; int ( * devlink_sb_occ_port_pool_get ) ( s#dsa_switch * , int , unsigned int , t#u16 , t#u32 * , t#u32 * ) ; int ( * devlink_sb_occ_tc_port_bind_get ) ( s#dsa_switch * , int , unsigned int , t#u16 , e#devlink_sb_pool_type , t#u32 * , t#u32 * ) ; int ( * port_change_mtu ) ( s#dsa_switch * , int , int ) ; int ( * port_max_mtu ) ( s#dsa_switch * , int ) ; int ( * port_lag_change ) ( s#dsa_switch * , int ) ; int ( * port_lag_join ) ( s#dsa_switch * , int , s#dsa_lag , s#netdev_lag_upper_info * , s#netlink_ext_ack * ) ; int ( * port_lag_leave ) ( s#dsa_switch * , int , s#dsa_lag ) ; int ( * port_hsr_join ) ( s#dsa_switch * , int , s#net_device * , s#netlink_ext_ack * ) ; int ( * port_hsr_leave ) ( s#dsa_switch * , int , s#net_device * ) ; int ( * port_mrp_add ) ( s#dsa_switch * , int , const s#switchdev_obj_mrp * ) ; int ( * port_mrp_del ) ( s#dsa_switch * , int , const s#switchdev_obj_mrp * ) ; int ( * port_mrp_add_ring_role ) ( s#dsa_switch * , int , const s#switchdev_obj_ring_role_mrp * ) ; int ( * port_mrp_del_ring_role ) ( s#dsa_switch * , int , const s#switchdev_obj_ring_role_mrp * ) ; int ( * tag_8021q_vlan_add ) ( s#dsa_switch * , int , t#u16 , t#u16 ) ; int ( * tag_8021q_vlan_del ) ( s#dsa_switch * , int , t#u16 ) ; void ( * conduit_state_change ) ( s#dsa_switch * , const s#net_device * , t#bool ) ; }
s#dsa_switch_tree struct dsa_switch_tree { s#list_head list ; s#list_head ports ; s#raw_notifier_head nh ; unsigned int index ; s#kref refcount ; s#dsa_lag * * lags ; const s#dsa_device_ops * tag_ops ; e#dsa_tag_protocol default_proto ; t#bool setup ; s#dsa_platform_data * pd ; s#list_head rtable ; unsigned int lags_len ; unsigned int last_switch ; }
s#dst_cache struct dst_cache { s#dst_cache_pcpu * cache ; unsigned long reset_ts ; }
s#dst_cache_pcpu struct dst_cache_pcpu { UNKNOWN }
s#dst_entry@5a2a5794 struct dst_entry { s#net_device * dev ; s#dst_ops * ops ; unsigned long _metrics ; unsigned long expires ; s#xfrm_state * xfrm ; int ( * input ) ( s#sk_buff * ) ; int ( * output ) ( s#net * , s#sock * , s#sk_buff * ) ; unsigned short flags ; short obsolete ; unsigned short header_len ; unsigned short trailer_len ; t#rcuref_t __rcuref ; int __use ; unsigned long lastuse ; s#callback_head callback_head ; short error ; short __pad ; t#__u32 tclassid ; t#netdevice_tracker dev_tracker ; s#list_head rt_uncached ; s#uncached_list * rt_uncached_list ; s#lwtunnel_state * lwtstate ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; }
s#dst_entry@d3e7ee36 struct dst_entry { UNKNOWN }
s#dst_metrics struct dst_metrics { t#u32 metrics [ ( E#__RTAX_MAX - 1 ) ] ; t#refcount_t refcnt ; }
s#dst_ops struct dst_ops { unsigned short family ; unsigned int gc_thresh ; void ( * gc ) ( s#dst_ops * ) ; s#dst_entry * ( * check ) ( s#dst_entry * , t#__u32 ) ; unsigned int ( * default_advmss ) ( const s#dst_entry * ) ; unsigned int ( * mtu ) ( const s#dst_entry * ) ; t#u32 * ( * cow_metrics ) ( s#dst_entry * , unsigned long ) ; void ( * destroy ) ( s#dst_entry * ) ; void ( * ifdown ) ( s#dst_entry * , s#net_device * ) ; void ( * negative_advice ) ( s#sock * , s#dst_entry * ) ; void ( * link_failure ) ( s#sk_buff * ) ; void ( * update_pmtu ) ( s#dst_entry * , s#sock * , s#sk_buff * , t#u32 , t#bool ) ; void ( * redirect ) ( s#dst_entry * , s#sock * , s#sk_buff * ) ; int ( * local_out ) ( s#net * , s#sock * , s#sk_buff * ) ; s#neighbour * ( * neigh_lookup ) ( const s#dst_entry * , s#sk_buff * , const void * ) ; void ( * confirm_neigh ) ( const s#dst_entry * , const void * ) ; s#kmem_cache * kmem_cachep ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; s#percpu_counter pcpuc_entries __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; }
s#eee_config struct eee_config { t#u32 tx_lpi_timer ; t#bool tx_lpi_enabled ; t#bool eee_enabled ; }
s#elevator_mq_ops struct elevator_mq_ops { int ( * init_sched ) ( s#request_queue * , s#elevator_type * ) ; void ( * exit_sched ) ( s#elevator_queue * ) ; int ( * init_hctx ) ( s#blk_mq_hw_ctx * , unsigned int ) ; void ( * exit_hctx ) ( s#blk_mq_hw_ctx * , unsigned int ) ; void ( * depth_updated ) ( s#blk_mq_hw_ctx * ) ; t#bool ( * allow_merge ) ( s#request_queue * , s#request * , s#bio * ) ; t#bool ( * bio_merge ) ( s#request_queue * , s#bio * , unsigned int ) ; int ( * request_merge ) ( s#request_queue * , s#request * * , s#bio * ) ; void ( * request_merged ) ( s#request_queue * , s#request * , e#elv_merge ) ; void ( * requests_merged ) ( s#request_queue * , s#request * , s#request * ) ; void ( * limit_depth ) ( t#blk_opf_t , s#blk_mq_alloc_data * ) ; void ( * prepare_request ) ( s#request * ) ; void ( * finish_request ) ( s#request * ) ; void ( * insert_requests ) ( s#blk_mq_hw_ctx * , s#list_head * , t#blk_insert_t ) ; s#request * ( * dispatch_request ) ( s#blk_mq_hw_ctx * ) ; t#bool ( * has_work ) ( s#blk_mq_hw_ctx * ) ; void ( * completed_request ) ( s#request * , t#u64 ) ; void ( * requeue_request ) ( s#request * ) ; s#request * ( * former_request ) ( s#request_queue * , s#request * ) ; s#request * ( * next_request ) ( s#request_queue * , s#request * ) ; void ( * init_icq ) ( s#io_cq * ) ; void ( * exit_icq ) ( s#io_cq * ) ; }
s#elevator_queue@68d4da21 struct elevator_queue { s#elevator_type * type ; void * elevator_data ; s#kobject kobj ; s#mutex sysfs_lock ; unsigned long flags ; s#hlist_head hash [ 1 << ( 6 ) ] ; }
s#elevator_queue@d35b4dc0 struct elevator_queue { UNKNOWN }
s#elevator_type struct elevator_type { s#kmem_cache * icq_cache ; s#elevator_mq_ops ops ; t#size_t icq_size ; t#size_t icq_align ; s#elv_fs_entry * elevator_attrs ; const char * elevator_name ; const char * elevator_alias ; s#module * elevator_owner ; const s#blk_mq_debugfs_attr * queue_debugfs_attrs ; const s#blk_mq_debugfs_attr * hctx_debugfs_attrs ; char icq_cache_name [ ( 16 ) + 6 ] ; s#list_head list ; }
s#elf64_sym struct elf64_sym { t#Elf64_Word st_name ; unsigned char st_info ; unsigned char st_other ; t#Elf64_Half st_shndx ; t#Elf64_Addr st_value ; t#Elf64_Xword st_size ; }
s#elv_fs_entry struct elv_fs_entry { s#attribute attr ; t#ssize_t ( * show ) ( s#elevator_queue * , char * ) ; t#ssize_t ( * store ) ( s#elevator_queue * , const char * , t#size_t ) ; }
s#em_perf_domain struct em_perf_domain { s#em_perf_table * em_table ; int nr_perf_states ; unsigned long flags ; unsigned long cpus [ ] ; }
s#em_perf_state struct em_perf_state { unsigned long performance ; unsigned long frequency ; unsigned long power ; unsigned long cost ; unsigned long flags ; }
s#em_perf_table struct em_perf_table { s#callback_head rcu ; s#kref kref ; s#em_perf_state state [ ] ; }
s#encoded_page struct encoded_page { UNKNOWN }
s#erase_info struct erase_info { t#uint64_t addr ; t#uint64_t len ; t#uint64_t fail_addr ; }
s#error_injection_entry struct error_injection_entry { unsigned long addr ; int etype ; }
s#ethhdr struct ethhdr { unsigned char h_dest [ 6 ] ; unsigned char h_source [ 6 ] ; t#__be16 h_proto ; }
s#ethtool_ah_espip4_spec struct ethtool_ah_espip4_spec { t#__be32 ip4src ; t#__be32 ip4dst ; t#__be32 spi ; t#__u8 tos ; }
s#ethtool_ah_espip6_spec struct ethtool_ah_espip6_spec { t#__be32 ip6src [ 4 ] ; t#__be32 ip6dst [ 4 ] ; t#__be32 spi ; t#__u8 tclass ; }
s#ethtool_channels struct ethtool_channels { t#__u32 cmd ; t#__u32 max_rx ; t#__u32 max_tx ; t#__u32 max_other ; t#__u32 max_combined ; t#__u32 rx_count ; t#__u32 tx_count ; t#__u32 other_count ; t#__u32 combined_count ; }
s#ethtool_coalesce struct ethtool_coalesce { t#__u32 cmd ; t#__u32 rx_coalesce_usecs ; t#__u32 rx_max_coalesced_frames ; t#__u32 rx_coalesce_usecs_irq ; t#__u32 rx_max_coalesced_frames_irq ; t#__u32 tx_coalesce_usecs ; t#__u32 tx_max_coalesced_frames ; t#__u32 tx_coalesce_usecs_irq ; t#__u32 tx_max_coalesced_frames_irq ; t#__u32 stats_block_coalesce_usecs ; t#__u32 use_adaptive_rx_coalesce ; t#__u32 use_adaptive_tx_coalesce ; t#__u32 pkt_rate_low ; t#__u32 rx_coalesce_usecs_low ; t#__u32 rx_max_coalesced_frames_low ; t#__u32 tx_coalesce_usecs_low ; t#__u32 tx_max_coalesced_frames_low ; t#__u32 pkt_rate_high ; t#__u32 rx_coalesce_usecs_high ; t#__u32 rx_max_coalesced_frames_high ; t#__u32 tx_coalesce_usecs_high ; t#__u32 tx_max_coalesced_frames_high ; t#__u32 rate_sample_interval ; }
s#ethtool_drvinfo struct ethtool_drvinfo { t#__u32 cmd ; char driver [ 32 ] ; char version [ 32 ] ; char fw_version [ 32 ] ; char bus_info [ 32 ] ; char erom_version [ 32 ] ; char reserved2 [ 12 ] ; t#__u32 n_priv_flags ; t#__u32 n_stats ; t#__u32 testinfo_len ; t#__u32 eedump_len ; t#__u32 regdump_len ; }
s#ethtool_dump struct ethtool_dump { t#__u32 cmd ; t#__u32 version ; t#__u32 flag ; t#__u32 len ; t#__u8 data [ ] ; }
s#ethtool_eeprom struct ethtool_eeprom { t#__u32 cmd ; t#__u32 magic ; t#__u32 offset ; t#__u32 len ; t#__u8 data [ ] ; }
s#ethtool_eth_ctrl_stats struct ethtool_eth_ctrl_stats { e#ethtool_mac_stats_src src ; union { struct { t#u64 MACControlFramesTransmitted ; t#u64 MACControlFramesReceived ; t#u64 UnsupportedOpcodesReceived ; } ; struct { t#u64 MACControlFramesTransmitted ; t#u64 MACControlFramesReceived ; t#u64 UnsupportedOpcodesReceived ; } stats ; } ; }
s#ethtool_eth_mac_stats struct ethtool_eth_mac_stats { e#ethtool_mac_stats_src src ; union { struct { t#u64 FramesTransmittedOK ; t#u64 SingleCollisionFrames ; t#u64 MultipleCollisionFrames ; t#u64 FramesReceivedOK ; t#u64 FrameCheckSequenceErrors ; t#u64 AlignmentErrors ; t#u64 OctetsTransmittedOK ; t#u64 FramesWithDeferredXmissions ; t#u64 LateCollisions ; t#u64 FramesAbortedDueToXSColls ; t#u64 FramesLostDueToIntMACXmitError ; t#u64 CarrierSenseErrors ; t#u64 OctetsReceivedOK ; t#u64 FramesLostDueToIntMACRcvError ; t#u64 MulticastFramesXmittedOK ; t#u64 BroadcastFramesXmittedOK ; t#u64 FramesWithExcessiveDeferral ; t#u64 MulticastFramesReceivedOK ; t#u64 BroadcastFramesReceivedOK ; t#u64 InRangeLengthErrors ; t#u64 OutOfRangeLengthField ; t#u64 FrameTooLongErrors ; } ; struct { t#u64 FramesTransmittedOK ; t#u64 SingleCollisionFrames ; t#u64 MultipleCollisionFrames ; t#u64 FramesReceivedOK ; t#u64 FrameCheckSequenceErrors ; t#u64 AlignmentErrors ; t#u64 OctetsTransmittedOK ; t#u64 FramesWithDeferredXmissions ; t#u64 LateCollisions ; t#u64 FramesAbortedDueToXSColls ; t#u64 FramesLostDueToIntMACXmitError ; t#u64 CarrierSenseErrors ; t#u64 OctetsReceivedOK ; t#u64 FramesLostDueToIntMACRcvError ; t#u64 MulticastFramesXmittedOK ; t#u64 BroadcastFramesXmittedOK ; t#u64 FramesWithExcessiveDeferral ; t#u64 MulticastFramesReceivedOK ; t#u64 BroadcastFramesReceivedOK ; t#u64 InRangeLengthErrors ; t#u64 OutOfRangeLengthField ; t#u64 FrameTooLongErrors ; } stats ; } ; }
s#ethtool_eth_phy_stats@b9c10d93 struct ethtool_eth_phy_stats { UNKNOWN }
s#ethtool_eth_phy_stats@e5a790c1 struct ethtool_eth_phy_stats { e#ethtool_mac_stats_src src ; union { struct { t#u64 SymbolErrorDuringCarrier ; } ; struct { t#u64 SymbolErrorDuringCarrier ; } stats ; } ; }
s#ethtool_fec_stat struct ethtool_fec_stat { t#u64 total ; t#u64 lanes [ 8 ] ; }
s#ethtool_fec_stats struct ethtool_fec_stats { s#ethtool_fec_stat corrected_blocks , uncorrectable_blocks , corrected_bits ; }
s#ethtool_fecparam struct ethtool_fecparam { t#__u32 cmd ; t#__u32 active_fec ; t#__u32 fec ; t#__u32 reserved ; }
s#ethtool_flash struct ethtool_flash { t#__u32 cmd ; t#__u32 region ; char data [ 128 ] ; }
s#ethtool_flow_ext struct ethtool_flow_ext { t#__u8 padding [ 2 ] ; unsigned char h_dest [ 6 ] ; t#__be16 vlan_etype ; t#__be16 vlan_tci ; t#__be32 data [ 2 ] ; }
s#ethtool_keee struct ethtool_keee { unsigned long supported [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long advertised [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long lp_advertised [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; t#u32 tx_lpi_timer ; t#bool tx_lpi_enabled ; t#bool eee_active ; t#bool eee_enabled ; }
s#ethtool_link_ext_state_info struct ethtool_link_ext_state_info { e#ethtool_link_ext_state link_ext_state ; union { e#ethtool_link_ext_substate_autoneg autoneg ; e#ethtool_link_ext_substate_link_training link_training ; e#ethtool_link_ext_substate_link_logical_mismatch link_logical_mismatch ; e#ethtool_link_ext_substate_bad_signal_integrity bad_signal_integrity ; e#ethtool_link_ext_substate_cable_issue cable_issue ; e#ethtool_link_ext_substate_module module ; t#u32 __link_ext_substate ; } ; unsigned long uek_reserved1 ; }
s#ethtool_link_ext_stats@42f8b2c9 struct ethtool_link_ext_stats { t#u64 link_down_events ; }
s#ethtool_link_ext_stats@e86a9f33 struct ethtool_link_ext_stats { UNKNOWN }
s#ethtool_link_ksettings struct ethtool_link_ksettings { s#ethtool_link_settings base ; struct { unsigned long supported [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long advertising [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long lp_advertising [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; } link_modes ; t#u32 lanes ; }
s#ethtool_link_settings struct ethtool_link_settings { t#__u32 cmd ; t#__u32 speed ; t#__u8 duplex ; t#__u8 port ; t#__u8 phy_address ; t#__u8 autoneg ; t#__u8 mdio_support ; t#__u8 eth_tp_mdix ; t#__u8 eth_tp_mdix_ctrl ; t#__s8 link_mode_masks_nwords ; t#__u8 transceiver ; t#__u8 master_slave_cfg ; t#__u8 master_slave_state ; t#__u8 rate_matching ; t#__u32 reserved [ 7 ] ; t#__u32 link_mode_masks [ ] ; }
s#ethtool_mm_cfg struct ethtool_mm_cfg { t#u32 verify_time ; t#bool verify_enabled ; t#bool tx_enabled ; t#bool pmac_enabled ; t#u32 tx_min_frag_size ; }
s#ethtool_mm_state struct ethtool_mm_state { t#u32 verify_time ; t#u32 max_verify_time ; e#ethtool_mm_verify_status verify_status ; t#bool tx_enabled ; t#bool tx_active ; t#bool pmac_enabled ; t#bool verify_enabled ; t#u32 tx_min_frag_size ; t#u32 rx_min_frag_size ; }
s#ethtool_mm_stats struct ethtool_mm_stats { t#u64 MACMergeFrameAssErrorCount ; t#u64 MACMergeFrameSmdErrorCount ; t#u64 MACMergeFrameAssOkCount ; t#u64 MACMergeFragCountRx ; t#u64 MACMergeFragCountTx ; t#u64 MACMergeHoldCount ; }
s#ethtool_modinfo struct ethtool_modinfo { t#__u32 cmd ; t#__u32 type ; t#__u32 eeprom_len ; t#__u32 reserved [ 8 ] ; }
s#ethtool_module_eeprom struct ethtool_module_eeprom { t#u32 offset ; t#u32 length ; t#u8 page ; t#u8 bank ; t#u8 i2c_address ; t#u8 * data ; }
s#ethtool_module_power_mode_params struct ethtool_module_power_mode_params { e#ethtool_module_power_mode_policy policy ; e#ethtool_module_power_mode mode ; }
s#ethtool_netdev_state@6330f982 struct ethtool_netdev_state { s#xarray rss_ctx ; s#mutex rss_lock ; unsigned wol_enabled : 1 ; unsigned module_fw_flash_in_progress : 1 ; }
s#ethtool_netdev_state@eff8fd02 struct ethtool_netdev_state { UNKNOWN }
s#ethtool_ops@13aaf17f struct ethtool_ops { UNKNOWN }
s#ethtool_ops@1d1dba04 struct ethtool_ops { t#u32 cap_link_lanes_supported : 1 ; t#u32 cap_rss_ctx_supported : 1 ; t#u32 cap_rss_sym_xor_supported : 1 ; t#u32 rxfh_per_ctx_key : 1 ; t#u32 cap_rss_rxnfc_adds : 1 ; t#u32 rxfh_indir_space ; t#u16 rxfh_key_space ; t#u16 rxfh_priv_size ; t#u32 rxfh_max_num_contexts ; t#u32 supported_coalesce_params ; t#u32 supported_ring_params ; void ( * get_drvinfo ) ( s#net_device * , s#ethtool_drvinfo * ) ; int ( * get_regs_len ) ( s#net_device * ) ; void ( * get_regs ) ( s#net_device * , s#ethtool_regs * , void * ) ; void ( * get_wol ) ( s#net_device * , s#ethtool_wolinfo * ) ; int ( * set_wol ) ( s#net_device * , s#ethtool_wolinfo * ) ; t#u32 ( * get_msglevel ) ( s#net_device * ) ; void ( * set_msglevel ) ( s#net_device * , t#u32 ) ; int ( * nway_reset ) ( s#net_device * ) ; t#u32 ( * get_link ) ( s#net_device * ) ; int ( * get_link_ext_state ) ( s#net_device * , s#ethtool_link_ext_state_info * ) ; void ( * get_link_ext_stats ) ( s#net_device * , s#ethtool_link_ext_stats * ) ; int ( * get_eeprom_len ) ( s#net_device * ) ; int ( * get_eeprom ) ( s#net_device * , s#ethtool_eeprom * , t#u8 * ) ; int ( * set_eeprom ) ( s#net_device * , s#ethtool_eeprom * , t#u8 * ) ; int ( * get_coalesce ) ( s#net_device * , s#ethtool_coalesce * , s#kernel_ethtool_coalesce * , s#netlink_ext_ack * ) ; int ( * set_coalesce ) ( s#net_device * , s#ethtool_coalesce * , s#kernel_ethtool_coalesce * , s#netlink_ext_ack * ) ; void ( * get_ringparam ) ( s#net_device * , s#ethtool_ringparam * , s#kernel_ethtool_ringparam * , s#netlink_ext_ack * ) ; int ( * set_ringparam ) ( s#net_device * , s#ethtool_ringparam * , s#kernel_ethtool_ringparam * , s#netlink_ext_ack * ) ; void ( * get_pause_stats ) ( s#net_device * , s#ethtool_pause_stats * ) ; void ( * get_pauseparam ) ( s#net_device * , s#ethtool_pauseparam * ) ; int ( * set_pauseparam ) ( s#net_device * , s#ethtool_pauseparam * ) ; void ( * self_test ) ( s#net_device * , s#ethtool_test * , t#u64 * ) ; void ( * get_strings ) ( s#net_device * , t#u32 , t#u8 * ) ; int ( * set_phys_id ) ( s#net_device * , e#ethtool_phys_id_state ) ; void ( * get_ethtool_stats ) ( s#net_device * , s#ethtool_stats * , t#u64 * ) ; int ( * begin ) ( s#net_device * ) ; void ( * complete ) ( s#net_device * ) ; t#u32 ( * get_priv_flags ) ( s#net_device * ) ; int ( * set_priv_flags ) ( s#net_device * , t#u32 ) ; int ( * get_sset_count ) ( s#net_device * , int ) ; int ( * get_rxnfc ) ( s#net_device * , s#ethtool_rxnfc * , t#u32 * ) ; int ( * set_rxnfc ) ( s#net_device * , s#ethtool_rxnfc * ) ; int ( * flash_device ) ( s#net_device * , s#ethtool_flash * ) ; int ( * reset ) ( s#net_device * , t#u32 * ) ; t#u32 ( * get_rxfh_key_size ) ( s#net_device * ) ; t#u32 ( * get_rxfh_indir_size ) ( s#net_device * ) ; int ( * get_rxfh ) ( s#net_device * , s#ethtool_rxfh_param * ) ; int ( * set_rxfh ) ( s#net_device * , s#ethtool_rxfh_param * , s#netlink_ext_ack * ) ; int ( * create_rxfh_context ) ( s#net_device * , s#ethtool_rxfh_context * , const s#ethtool_rxfh_param * , s#netlink_ext_ack * ) ; int ( * modify_rxfh_context ) ( s#net_device * , s#ethtool_rxfh_context * , const s#ethtool_rxfh_param * , s#netlink_ext_ack * ) ; int ( * remove_rxfh_context ) ( s#net_device * , s#ethtool_rxfh_context * , t#u32 , s#netlink_ext_ack * ) ; void ( * get_channels ) ( s#net_device * , s#ethtool_channels * ) ; int ( * set_channels ) ( s#net_device * , s#ethtool_channels * ) ; int ( * get_dump_flag ) ( s#net_device * , s#ethtool_dump * ) ; int ( * get_dump_data ) ( s#net_device * , s#ethtool_dump * , void * ) ; int ( * set_dump ) ( s#net_device * , s#ethtool_dump * ) ; int ( * get_ts_info ) ( s#net_device * , s#kernel_ethtool_ts_info * ) ; void ( * get_ts_stats ) ( s#net_device * , s#ethtool_ts_stats * ) ; int ( * get_module_info ) ( s#net_device * , s#ethtool_modinfo * ) ; int ( * get_module_eeprom ) ( s#net_device * , s#ethtool_eeprom * , t#u8 * ) ; int ( * get_eee ) ( s#net_device * , s#ethtool_keee * ) ; int ( * set_eee ) ( s#net_device * , s#ethtool_keee * ) ; int ( * get_tunable ) ( s#net_device * , const s#ethtool_tunable * , void * ) ; int ( * set_tunable ) ( s#net_device * , const s#ethtool_tunable * , const void * ) ; int ( * get_per_queue_coalesce ) ( s#net_device * , t#u32 , s#ethtool_coalesce * ) ; int ( * set_per_queue_coalesce ) ( s#net_device * , t#u32 , s#ethtool_coalesce * ) ; int ( * get_link_ksettings ) ( s#net_device * , s#ethtool_link_ksettings * ) ; int ( * set_link_ksettings ) ( s#net_device * , const s#ethtool_link_ksettings * ) ; void ( * get_fec_stats ) ( s#net_device * , s#ethtool_fec_stats * ) ; int ( * get_fecparam ) ( s#net_device * , s#ethtool_fecparam * ) ; int ( * set_fecparam ) ( s#net_device * , s#ethtool_fecparam * ) ; void ( * get_ethtool_phy_stats ) ( s#net_device * , s#ethtool_stats * , t#u64 * ) ; int ( * get_phy_tunable ) ( s#net_device * , const s#ethtool_tunable * , void * ) ; int ( * set_phy_tunable ) ( s#net_device * , const s#ethtool_tunable * , const void * ) ; int ( * get_module_eeprom_by_page ) ( s#net_device * , const s#ethtool_module_eeprom * , s#netlink_ext_ack * ) ; int ( * set_module_eeprom_by_page ) ( s#net_device * , const s#ethtool_module_eeprom * , s#netlink_ext_ack * ) ; void ( * get_eth_phy_stats ) ( s#net_device * , s#ethtool_eth_phy_stats * ) ; void ( * get_eth_mac_stats ) ( s#net_device * , s#ethtool_eth_mac_stats * ) ; void ( * get_eth_ctrl_stats ) ( s#net_device * , s#ethtool_eth_ctrl_stats * ) ; void ( * get_rmon_stats ) ( s#net_device * , s#ethtool_rmon_stats * , const s#ethtool_rmon_hist_range * * ) ; int ( * get_module_power_mode ) ( s#net_device * , s#ethtool_module_power_mode_params * , s#netlink_ext_ack * ) ; int ( * set_module_power_mode ) ( s#net_device * , const s#ethtool_module_power_mode_params * , s#netlink_ext_ack * ) ; int ( * get_mm ) ( s#net_device * , s#ethtool_mm_state * ) ; int ( * set_mm ) ( s#net_device * , s#ethtool_mm_cfg * , s#netlink_ext_ack * ) ; void ( * get_mm_stats ) ( s#net_device * , s#ethtool_mm_stats * ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#ethtool_pause_stats struct ethtool_pause_stats { e#ethtool_mac_stats_src src ; union { struct { t#u64 tx_pause_frames ; t#u64 rx_pause_frames ; } ; struct { t#u64 tx_pause_frames ; t#u64 rx_pause_frames ; } stats ; } ; }
s#ethtool_pauseparam struct ethtool_pauseparam { t#__u32 cmd ; t#__u32 autoneg ; t#__u32 rx_pause ; t#__u32 tx_pause ; }
s#ethtool_phy_stats@1abf8c99 struct ethtool_phy_stats { t#u64 rx_packets ; t#u64 rx_bytes ; t#u64 rx_errors ; t#u64 tx_packets ; t#u64 tx_bytes ; t#u64 tx_errors ; }
s#ethtool_phy_stats@3eaa03b7 struct ethtool_phy_stats { UNKNOWN }
s#ethtool_regs struct ethtool_regs { t#__u32 cmd ; t#__u32 version ; t#__u32 len ; t#__u8 data [ ] ; }
s#ethtool_ringparam struct ethtool_ringparam { t#__u32 cmd ; t#__u32 rx_max_pending ; t#__u32 rx_mini_max_pending ; t#__u32 rx_jumbo_max_pending ; t#__u32 tx_max_pending ; t#__u32 rx_pending ; t#__u32 rx_mini_pending ; t#__u32 rx_jumbo_pending ; t#__u32 tx_pending ; }
s#ethtool_rmon_hist_range struct ethtool_rmon_hist_range { t#u16 low ; t#u16 high ; }
s#ethtool_rmon_stats struct ethtool_rmon_stats { e#ethtool_mac_stats_src src ; union { struct { t#u64 undersize_pkts ; t#u64 oversize_pkts ; t#u64 fragments ; t#u64 jabbers ; t#u64 hist [ 10 ] ; t#u64 hist_tx [ 10 ] ; } ; struct { t#u64 undersize_pkts ; t#u64 oversize_pkts ; t#u64 fragments ; t#u64 jabbers ; t#u64 hist [ 10 ] ; t#u64 hist_tx [ 10 ] ; } stats ; } ; }
s#ethtool_rx_flow_spec struct ethtool_rx_flow_spec { t#__u32 flow_type ; u#ethtool_flow_union h_u ; s#ethtool_flow_ext h_ext ; u#ethtool_flow_union m_u ; s#ethtool_flow_ext m_ext ; t#__u64 ring_cookie ; t#__u32 location ; }
s#ethtool_rxfh_context struct ethtool_rxfh_context { t#u32 indir_size ; t#u32 key_size ; t#u16 priv_size ; t#u8 hfunc ; t#u8 input_xfrm ; t#u8 indir_configured : 1 ; t#u8 key_configured : 1 ; t#u32 key_off ; t#u8 data [ ] __attribute__ ( ( __aligned__ ( sizeof ( void * ) ) ) ) ; }
s#ethtool_rxfh_param struct ethtool_rxfh_param { t#u8 hfunc ; t#u32 indir_size ; t#u32 * indir ; t#u32 key_size ; t#u8 * key ; t#u32 rss_context ; t#u8 rss_delete ; t#u8 input_xfrm ; }
s#ethtool_rxnfc struct ethtool_rxnfc { t#__u32 cmd ; t#__u32 flow_type ; t#__u64 data ; s#ethtool_rx_flow_spec fs ; union { t#__u32 rule_cnt ; t#__u32 rss_context ; } ; t#__u32 rule_locs [ ] ; }
s#ethtool_stats struct ethtool_stats { t#__u32 cmd ; t#__u32 n_stats ; t#__u64 data [ ] ; }
s#ethtool_tcpip4_spec struct ethtool_tcpip4_spec { t#__be32 ip4src ; t#__be32 ip4dst ; t#__be16 psrc ; t#__be16 pdst ; t#__u8 tos ; }
s#ethtool_tcpip6_spec struct ethtool_tcpip6_spec { t#__be32 ip6src [ 4 ] ; t#__be32 ip6dst [ 4 ] ; t#__be16 psrc ; t#__be16 pdst ; t#__u8 tclass ; }
s#ethtool_test struct ethtool_test { t#__u32 cmd ; t#__u32 flags ; t#__u32 reserved ; t#__u32 len ; t#__u64 data [ ] ; }
s#ethtool_ts_stats struct ethtool_ts_stats { union { struct { t#u64 pkts ; t#u64 lost ; t#u64 err ; } ; struct { t#u64 pkts ; t#u64 lost ; t#u64 err ; } tx_stats ; } ; }
s#ethtool_tunable struct ethtool_tunable { t#__u32 cmd ; t#__u32 id ; t#__u32 type_id ; t#__u32 len ; void * data [ ] ; }
s#ethtool_usrip4_spec struct ethtool_usrip4_spec { t#__be32 ip4src ; t#__be32 ip4dst ; t#__be32 l4_4_bytes ; t#__u8 tos ; t#__u8 ip_ver ; t#__u8 proto ; }
s#ethtool_usrip6_spec struct ethtool_usrip6_spec { t#__be32 ip6src [ 4 ] ; t#__be32 ip6dst [ 4 ] ; t#__be32 l4_4_bytes ; t#__u8 tclass ; t#__u8 l4_proto ; }
s#ethtool_wolinfo struct ethtool_wolinfo { t#__u32 cmd ; t#__u32 supported ; t#__u32 wolopts ; t#__u8 sopass [ 6 ] ; }
s#event_filter@75cdb1df struct event_filter { s#prog_entry * prog ; char * filter_string ; }
s#event_filter@89b1689f struct event_filter { UNKNOWN }
s#event_subsystem struct event_subsystem { s#list_head list ; const char * name ; s#event_filter * filter ; int ref_count ; }
s#eventfd_ctx struct eventfd_ctx { UNKNOWN }
s#eventfs_inode struct eventfs_inode { UNKNOWN }
s#exception_table_entry struct exception_table_entry { int insn , fixup , data ; }
s#export_operations@96518368 struct export_operations { UNKNOWN }
s#export_operations@97c6b0cb struct export_operations { int ( * encode_fh ) ( s#inode * , t#__u32 * , int * , s#inode * ) ; s#dentry * ( * fh_to_dentry ) ( s#super_block * , s#fid * , int , int ) ; s#dentry * ( * fh_to_parent ) ( s#super_block * , s#fid * , int , int ) ; int ( * get_name ) ( s#dentry * , char * , s#dentry * ) ; s#dentry * ( * get_parent ) ( s#dentry * ) ; int ( * commit_metadata ) ( s#inode * ) ; int ( * get_uuid ) ( s#super_block * , t#u8 * , t#u32 * , t#u64 * ) ; int ( * map_blocks ) ( s#inode * , t#loff_t , t#u64 , s#iomap * , t#bool , t#u32 * ) ; int ( * commit_blocks ) ( s#inode * , s#iomap * , int , s#iattr * ) ; unsigned long flags ; }
s#fasync_struct struct fasync_struct { t#rwlock_t fa_lock ; int magic ; int fa_fd ; s#fasync_struct * fa_next ; s#file * fa_file ; s#callback_head fa_rcu ; }
s#fc_fpin_stats struct fc_fpin_stats { t#u64 dn ; t#u64 dn_unknown ; t#u64 dn_timeout ; t#u64 dn_unable_to_route ; t#u64 dn_device_specific ; t#u64 li ; t#u64 li_failure_unknown ; t#u64 li_link_failure_count ; t#u64 li_loss_of_sync_count ; t#u64 li_loss_of_signals_count ; t#u64 li_prim_seq_err_count ; t#u64 li_invalid_tx_word_count ; t#u64 li_invalid_crc_count ; t#u64 li_device_specific ; t#u64 cn ; t#u64 cn_clear ; t#u64 cn_lost_credit ; t#u64 cn_credit_stall ; t#u64 cn_oversubscription ; t#u64 cn_device_specific ; }
s#fc_function_template struct fc_function_template { void ( * get_rport_dev_loss_tmo ) ( s#fc_rport * ) ; void ( * set_rport_dev_loss_tmo ) ( s#fc_rport * , t#u32 ) ; void ( * get_starget_node_name ) ( s#scsi_target * ) ; void ( * get_starget_port_name ) ( s#scsi_target * ) ; void ( * get_starget_port_id ) ( s#scsi_target * ) ; void ( * get_host_port_id ) ( s#Scsi_Host * ) ; void ( * get_host_port_type ) ( s#Scsi_Host * ) ; void ( * get_host_port_state ) ( s#Scsi_Host * ) ; void ( * get_host_active_fc4s ) ( s#Scsi_Host * ) ; void ( * get_host_speed ) ( s#Scsi_Host * ) ; void ( * get_host_fabric_name ) ( s#Scsi_Host * ) ; void ( * get_host_symbolic_name ) ( s#Scsi_Host * ) ; void ( * set_host_system_hostname ) ( s#Scsi_Host * ) ; s#fc_host_statistics * ( * get_fc_host_stats ) ( s#Scsi_Host * ) ; void ( * reset_fc_host_stats ) ( s#Scsi_Host * ) ; int ( * issue_fc_host_lip ) ( s#Scsi_Host * ) ; void ( * dev_loss_tmo_callbk ) ( s#fc_rport * ) ; void ( * terminate_rport_io ) ( s#fc_rport * ) ; void ( * set_vport_symbolic_name ) ( s#fc_vport * ) ; int ( * vport_create ) ( s#fc_vport * , t#bool ) ; int ( * vport_disable ) ( s#fc_vport * , t#bool ) ; int ( * vport_delete ) ( s#fc_vport * ) ; t#u32 max_bsg_segments ; int ( * bsg_request ) ( s#bsg_job * ) ; int ( * bsg_timeout ) ( s#bsg_job * ) ; t#u32 dd_fcrport_size ; t#u32 dd_fcvport_size ; t#u32 dd_bsg_size ; unsigned long show_rport_maxframe_size : 1 ; unsigned long show_rport_supported_classes : 1 ; unsigned long show_rport_dev_loss_tmo : 1 ; unsigned long show_starget_node_name : 1 ; unsigned long show_starget_port_name : 1 ; unsigned long show_starget_port_id : 1 ; unsigned long show_host_node_name : 1 ; unsigned long show_host_port_name : 1 ; unsigned long show_host_permanent_port_name : 1 ; unsigned long show_host_supported_classes : 1 ; unsigned long show_host_supported_fc4s : 1 ; unsigned long show_host_supported_speeds : 1 ; unsigned long show_host_maxframe_size : 1 ; unsigned long show_host_serial_number : 1 ; unsigned long show_host_manufacturer : 1 ; unsigned long show_host_model : 1 ; unsigned long show_host_model_description : 1 ; unsigned long show_host_hardware_version : 1 ; unsigned long show_host_driver_version : 1 ; unsigned long show_host_firmware_version : 1 ; unsigned long show_host_optionrom_version : 1 ; unsigned long show_host_port_id : 1 ; unsigned long show_host_port_type : 1 ; unsigned long show_host_port_state : 1 ; unsigned long show_host_active_fc4s : 1 ; unsigned long show_host_speed : 1 ; unsigned long show_host_fabric_name : 1 ; unsigned long show_host_symbolic_name : 1 ; unsigned long show_host_system_hostname : 1 ; unsigned long disable_target_scan : 1 ; }
s#fc_host_statistics struct fc_host_statistics { t#u64 seconds_since_last_reset ; t#u64 tx_frames ; t#u64 tx_words ; t#u64 rx_frames ; t#u64 rx_words ; t#u64 lip_count ; t#u64 nos_count ; t#u64 error_frames ; t#u64 dumped_frames ; t#u64 link_failure_count ; t#u64 loss_of_sync_count ; t#u64 loss_of_signal_count ; t#u64 prim_seq_protocol_err_count ; t#u64 invalid_tx_word_count ; t#u64 invalid_crc_count ; t#u64 fcp_input_requests ; t#u64 fcp_output_requests ; t#u64 fcp_control_requests ; t#u64 fcp_input_megabytes ; t#u64 fcp_output_megabytes ; t#u64 fcp_packet_alloc_failures ; t#u64 fcp_packet_aborts ; t#u64 fcp_frame_alloc_failures ; t#u64 fc_no_free_exch ; t#u64 fc_no_free_exch_xid ; t#u64 fc_xid_not_found ; t#u64 fc_xid_busy ; t#u64 fc_seq_not_found ; t#u64 fc_non_bls_resp ; t#u64 cn_sig_warn ; t#u64 cn_sig_alarm ; }
s#fc_log struct fc_log { t#refcount_t usage ; t#u8 head ; t#u8 tail ; t#u8 need_free ; s#module * owner ; char * buffer [ 8 ] ; }
s#fc_rport struct fc_rport { t#u32 maxframe_size ; t#u32 supported_classes ; t#u32 dev_loss_tmo ; s#fc_fpin_stats fpin_stats ; t#u64 node_name ; t#u64 port_name ; t#u32 port_id ; t#u32 roles ; e#fc_port_state port_state ; t#u32 scsi_target_id ; t#u32 fast_io_fail_tmo ; void * dd_data ; unsigned int channel ; t#u32 number ; t#u8 flags ; s#list_head peers ; s#device dev ; s#delayed_work dev_loss_work ; s#work_struct scan_work ; s#delayed_work fail_io_work ; s#work_struct stgt_delete_work ; s#work_struct rport_delete_work ; s#request_queue * rqst_q ; }
s#fc_rport_identifiers struct fc_rport_identifiers { t#u64 node_name ; t#u64 port_name ; t#u32 port_id ; t#u32 roles ; }
s#fc_vport struct fc_vport { e#fc_vport_state vport_state ; e#fc_vport_state vport_last_state ; t#u64 node_name ; t#u64 port_name ; t#u32 roles ; t#u32 vport_id ; e#fc_port_type vport_type ; char symbolic_name [ 64 ] ; void * dd_data ; s#Scsi_Host * shost ; unsigned int channel ; t#u32 number ; t#u8 flags ; s#list_head peers ; s#device dev ; s#work_struct vport_delete_work ; }
s#fd struct fd { unsigned long word ; }
s#fdtable struct fdtable { unsigned int max_fds ; s#file * * fd ; unsigned long * close_on_exec ; unsigned long * open_fds ; unsigned long * full_fds_bits ; s#callback_head rcu ; }
s#fgraph_ops struct fgraph_ops { t#trace_func_graph_ent_t entryfunc ; t#trace_func_graph_ret_t retfunc ; s#ftrace_ops ops ; void * private ; t#trace_func_graph_ent_t saved_func ; int idx ; }
s#fib6_info@2d942774 struct fib6_info { s#fib6_table * fib6_table ; s#fib6_info * fib6_next ; s#fib6_node * fib6_node ; union { s#list_head fib6_siblings ; s#list_head nh_list ; } ; unsigned int fib6_nsiblings ; t#refcount_t fib6_ref ; unsigned long expires ; s#hlist_node gc_link ; s#dst_metrics * fib6_metrics ; s#rt6key fib6_dst ; t#u32 fib6_flags ; s#rt6key fib6_src ; s#rt6key fib6_prefsrc ; t#u32 fib6_metric ; t#u8 fib6_protocol ; t#u8 fib6_type ; t#u8 offload ; t#u8 trap ; t#u8 offload_failed ; t#u8 should_flush : 1 , dst_nocount : 1 , dst_nopolicy : 1 , fib6_destroying : 1 , unused : 4 ; s#callback_head rcu ; s#nexthop * nh ; s#fib6_nh fib6_nh [ ] ; }
s#fib6_info@efeac2b6 struct fib6_info { UNKNOWN }
s#fib6_nh@58738b2a struct fib6_nh { s#fib_nh_common nh_common ; unsigned long last_probe ; s#rt6_info * * rt6i_pcpu ; s#rt6_exception_bucket * rt6i_exception_bucket ; }
s#fib6_nh@8a2b5b63 struct fib6_nh { UNKNOWN }
s#fib6_node struct fib6_node { s#fib6_node * parent ; s#fib6_node * left ; s#fib6_node * right ; s#fib6_info * leaf ; t#__u16 fn_bit ; t#__u16 fn_flags ; int fn_sernum ; s#fib6_info * rr_ptr ; s#callback_head rcu ; }
s#fib6_table@9726e4a6 struct fib6_table { UNKNOWN }
s#fib6_table@d9bdc901 struct fib6_table { s#hlist_node tb6_hlist ; t#u32 tb6_id ; t#spinlock_t tb6_lock ; s#fib6_node tb6_root ; s#inet_peer_base tb6_peers ; unsigned int flags ; unsigned int fib_seq ; s#hlist_head tb6_gc_hlist ; }
s#fib_info struct fib_info { s#hlist_node fib_hash ; s#hlist_node fib_lhash ; s#list_head nh_list ; s#net * fib_net ; t#refcount_t fib_treeref ; t#refcount_t fib_clntref ; unsigned int fib_flags ; unsigned char fib_dead ; unsigned char fib_protocol ; unsigned char fib_scope ; unsigned char fib_type ; t#__be32 fib_prefsrc ; t#u32 fib_tb_id ; t#u32 fib_priority ; s#dst_metrics * fib_metrics ; int fib_nhs ; t#bool fib_nh_is_v6 ; t#bool nh_updated ; t#bool pfsrc_removed ; s#nexthop * nh ; s#callback_head rcu ; s#fib_nh fib_nh [ ] ; }
s#fib_kuid_range struct fib_kuid_range { t#kuid_t start ; t#kuid_t end ; }
s#fib_lookup_arg struct fib_lookup_arg { void * lookup_ptr ; const void * lookup_data ; void * result ; s#fib_rule * rule ; t#u32 table ; int flags ; }
s#fib_nh struct fib_nh { s#fib_nh_common nh_common ; s#hlist_node nh_hash ; s#fib_info * nh_parent ; t#__u32 nh_tclassid ; t#__be32 nh_saddr ; int nh_saddr_genid ; }
s#fib_nh_common struct fib_nh_common { s#net_device * nhc_dev ; t#netdevice_tracker nhc_dev_tracker ; int nhc_oif ; unsigned char nhc_scope ; t#u8 nhc_family ; t#u8 nhc_gw_family ; unsigned char nhc_flags ; s#lwtunnel_state * nhc_lwtstate ; union { t#__be32 ipv4 ; s#in6_addr ipv6 ; } nhc_gw ; int nhc_weight ; t#atomic_t nhc_upper_bound ; s#rtable * * nhc_pcpu_rth_output ; s#rtable * nhc_rth_input ; s#fnhe_hash_bucket * nhc_exceptions ; }
s#fib_nh_exception struct fib_nh_exception { s#fib_nh_exception * fnhe_next ; int fnhe_genid ; t#__be32 fnhe_daddr ; t#u32 fnhe_pmtu ; t#bool fnhe_mtu_locked ; t#__be32 fnhe_gw ; unsigned long fnhe_expires ; s#rtable * fnhe_rth_input ; s#rtable * fnhe_rth_output ; unsigned long fnhe_stamp ; s#callback_head rcu ; }
s#fib_notifier_ops@02b05148 struct fib_notifier_ops { UNKNOWN }
s#fib_notifier_ops@09b7d66f struct fib_notifier_ops { int family ; s#list_head list ; unsigned int ( * fib_seq_read ) ( s#net * ) ; int ( * fib_dump ) ( s#net * , s#notifier_block * , s#netlink_ext_ack * ) ; s#module * owner ; s#callback_head rcu ; }
s#fib_rule struct fib_rule { s#list_head list ; int iifindex ; int oifindex ; t#u32 mark ; t#u32 mark_mask ; t#u32 flags ; t#u32 table ; t#u8 action ; t#u8 l3mdev ; t#u8 proto ; t#u8 ip_proto ; t#u32 target ; t#__be64 tun_id ; s#fib_rule * ctarget ; s#net * fr_net ; t#refcount_t refcnt ; t#u32 pref ; int suppress_ifgroup ; int suppress_prefixlen ; char iifname [ 16 ] ; char oifname [ 16 ] ; s#fib_kuid_range uid_range ; s#fib_rule_port_range sport_range ; s#fib_rule_port_range dport_range ; s#callback_head rcu ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; }
s#fib_rule_hdr struct fib_rule_hdr { t#__u8 family ; t#__u8 dst_len ; t#__u8 src_len ; t#__u8 tos ; t#__u8 table ; t#__u8 res1 ; t#__u8 res2 ; t#__u8 action ; t#__u32 flags ; }
s#fib_rule_port_range struct fib_rule_port_range { t#__u16 start ; t#__u16 end ; }
s#fib_rules_ops@306a8a75 struct fib_rules_ops { UNKNOWN }
s#fib_rules_ops@ab0c04da struct fib_rules_ops { int family ; s#list_head list ; int rule_size ; int addr_size ; int unresolved_rules ; int nr_goto_rules ; unsigned int fib_rules_seq ; int ( * action ) ( s#fib_rule * , s#flowi * , int , s#fib_lookup_arg * ) ; t#bool ( * suppress ) ( s#fib_rule * , int , s#fib_lookup_arg * ) ; int ( * match ) ( s#fib_rule * , s#flowi * , int ) ; int ( * configure ) ( s#fib_rule * , s#sk_buff * , s#fib_rule_hdr * , s#nlattr * * , s#netlink_ext_ack * ) ; int ( * delete ) ( s#fib_rule * ) ; int ( * compare ) ( s#fib_rule * , s#fib_rule_hdr * , s#nlattr * * ) ; int ( * fill ) ( s#fib_rule * , s#sk_buff * , s#fib_rule_hdr * ) ; t#size_t ( * nlmsg_payload ) ( s#fib_rule * ) ; void ( * flush_cache ) ( s#fib_rules_ops * ) ; int nlgroup ; s#list_head rules_list ; s#module * owner ; s#net * fro_net ; s#callback_head rcu ; }
s#fib_table@c68738ba struct fib_table { UNKNOWN }
s#fib_table@d7877c9d struct fib_table { s#hlist_node tb_hlist ; t#u32 tb_id ; int tb_num_default ; s#callback_head rcu ; unsigned long * tb_data ; unsigned long __data [ ] ; }
s#fid struct fid { union { struct { t#u32 ino ; t#u32 gen ; t#u32 parent_ino ; t#u32 parent_gen ; } i32 ; struct { t#u64 ino ; t#u32 gen ; } __attribute__ ( ( __packed__ ) ) i64 ; struct { t#u32 block ; t#u16 partref ; t#u16 parent_partref ; t#u32 generation ; t#u32 parent_block ; t#u32 parent_generation ; } udf ; struct { struct { } __empty_raw ; t#__u32 raw [ ] ; } ; } ; }
s#fiemap_extent struct fiemap_extent { t#__u64 fe_logical ; t#__u64 fe_physical ; t#__u64 fe_length ; t#__u64 fe_reserved64 [ 2 ] ; t#__u32 fe_flags ; t#__u32 fe_reserved [ 3 ] ; }
s#fiemap_extent_info@1bed3a83 struct fiemap_extent_info { unsigned int fi_flags ; unsigned int fi_extents_mapped ; unsigned int fi_extents_max ; s#fiemap_extent * fi_extents_start ; }
s#fiemap_extent_info@672844d2 struct fiemap_extent_info { UNKNOWN }
s#file@5dd0e54d struct file { UNKNOWN }
s#file@76e9f396 struct file { t#atomic_long_t f_count ; t#spinlock_t f_lock ; t#fmode_t f_mode ; const s#file_operations * f_op ; s#address_space * f_mapping ; void * private_data ; s#inode * f_inode ; unsigned int f_flags ; unsigned int f_iocb_flags ; const s#cred * f_cred ; s#path f_path ; union { s#mutex f_pos_lock ; t#u64 f_pipe ; } ; t#loff_t f_pos ; void * f_security ; s#fown_struct * f_owner ; t#errseq_t f_wb_err ; t#errseq_t f_sb_err ; s#hlist_head * f_ep ; union { s#callback_head f_task_work ; s#llist_node f_llist ; s#file_ra_state f_ra ; t#freeptr_t f_freeptr ; } ; }
s#file_lease@3afc3356 struct file_lease { UNKNOWN }
s#file_lease@ae8ea715 struct file_lease { s#file_lock_core c ; s#fasync_struct * fl_fasync ; unsigned long fl_break_time ; unsigned long fl_downgrade_time ; const s#lease_manager_operations * fl_lmops ; }
s#file_lock@31a8bf1f struct file_lock { s#file_lock_core c ; t#loff_t fl_start ; t#loff_t fl_end ; const s#file_lock_operations * fl_ops ; const s#lock_manager_operations * fl_lmops ; union { s#nfs_lock_info nfs_fl ; s#nfs4_lock_info nfs4_fl ; struct { s#list_head link ; int state ; unsigned int debug_id ; } afs ; struct { s#inode * inode ; } ceph ; } fl_u ; }
s#file_lock@c34f1df2 struct file_lock { UNKNOWN }
s#file_lock_context@59edc797 struct file_lock_context { UNKNOWN }
s#file_lock_context@787998e9 struct file_lock_context { t#spinlock_t flc_lock ; s#list_head flc_flock ; s#list_head flc_posix ; s#list_head flc_lease ; }
s#file_lock_core struct file_lock_core { s#file_lock_core * flc_blocker ; s#list_head flc_list ; s#hlist_node flc_link ; s#list_head flc_blocked_requests ; s#list_head flc_blocked_member ; t#fl_owner_t flc_owner ; unsigned int flc_flags ; unsigned char flc_type ; t#pid_t flc_pid ; int flc_link_cpu ; t#wait_queue_head_t flc_wait ; s#file * flc_file ; }
s#file_lock_operations struct file_lock_operations { void ( * fl_copy_lock ) ( s#file_lock * , s#file_lock * ) ; void ( * fl_release_private ) ( s#file_lock * ) ; unsigned long uek_reserved1 ; }
s#file_operations struct file_operations { s#module * owner ; t#fop_flags_t fop_flags ; t#loff_t ( * llseek ) ( s#file * , t#loff_t , int ) ; t#ssize_t ( * read ) ( s#file * , char * , t#size_t , t#loff_t * ) ; t#ssize_t ( * write ) ( s#file * , const char * , t#size_t , t#loff_t * ) ; t#ssize_t ( * read_iter ) ( s#kiocb * , s#iov_iter * ) ; t#ssize_t ( * write_iter ) ( s#kiocb * , s#iov_iter * ) ; int ( * iopoll ) ( s#kiocb * , s#io_comp_batch * , unsigned int ) ; int ( * iterate_shared ) ( s#file * , s#dir_context * ) ; t#__poll_t ( * poll ) ( s#file * , s#poll_table_struct * ) ; long ( * unlocked_ioctl ) ( s#file * , unsigned int , unsigned long ) ; long ( * compat_ioctl ) ( s#file * , unsigned int , unsigned long ) ; int ( * mmap ) ( s#file * , s#vm_area_struct * ) ; int ( * open ) ( s#inode * , s#file * ) ; int ( * flush ) ( s#file * , t#fl_owner_t ) ; int ( * release ) ( s#inode * , s#file * ) ; int ( * fsync ) ( s#file * , t#loff_t , t#loff_t , int ) ; int ( * fasync ) ( int , s#file * , int ) ; int ( * lock ) ( s#file * , int , s#file_lock * ) ; unsigned long ( * get_unmapped_area ) ( s#file * , unsigned long , unsigned long , unsigned long , unsigned long ) ; int ( * check_flags ) ( int ) ; int ( * flock ) ( s#file * , int , s#file_lock * ) ; t#ssize_t ( * splice_write ) ( s#pipe_inode_info * , s#file * , t#loff_t * , t#size_t , unsigned int ) ; t#ssize_t ( * splice_read ) ( s#file * , t#loff_t * , s#pipe_inode_info * , t#size_t , unsigned int ) ; void ( * splice_eof ) ( s#file * ) ; int ( * setlease ) ( s#file * , int , s#file_lease * * , void * * ) ; long ( * fallocate ) ( s#file * , int , t#loff_t , t#loff_t ) ; void ( * show_fdinfo ) ( s#seq_file * , s#file * ) ; t#ssize_t ( * copy_file_range ) ( s#file * , t#loff_t , s#file * , t#loff_t , t#size_t , unsigned int ) ; t#loff_t ( * remap_file_range ) ( s#file * , t#loff_t , s#file * , t#loff_t , t#loff_t , unsigned int ) ; int ( * fadvise ) ( s#file * , t#loff_t , t#loff_t , int ) ; int ( * uring_cmd ) ( s#io_uring_cmd * , unsigned int ) ; int ( * uring_cmd_iopoll ) ( s#io_uring_cmd * , s#io_comp_batch * , unsigned int ) ; }
s#file_ra_state struct file_ra_state { unsigned long start ; unsigned int size ; unsigned int async_size ; unsigned int ra_pages ; unsigned int mmap_miss ; t#loff_t prev_pos ; }
s#file_system_type struct file_system_type { const char * name ; int fs_flags ; int ( * init_fs_context ) ( s#fs_context * ) ; const s#fs_parameter_spec * parameters ; s#dentry * ( * mount ) ( s#file_system_type * , int , const char * , void * ) ; void ( * kill_sb ) ( s#super_block * ) ; s#module * owner ; s#file_system_type * next ; s#hlist_head fs_supers ; s#lock_class_key s_lock_key ; s#lock_class_key s_umount_key ; s#lock_class_key s_vfs_rename_key ; s#lock_class_key s_writers_key [ ( E#SB_FREEZE_COMPLETE - 1 ) ] ; s#lock_class_key i_lock_key ; s#lock_class_key i_mutex_key ; s#lock_class_key invalidate_lock_key ; s#lock_class_key i_mutex_dir_key ; }
s#fileattr@44f677b4 struct fileattr { UNKNOWN }
s#fileattr@8d2befb0 struct fileattr { t#u32 flags ; t#u32 fsx_xflags ; t#u32 fsx_extsize ; t#u32 fsx_nextents ; t#u32 fsx_projid ; t#u32 fsx_cowextsize ; t#bool flags_valid : 1 ; t#bool fsx_valid : 1 ; }
s#filename struct filename { const char * name ; const char * uptr ; t#atomic_t refcnt ; s#audit_names * aname ; const char iname [ ] ; }
s#files_struct@8536a667 struct files_struct { UNKNOWN }
s#files_struct@bbbe635b struct files_struct { t#atomic_t count ; t#bool resize_in_progress ; t#wait_queue_head_t resize_wait ; s#fdtable * fdt ; s#fdtable fdtab ; t#spinlock_t file_lock __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; unsigned int next_fd ; unsigned long close_on_exec_init [ 1 ] ; unsigned long open_fds_init [ 1 ] ; unsigned long full_fds_bits_init [ 1 ] ; s#file * fd_array [ 64 ] ; }
s#firmware@118f7c0d struct firmware { t#size_t size ; const t#u8 * data ; void * priv ; }
s#firmware@794c6bd5 struct firmware { UNKNOWN }
s#flow_action struct flow_action { unsigned int num_entries ; s#flow_action_entry entries [ ] ; }
s#flow_action_cookie struct flow_action_cookie { t#u32 cookie_len ; t#u8 cookie [ ] ; }
s#flow_action_entry struct flow_action_entry { e#flow_action_id id ; t#u32 hw_index ; unsigned long cookie ; t#u64 miss_cookie ; e#flow_action_hw_stats hw_stats ; t#action_destr destructor ; void * destructor_priv ; union { t#u32 chain_index ; s#net_device * dev ; struct { t#u16 vid ; t#__be16 proto ; t#u8 prio ; } vlan ; struct { unsigned char dst [ 6 ] ; unsigned char src [ 6 ] ; } vlan_push_eth ; struct { e#flow_action_mangle_base htype ; t#u32 offset ; t#u32 mask ; t#u32 val ; } mangle ; s#ip_tunnel_info * tunnel ; t#u32 csum_flags ; t#u32 mark ; t#u16 ptype ; t#u16 rx_queue ; t#u32 priority ; struct { t#u32 ctx ; t#u32 index ; t#u8 vf ; } queue ; struct { s#psample_group * psample_group ; t#u32 rate ; t#u32 trunc_size ; t#bool truncate ; } sample ; struct { t#u32 burst ; t#u64 rate_bytes_ps ; t#u64 peakrate_bytes_ps ; t#u32 avrate ; t#u16 overhead ; t#u64 burst_pkt ; t#u64 rate_pkt_ps ; t#u32 mtu ; struct { e#flow_action_id act_id ; t#u32 extval ; } exceed , notexceed ; } police ; struct { int action ; t#u16 zone ; s#nf_flowtable * flow_table ; } ct ; struct { unsigned long cookie ; t#u32 mark ; t#u32 labels [ 4 ] ; t#bool orig_dir ; } ct_metadata ; struct { t#u32 label ; t#__be16 proto ; t#u8 tc ; t#u8 bos ; t#u8 ttl ; } mpls_push ; struct { t#__be16 proto ; } mpls_pop ; struct { t#u32 label ; t#u8 tc ; t#u8 bos ; t#u8 ttl ; } mpls_mangle ; struct { t#s32 prio ; t#u64 basetime ; t#u64 cycletime ; t#u64 cycletimeext ; t#u32 num_entries ; s#action_gate_entry * entries ; } gate ; struct { t#u16 sid ; } pppoe ; } ; s#flow_action_cookie * user_cookie ; }
s#flow_block struct flow_block { s#list_head cb_list ; }
s#flow_cls_common_offload struct flow_cls_common_offload { t#u32 chain_index ; t#__be16 protocol ; t#u32 prio ; s#netlink_ext_ack * extack ; }
s#flow_cls_offload struct flow_cls_offload { s#flow_cls_common_offload common ; e#flow_cls_command command ; t#bool use_act_stats ; unsigned long cookie ; s#flow_rule * rule ; s#flow_stats stats ; t#u32 classid ; }
s#flow_dissector struct flow_dissector { unsigned long long used_keys ; unsigned short int offset [ E#FLOW_DISSECTOR_KEY_MAX ] ; }
s#flow_dissector_key_basic struct flow_dissector_key_basic { t#__be16 n_proto ; t#u8 ip_proto ; t#u8 padding ; }
s#flow_dissector_key_control struct flow_dissector_key_control { t#u16 thoff ; t#u16 addr_type ; t#u32 flags ; }
s#flow_dissector_key_ipv4_addrs struct flow_dissector_key_ipv4_addrs { t#__be32 src ; t#__be32 dst ; }
s#flow_dissector_key_ipv6_addrs struct flow_dissector_key_ipv6_addrs { s#in6_addr src ; s#in6_addr dst ; }
s#flow_dissector_key_keyid struct flow_dissector_key_keyid { t#__be32 keyid ; }
s#flow_dissector_key_meta struct flow_dissector_key_meta { int ingress_ifindex ; t#u16 ingress_iftype ; t#u8 l2_miss ; }
s#flow_dissector_key_ports struct flow_dissector_key_ports { union { t#__be32 ports ; struct { t#__be16 src ; t#__be16 dst ; } ; } ; }
s#flow_dissector_key_tcp struct flow_dissector_key_tcp { t#__be16 flags ; }
s#flow_dissector_key_vlan struct flow_dissector_key_vlan { union { struct { t#u16 vlan_id : 12 , vlan_dei : 1 , vlan_priority : 3 ; } ; t#__be16 vlan_tci ; } ; t#__be16 vlan_tpid ; t#__be16 vlan_eth_type ; t#u16 padding ; }
s#flow_match struct flow_match { s#flow_dissector * dissector ; void * mask ; void * key ; }
s#flow_offload struct flow_offload { s#flow_offload_tuple_rhash tuplehash [ E#IP_CT_DIR_MAX ] ; s#nf_conn * ct ; unsigned long flags ; t#u16 type ; t#u32 timeout ; s#callback_head callback_head ; }
s#flow_offload_tuple struct flow_offload_tuple { union { s#in_addr src_v4 ; s#in6_addr src_v6 ; } ; union { s#in_addr dst_v4 ; s#in6_addr dst_v6 ; } ; struct { t#__be16 src_port ; t#__be16 dst_port ; } ; int iifidx ; t#u8 l3proto ; t#u8 l4proto ; struct { t#u16 id ; t#__be16 proto ; } encap [ 2 ] ; struct { } __hash ; t#u8 dir : 2 , xmit_type : 3 , encap_num : 2 , in_vlan_ingress : 2 ; t#u16 mtu ; union { struct { s#dst_entry * dst_cache ; t#u32 dst_cookie ; } ; struct { t#u32 ifidx ; t#u32 hw_ifidx ; t#u8 h_source [ 6 ] ; t#u8 h_dest [ 6 ] ; } out ; struct { t#u32 iifidx ; } tc ; } ; }
s#flow_offload_tuple_rhash struct flow_offload_tuple_rhash { s#rhash_head node ; s#flow_offload_tuple tuple ; }
s#flow_rule struct flow_rule { s#flow_match match ; s#flow_action action ; }
s#flow_stats struct flow_stats { t#u64 pkts ; t#u64 bytes ; t#u64 drops ; t#u64 lastused ; e#flow_action_hw_stats used_hw_stats ; t#bool used_hw_stats_valid ; }
s#flowi struct flowi { union { s#flowi_common __fl_common ; s#flowi4 ip4 ; s#flowi6 ip6 ; } u ; }
s#flowi4 struct flowi4 { s#flowi_common __fl_common ; t#__be32 saddr ; t#__be32 daddr ; u#flowi_uli uli ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#flowi6 struct flowi6 { s#flowi_common __fl_common ; s#in6_addr daddr ; s#in6_addr saddr ; t#__be32 flowlabel ; u#flowi_uli uli ; t#__u32 mp_hash ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#flowi_common struct flowi_common { int flowic_oif ; int flowic_iif ; int flowic_l3mdev ; t#__u32 flowic_mark ; t#__u8 flowic_tos ; t#__u8 flowic_scope ; t#__u8 flowic_proto ; t#__u8 flowic_flags ; t#__u32 flowic_secid ; t#kuid_t flowic_uid ; t#__u32 flowic_multipath_hash ; s#flowi_tunnel flowic_tun_key ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#flowi_tunnel struct flowi_tunnel { t#__be64 tun_id ; }
s#flush_tlb_info struct flush_tlb_info { s#mm_struct * mm ; unsigned long start ; unsigned long end ; t#u64 new_tlb_gen ; unsigned int initiating_cpu ; t#u8 stride_shift ; t#u8 freed_tables ; t#u8 trim_cpumask ; }
s#fnhe_hash_bucket struct fnhe_hash_bucket { s#fib_nh_exception * chain ; }
s#folio struct folio { union { struct { unsigned long flags ; union { s#list_head lru ; struct { void * __filler ; unsigned int mlock_count ; } ; } ; s#address_space * mapping ; unsigned long index ; union { void * private ; t#swp_entry_t swap ; } ; t#atomic_t _mapcount ; t#atomic_t _refcount ; unsigned long memcg_data ; } ; s#page page ; } ; union { struct { unsigned long _flags_1 ; unsigned long _head_1 ; t#atomic_t _large_mapcount ; t#atomic_t _entire_mapcount ; t#atomic_t _nr_pages_mapped ; t#atomic_t _pincount ; unsigned int _folio_nr_pages ; } ; s#page __page_1 ; } ; union { struct { unsigned long _flags_2 ; unsigned long _head_2 ; void * _hugetlb_subpool ; void * _hugetlb_cgroup ; void * _hugetlb_cgroup_rsvd ; void * _hugetlb_hwpoison ; } ; struct { unsigned long _flags_2a ; unsigned long _head_2a ; s#list_head _deferred_list ; } ; s#page __page_2 ; } ; }
s#folio_batch struct folio_batch { unsigned char nr ; unsigned char i ; t#bool percpu_pvec_drained ; s#folio * folios [ 31 ] ; }
s#folio_queue@17dee850 struct folio_queue { UNKNOWN }
s#folio_queue@29d56ea4 struct folio_queue { s#folio_batch vec ; t#u8 orders [ 31 ] ; s#folio_queue * next ; s#folio_queue * prev ; unsigned long marks ; unsigned long marks2 ; unsigned long marks3 ; }
s#fown_struct struct fown_struct { s#file * file ; t#rwlock_t lock ; s#pid * pid ; e#pid_type pid_type ; t#kuid_t uid , euid ; int signum ; }
s#fprop_global struct fprop_global { s#percpu_counter events ; unsigned int period ; t#seqcount_t sequence ; }
s#fprop_local_percpu struct fprop_local_percpu { s#percpu_counter events ; unsigned int period ; t#raw_spinlock_t lock ; }
s#fpstate struct fpstate { unsigned int size ; unsigned int user_size ; t#u64 xfeatures ; t#u64 user_xfeatures ; t#u64 xfd ; unsigned int is_valloc : 1 ; unsigned int is_guest : 1 ; unsigned int is_confidential : 1 ; unsigned int in_use : 1 ; u#fpregs_state regs ; }
s#fpu struct fpu { unsigned int last_cpu ; unsigned long avx512_timestamp ; s#fpstate * fpstate ; s#fpstate * __task_fpstate ; s#fpu_state_perm perm ; s#fpu_state_perm guest_perm ; unsigned long uek_reserved1 ; s#fpstate __fpstate ; }
s#fpu_state_perm struct fpu_state_perm { t#u64 __state_perm ; unsigned int __state_size ; unsigned int __user_state_size ; }
s#fqdir struct fqdir { long high_thresh ; long low_thresh ; int timeout ; int max_dist ; s#inet_frags * f ; s#net * net ; t#bool dead ; s#rhashtable rhashtable __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; t#atomic_long_t mem __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; s#work_struct destroy_work ; s#llist_node free_list ; }
s#frag_v4_compare_key struct frag_v4_compare_key { t#__be32 saddr ; t#__be32 daddr ; t#u32 user ; t#u32 vif ; t#__be16 id ; t#u16 protocol ; }
s#frag_v6_compare_key struct frag_v6_compare_key { s#in6_addr saddr ; s#in6_addr daddr ; t#u32 user ; t#__be32 id ; t#u32 iif ; }
s#fred_cs struct fred_cs { t#u64 cs : 16 , sl : 2 , wfe : 1 , : 45 ; }
s#fred_ss struct fred_ss { t#u64 ss : 16 , sti : 1 , swevent : 1 , nmi : 1 , : 13 , vector : 8 , : 8 , type : 4 , : 4 , enclave : 1 , lm : 1 , nested : 1 , : 1 , insnlen : 4 ; }
s#free_area struct free_area { s#list_head free_list [ E#MIGRATE_TYPES ] ; unsigned long nr_free ; }
s#fregs_state struct fregs_state { t#u32 cwd ; t#u32 swd ; t#u32 twd ; t#u32 fip ; t#u32 fcs ; t#u32 foo ; t#u32 fos ; t#u32 st_space [ 20 ] ; t#u32 status ; }
s#freq_constraints struct freq_constraints { s#pm_qos_constraints min_freq ; s#blocking_notifier_head min_freq_notifiers ; s#pm_qos_constraints max_freq ; s#blocking_notifier_head max_freq_notifiers ; }
s#freq_qos_request struct freq_qos_request { e#freq_qos_req_type type ; s#plist_node pnode ; s#freq_constraints * qos ; }
s#fs_context@dc4237ee struct fs_context { UNKNOWN }
s#fs_context@e8c933d7 struct fs_context { const s#fs_context_operations * ops ; s#mutex uapi_mutex ; s#file_system_type * fs_type ; void * fs_private ; void * sget_key ; s#dentry * root ; s#user_namespace * user_ns ; s#net * net_ns ; const s#cred * cred ; s#p_log log ; const char * source ; void * security ; void * s_fs_info ; unsigned int sb_flags ; unsigned int sb_flags_mask ; unsigned int s_iflags ; e#fs_context_purpose purpose : 8 ; e#fs_context_phase phase : 8 ; t#bool need_free : 1 ; t#bool global : 1 ; t#bool oldapi : 1 ; t#bool exclusive : 1 ; }
s#fs_context_operations struct fs_context_operations { void ( * free ) ( s#fs_context * ) ; int ( * dup ) ( s#fs_context * , s#fs_context * ) ; int ( * parse_param ) ( s#fs_context * , s#fs_parameter * ) ; int ( * parse_monolithic ) ( s#fs_context * , void * ) ; int ( * get_tree ) ( s#fs_context * ) ; int ( * reconfigure ) ( s#fs_context * ) ; }
s#fs_parameter struct fs_parameter { const char * key ; e#fs_value_type type : 8 ; union { char * string ; void * blob ; s#filename * name ; s#file * file ; } ; t#size_t size ; int dirfd ; }
s#fs_parameter_spec@2dfde979 struct fs_parameter_spec { UNKNOWN }
s#fs_parameter_spec@30a833e5 struct fs_parameter_spec { const char * name ; t#fs_param_type * type ; t#u8 opt ; unsigned short flags ; const void * data ; }
s#fs_parse_result struct fs_parse_result { t#bool negated ; union { t#bool boolean ; int int_32 ; unsigned int uint_32 ; t#u64 uint_64 ; t#kuid_t uid ; t#kgid_t gid ; } ; }
s#fs_pin@7d6db402 struct fs_pin { t#wait_queue_head_t wait ; int done ; s#hlist_node s_list ; s#hlist_node m_list ; void ( * kill ) ( s#fs_pin * ) ; }
s#fs_pin@cb017644 struct fs_pin { UNKNOWN }
s#fs_struct@9466df19 struct fs_struct { int users ; t#spinlock_t lock ; t#seqcount_spinlock_t seq ; int umask ; int in_exec ; s#path root , pwd ; }
s#fs_struct@b5890d40 struct fs_struct { UNKNOWN }
s#fscache_cache@165d89b6 struct fscache_cache { UNKNOWN }
s#fscache_cache@8b118a69 struct fscache_cache { const s#fscache_cache_ops * ops ; s#list_head cache_link ; void * cache_priv ; t#refcount_t ref ; t#atomic_t n_volumes ; t#atomic_t n_accesses ; t#atomic_t object_count ; unsigned int debug_id ; e#fscache_cache_state state ; char * name ; }
s#fscache_cache_ops struct fscache_cache_ops { const char * name ; void ( * acquire_volume ) ( s#fscache_volume * ) ; void ( * free_volume ) ( s#fscache_volume * ) ; t#bool ( * lookup_cookie ) ( s#fscache_cookie * ) ; void ( * withdraw_cookie ) ( s#fscache_cookie * ) ; void ( * resize_cookie ) ( s#netfs_cache_resources * , t#loff_t ) ; t#bool ( * invalidate_cookie ) ( s#fscache_cookie * ) ; t#bool ( * begin_operation ) ( s#netfs_cache_resources * , e#fscache_want_state ) ; void ( * prepare_to_write ) ( s#fscache_cookie * ) ; }
s#fscache_cookie@0084e53b struct fscache_cookie { UNKNOWN }
s#fscache_cookie@2ae8c4bb struct fscache_cookie { t#refcount_t ref ; t#atomic_t n_active ; t#atomic_t n_accesses ; unsigned int debug_id ; unsigned int inval_counter ; t#spinlock_t lock ; s#fscache_volume * volume ; void * cache_priv ; s#hlist_bl_node hash_link ; s#list_head proc_link ; s#list_head commit_link ; s#work_struct work ; t#loff_t object_size ; unsigned long unused_at ; unsigned long flags ; e#fscache_cookie_state state ; t#u8 advice ; t#u8 key_len ; t#u8 aux_len ; t#u32 key_hash ; union { void * key ; t#u8 inline_key [ 16 ] ; } ; union { void * aux ; t#u8 inline_aux [ 8 ] ; } ; }
s#fscache_volume@825f858c struct fscache_volume { t#refcount_t ref ; t#atomic_t n_cookies ; t#atomic_t n_accesses ; unsigned int debug_id ; unsigned int key_hash ; t#u8 * key ; s#list_head proc_link ; s#hlist_bl_node hash_link ; s#work_struct work ; s#fscache_cache * cache ; void * cache_priv ; t#spinlock_t lock ; unsigned long flags ; t#u8 coherency_len ; t#u8 coherency [ ] ; }
s#fscache_volume@a76a6182 struct fscache_volume { UNKNOWN }
s#fscrypt_direct_key struct fscrypt_direct_key { UNKNOWN }
s#fscrypt_hkdf struct fscrypt_hkdf { s#crypto_shash * hmac_tfm ; }
s#fscrypt_inode_info@65e93c4c struct fscrypt_inode_info { UNKNOWN }
s#fscrypt_inode_info@740e3848 struct fscrypt_inode_info { s#fscrypt_prepared_key ci_enc_key ; t#u8 ci_owns_key : 1 ; t#u8 ci_dirhash_key_initialized : 1 ; t#u8 ci_data_unit_bits ; t#u8 ci_data_units_per_block_bits ; t#u32 ci_hashed_ino ; s#fscrypt_mode * ci_mode ; s#inode * ci_inode ; s#fscrypt_master_key * ci_master_key ; s#list_head ci_master_key_link ; s#fscrypt_direct_key * ci_direct_key ; t#siphash_key_t ci_dirhash_key ; u#fscrypt_policy ci_policy ; t#u8 ci_nonce [ 16 ] ; }
s#fscrypt_key_specifier struct fscrypt_key_specifier { t#__u32 type ; t#__u32 __reserved ; union { t#__u8 __reserved [ 32 ] ; t#__u8 descriptor [ 8 ] ; t#__u8 identifier [ 16 ] ; } u ; }
s#fscrypt_keyring struct fscrypt_keyring { UNKNOWN }
s#fscrypt_master_key struct fscrypt_master_key { s#hlist_node mk_node ; s#rw_semaphore mk_sem ; t#refcount_t mk_active_refs ; t#refcount_t mk_struct_refs ; s#callback_head mk_rcu_head ; s#fscrypt_master_key_secret mk_secret ; s#fscrypt_key_specifier mk_spec ; s#key * mk_users ; s#list_head mk_decrypted_inodes ; t#spinlock_t mk_decrypted_inodes_lock ; s#fscrypt_prepared_key mk_direct_keys [ 10 + 1 ] ; s#fscrypt_prepared_key mk_iv_ino_lblk_64_keys [ 10 + 1 ] ; s#fscrypt_prepared_key mk_iv_ino_lblk_32_keys [ 10 + 1 ] ; t#siphash_key_t mk_ino_hash_key ; t#bool mk_ino_hash_key_initialized ; t#bool mk_present ; }
s#fscrypt_master_key_secret struct fscrypt_master_key_secret { s#fscrypt_hkdf hkdf ; t#u32 size ; t#u8 raw [ 64 ] ; }
s#fscrypt_mode struct fscrypt_mode { const char * friendly_name ; const char * cipher_str ; int keysize ; int security_strength ; int ivsize ; int logged_cryptoapi_impl ; int logged_blk_crypto_native ; int logged_blk_crypto_fallback ; e#blk_crypto_mode_num blk_crypto_mode ; }
s#fscrypt_operations@8c0aa70b struct fscrypt_operations { UNKNOWN }
s#fscrypt_operations@af8f736c struct fscrypt_operations { unsigned int needs_bounce_pages : 1 ; unsigned int has_32bit_inodes : 1 ; unsigned int supports_subblock_data_units : 1 ; const char * legacy_key_prefix ; int ( * get_context ) ( s#inode * , void * , t#size_t ) ; int ( * set_context ) ( s#inode * , const void * , t#size_t , void * ) ; const u#fscrypt_policy * ( * get_dummy_policy ) ( s#super_block * ) ; t#bool ( * empty_dir ) ( s#inode * ) ; t#bool ( * has_stable_inodes ) ( s#super_block * ) ; s#block_device * * ( * get_devices ) ( s#super_block * , unsigned int * ) ; }
s#fscrypt_policy_v1 struct fscrypt_policy_v1 { t#__u8 version ; t#__u8 contents_encryption_mode ; t#__u8 filenames_encryption_mode ; t#__u8 flags ; t#__u8 master_key_descriptor [ 8 ] ; }
s#fscrypt_policy_v2 struct fscrypt_policy_v2 { t#__u8 version ; t#__u8 contents_encryption_mode ; t#__u8 filenames_encryption_mode ; t#__u8 flags ; t#__u8 log2_data_unit_size ; t#__u8 __reserved [ 3 ] ; t#__u8 master_key_identifier [ 16 ] ; }
s#fscrypt_prepared_key struct fscrypt_prepared_key { s#crypto_skcipher * tfm ; }
s#fsnotify_mark_connector@1e0318bf struct fsnotify_mark_connector { UNKNOWN }
s#fsnotify_mark_connector@d56ec019 struct fsnotify_mark_connector { t#spinlock_t lock ; unsigned char type ; unsigned char prio ; unsigned short flags ; union { void * obj ; s#fsnotify_mark_connector * destroy_next ; } ; s#hlist_head list ; }
s#fsnotify_sb_info@1ef4c56a struct fsnotify_sb_info { s#fsnotify_mark_connector * sb_marks ; t#atomic_long_t watched_objects [ E#__FSNOTIFY_PRIO_NUM ] ; }
s#fsnotify_sb_info@c7b3898e struct fsnotify_sb_info { UNKNOWN }
s#fsverity_hash_alg struct fsverity_hash_alg { s#crypto_shash * tfm ; const char * name ; unsigned int digest_size ; unsigned int block_size ; e#hash_algo algo_id ; }
s#fsverity_info@02697142 struct fsverity_info { s#merkle_tree_params tree_params ; t#u8 root_hash [ 64 ] ; t#u8 file_digest [ 64 ] ; const s#inode * inode ; unsigned long * hash_block_verified ; }
s#fsverity_info@ecc2a868 struct fsverity_info { UNKNOWN }
s#fsverity_operations@32f16975 struct fsverity_operations { int ( * begin_enable_verity ) ( s#file * ) ; int ( * end_enable_verity ) ( s#file * , const void * , t#size_t , t#u64 ) ; int ( * get_verity_descriptor ) ( s#inode * , void * , t#size_t ) ; s#page * ( * read_merkle_tree_page ) ( s#inode * , unsigned long , unsigned long ) ; int ( * write_merkle_tree_block ) ( s#inode * , const void * , t#u64 , unsigned int ) ; }
s#fsverity_operations@ba45af4c struct fsverity_operations { UNKNOWN }
s#ftrace_graph_ent struct ftrace_graph_ent { unsigned long func ; int depth ; }
s#ftrace_graph_ret struct ftrace_graph_ret { unsigned long func ; unsigned long retval ; int depth ; unsigned int overrun ; unsigned long long calltime ; unsigned long long rettime ; }
s#ftrace_hash@302dc061 struct ftrace_hash { UNKNOWN }
s#ftrace_hash@738615b3 struct ftrace_hash { unsigned long size_bits ; s#hlist_head * buckets ; unsigned long count ; unsigned long flags ; s#callback_head rcu ; }
s#ftrace_ops@393d5fad struct ftrace_ops { t#ftrace_func_t func ; s#ftrace_ops * next ; unsigned long flags ; void * private ; t#ftrace_func_t saved_func ; s#ftrace_ops_hash local_hash ; s#ftrace_ops_hash * func_hash ; s#ftrace_ops_hash old_hash ; unsigned long trampoline ; unsigned long trampoline_size ; s#list_head list ; s#list_head subop_list ; t#ftrace_ops_func_t ops_func ; s#ftrace_ops * managed ; unsigned long direct_call ; }
s#ftrace_ops@83508898 struct ftrace_ops { UNKNOWN }
s#ftrace_ops_hash struct ftrace_ops_hash { s#ftrace_hash * notrace_hash ; s#ftrace_hash * filter_hash ; s#mutex regex_lock ; }
s#ftrace_regs struct ftrace_regs { s#pt_regs regs ; }
s#futex_pi_state struct futex_pi_state { UNKNOWN }
s#fwnode_endpoint struct fwnode_endpoint { unsigned int port ; unsigned int id ; const s#fwnode_handle * local_fwnode ; }
s#fwnode_handle@a449eb34 struct fwnode_handle { UNKNOWN }
s#fwnode_handle@f1692138 struct fwnode_handle { s#fwnode_handle * secondary ; const s#fwnode_operations * ops ; s#device * dev ; s#list_head suppliers ; s#list_head consumers ; t#u8 flags ; }
s#fwnode_operations struct fwnode_operations { s#fwnode_handle * ( * get ) ( s#fwnode_handle * ) ; void ( * put ) ( s#fwnode_handle * ) ; t#bool ( * device_is_available ) ( const s#fwnode_handle * ) ; const void * ( * device_get_match_data ) ( const s#fwnode_handle * , const s#device * ) ; t#bool ( * device_dma_supported ) ( const s#fwnode_handle * ) ; e#dev_dma_attr ( * device_get_dma_attr ) ( const s#fwnode_handle * ) ; t#bool ( * property_present ) ( const s#fwnode_handle * , const char * ) ; int ( * property_read_int_array ) ( const s#fwnode_handle * , const char * , unsigned int , void * , t#size_t ) ; int ( * property_read_string_array ) ( const s#fwnode_handle * , const char * , const char * * , t#size_t ) ; const char * ( * get_name ) ( const s#fwnode_handle * ) ; const char * ( * get_name_prefix ) ( const s#fwnode_handle * ) ; s#fwnode_handle * ( * get_parent ) ( const s#fwnode_handle * ) ; s#fwnode_handle * ( * get_next_child_node ) ( const s#fwnode_handle * , s#fwnode_handle * ) ; s#fwnode_handle * ( * get_named_child_node ) ( const s#fwnode_handle * , const char * ) ; int ( * get_reference_args ) ( const s#fwnode_handle * , const char * , const char * , unsigned int , unsigned int , s#fwnode_reference_args * ) ; s#fwnode_handle * ( * graph_get_next_endpoint ) ( const s#fwnode_handle * , s#fwnode_handle * ) ; s#fwnode_handle * ( * graph_get_remote_endpoint ) ( const s#fwnode_handle * ) ; s#fwnode_handle * ( * graph_get_port_parent ) ( s#fwnode_handle * ) ; int ( * graph_parse_endpoint ) ( const s#fwnode_handle * , s#fwnode_endpoint * ) ; void * ( * iomap ) ( s#fwnode_handle * , int ) ; int ( * irq_get ) ( const s#fwnode_handle * , unsigned int ) ; int ( * add_links ) ( s#fwnode_handle * ) ; }
s#fwnode_reference_args@b4532ede struct fwnode_reference_args { s#fwnode_handle * fwnode ; unsigned int nargs ; t#u64 args [ 8 ] ; }
s#fwnode_reference_args@c3eb1015 struct fwnode_reference_args { UNKNOWN }
s#fxregs_state struct fxregs_state { t#u16 cwd ; t#u16 swd ; t#u16 twd ; t#u16 fop ; union { struct { t#u64 rip ; t#u64 rdp ; } ; struct { t#u32 fip ; t#u32 fcs ; t#u32 foo ; t#u32 fos ; } ; } ; t#u32 mxcsr ; t#u32 mxcsr_mask ; t#u32 st_space [ 32 ] ; t#u32 xmm_space [ 64 ] ; t#u32 padding [ 12 ] ; union { t#u32 padding1 [ 12 ] ; t#u32 sw_reserved [ 12 ] ; } ; }
s#garp_applicant struct garp_applicant { s#garp_application * app ; s#net_device * dev ; s#timer_list join_timer ; t#spinlock_t lock ; s#sk_buff_head queue ; s#sk_buff * pdu ; s#rb_root gid ; s#callback_head rcu ; }
s#garp_application struct garp_application { e#garp_applications type ; unsigned int maxattr ; s#stp_proto proto ; }
s#garp_port@710646f2 struct garp_port { s#garp_applicant * applicants [ ( E#__GARP_APPLICATION_MAX - 1 ) + 1 ] ; s#callback_head rcu ; }
s#garp_port@d7d34070 struct garp_port { UNKNOWN }
s#gate_struct struct gate_struct { t#u16 offset_low ; t#u16 segment ; s#idt_bits bits ; t#u16 offset_middle ; t#u32 offset_high ; t#u32 reserved ; }
s#gendisk@89751274 struct gendisk { int major ; int first_minor ; int minors ; char disk_name [ 32 ] ; unsigned short events ; unsigned short event_flags ; s#xarray part_tbl ; s#block_device * part0 ; const s#block_device_operations * fops ; s#request_queue * queue ; void * private_data ; s#bio_set bio_split ; int flags ; unsigned long state ; s#mutex open_mutex ; unsigned open_partitions ; s#backing_dev_info * bdi ; s#kobject queue_kobj ; s#kobject * slave_dir ; s#list_head slave_bdevs ; s#timer_rand_state * random ; t#atomic_t sync_io ; s#disk_events * ev ; unsigned int nr_zones ; unsigned int zone_capacity ; unsigned int last_zone_capacity ; unsigned long * conv_zones_bitmap ; unsigned int zone_wplugs_hash_bits ; t#atomic_t nr_zone_wplugs ; t#spinlock_t zone_wplugs_lock ; s#mempool_s * zone_wplugs_pool ; s#hlist_head * zone_wplugs_hash ; s#workqueue_struct * zone_wplugs_wq ; s#cdrom_device_info * cdi ; int node_id ; s#badblocks * bb ; s#lockdep_map lockdep_map ; t#u64 diskseq ; t#blk_mode_t open_mode ; s#blk_independent_access_ranges * ia_ranges ; }
s#gendisk@e24151d3 struct gendisk { UNKNOWN }
s#gnet_dump struct gnet_dump { t#spinlock_t * lock ; s#sk_buff * skb ; s#nlattr * tail ; int compat_tc_stats ; int compat_xstats ; int padattr ; void * xstats ; int xstats_len ; s#tc_stats tc_stats ; }
s#gnet_stats_basic_sync struct gnet_stats_basic_sync { t#u64_stats_t bytes ; t#u64_stats_t packets ; s#u64_stats_sync syncp ; }
s#gnet_stats_queue struct gnet_stats_queue { t#__u32 qlen ; t#__u32 backlog ; t#__u32 drops ; t#__u32 requeues ; t#__u32 overlimits ; }
s#gpio_chip struct gpio_chip { const char * label ; s#gpio_device * gpiodev ; s#device * parent ; s#fwnode_handle * fwnode ; s#module * owner ; int ( * request ) ( s#gpio_chip * , unsigned int ) ; void ( * free ) ( s#gpio_chip * , unsigned int ) ; int ( * get_direction ) ( s#gpio_chip * , unsigned int ) ; int ( * direction_input ) ( s#gpio_chip * , unsigned int ) ; int ( * direction_output ) ( s#gpio_chip * , unsigned int , int ) ; int ( * get ) ( s#gpio_chip * , unsigned int ) ; int ( * get_multiple ) ( s#gpio_chip * , unsigned long * , unsigned long * ) ; void ( * set ) ( s#gpio_chip * , unsigned int , int ) ; void ( * set_multiple ) ( s#gpio_chip * , unsigned long * , unsigned long * ) ; int ( * set_config ) ( s#gpio_chip * , unsigned int , unsigned long ) ; int ( * to_irq ) ( s#gpio_chip * , unsigned int ) ; void ( * dbg_show ) ( s#seq_file * , s#gpio_chip * ) ; int ( * init_valid_mask ) ( s#gpio_chip * , unsigned long * , unsigned int ) ; int ( * add_pin_ranges ) ( s#gpio_chip * ) ; int ( * en_hw_timestamp ) ( s#gpio_chip * , t#u32 , unsigned long ) ; int ( * dis_hw_timestamp ) ( s#gpio_chip * , t#u32 , unsigned long ) ; int base ; t#u16 ngpio ; t#u16 offset ; const char * const * names ; t#bool can_sleep ; unsigned long ( * read_reg ) ( void * ) ; void ( * write_reg ) ( void * , unsigned long ) ; t#bool be_bits ; void * reg_dat ; void * reg_set ; void * reg_clr ; void * reg_dir_out ; void * reg_dir_in ; t#bool bgpio_dir_unreadable ; int bgpio_bits ; t#raw_spinlock_t bgpio_lock ; unsigned long bgpio_data ; unsigned long bgpio_dir ; s#gpio_irq_chip irq ; unsigned long * valid_mask ; }
s#gpio_desc@62750c11 struct gpio_desc { s#gpio_device * gdev ; unsigned long flags ; s#gpio_desc_label * label ; const char * name ; }
s#gpio_desc@b1bba9b1 struct gpio_desc { UNKNOWN }
s#gpio_desc_label struct gpio_desc_label { s#callback_head rh ; char str [ ] ; }
s#gpio_device@888eb96e struct gpio_device { UNKNOWN }
s#gpio_device@926f494e struct gpio_device { s#device dev ; s#cdev chrdev ; int id ; s#device * mockdev ; s#module * owner ; s#gpio_chip * chip ; s#gpio_desc * descs ; s#srcu_struct desc_srcu ; unsigned int base ; t#u16 ngpio ; t#bool can_sleep ; const char * label ; void * data ; s#list_head list ; s#blocking_notifier_head line_state_notifier ; s#blocking_notifier_head device_notifier ; s#srcu_struct srcu ; s#list_head pin_ranges ; }
s#gpio_irq_chip struct gpio_irq_chip { s#irq_chip * chip ; s#irq_domain * domain ; s#fwnode_handle * fwnode ; s#irq_domain * parent_domain ; int ( * child_to_parent_hwirq ) ( s#gpio_chip * , unsigned int , unsigned int , unsigned int * , unsigned int * ) ; int ( * populate_parent_alloc_arg ) ( s#gpio_chip * , u#gpio_irq_fwspec * , unsigned int , unsigned int ) ; unsigned int ( * child_offset_to_irq ) ( s#gpio_chip * , unsigned int ) ; s#irq_domain_ops child_irq_domain_ops ; t#irq_flow_handler_t handler ; unsigned int default_type ; s#lock_class_key * lock_key ; s#lock_class_key * request_key ; t#irq_flow_handler_t parent_handler ; union { void * parent_handler_data ; void * * parent_handler_data_array ; } ; unsigned int num_parents ; unsigned int * parents ; unsigned int * map ; t#bool threaded ; t#bool per_parent_data ; t#bool initialized ; t#bool domain_is_allocated_externally ; int ( * init_hw ) ( s#gpio_chip * ) ; void ( * init_valid_mask ) ( s#gpio_chip * , unsigned long * , unsigned int ) ; unsigned long * valid_mask ; unsigned int first ; void ( * irq_enable ) ( s#irq_data * ) ; void ( * irq_disable ) ( s#irq_data * ) ; void ( * irq_unmask ) ( s#irq_data * ) ; void ( * irq_mask ) ( s#irq_data * ) ; }
s#gro_list struct gro_list { s#list_head list ; int count ; }
s#group_info struct group_info { t#refcount_t usage ; int ngroups ; t#kgid_t gid [ ] ; }
s#gss_api_mech struct gss_api_mech { s#list_head gm_list ; s#module * gm_owner ; s#rpcsec_gss_oid gm_oid ; char * gm_name ; const s#gss_api_ops * gm_ops ; int gm_pf_num ; s#pf_desc * gm_pfs ; const char * gm_upcall_enctypes ; }
s#gss_api_ops struct gss_api_ops { int ( * gss_import_sec_context ) ( const void * , t#size_t , s#gss_ctx * , t#time64_t * , t#gfp_t ) ; t#u32 ( * gss_get_mic ) ( s#gss_ctx * , s#xdr_buf * , s#xdr_netobj * ) ; t#u32 ( * gss_verify_mic ) ( s#gss_ctx * , s#xdr_buf * , s#xdr_netobj * ) ; t#u32 ( * gss_wrap ) ( s#gss_ctx * , int , s#xdr_buf * , s#page * * ) ; t#u32 ( * gss_unwrap ) ( s#gss_ctx * , int , int , s#xdr_buf * ) ; void ( * gss_delete_sec_context ) ( void * ) ; }
s#gss_ctx struct gss_ctx { s#gss_api_mech * mech_type ; void * internal_ctx_id ; unsigned int slack , align ; }
s#hd_geometry@1fae69fd struct hd_geometry { UNKNOWN }
s#hd_geometry@cba8892d struct hd_geometry { unsigned char heads ; unsigned char sectors ; unsigned short cylinders ; unsigned long start ; }
s#header_ops struct header_ops { int ( * create ) ( s#sk_buff * , s#net_device * , unsigned short , const void * , const void * , unsigned int ) ; int ( * parse ) ( const s#sk_buff * , unsigned char * ) ; int ( * cache ) ( const s#neighbour * , s#hh_cache * , t#__be16 ) ; void ( * cache_update ) ( s#hh_cache * , const s#net_device * , const unsigned char * ) ; t#bool ( * validate ) ( const char * , unsigned int ) ; t#__be16 ( * parse_protocol ) ( const s#sk_buff * ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#hh_cache struct hh_cache { unsigned int hh_len ; t#seqlock_t hh_lock ; unsigned long hh_data [ ( ( ( 128 ) + ( 16 - 1 ) ) & ~ ( 16 - 1 ) ) / sizeof ( long ) ] ; }
s#hlist_bl_head struct hlist_bl_head { s#hlist_bl_node * first ; }
s#hlist_bl_node struct hlist_bl_node { s#hlist_bl_node * next , * * pprev ; }
s#hlist_head struct hlist_head { s#hlist_node * first ; }
s#hlist_node struct hlist_node { s#hlist_node * next , * * pprev ; }
s#hlist_nulls_head struct hlist_nulls_head { s#hlist_nulls_node * first ; }
s#hlist_nulls_node struct hlist_nulls_node { s#hlist_nulls_node * next , * * pprev ; }
s#hotplug_slot@1b7da886 struct hotplug_slot { UNKNOWN }
s#hotplug_slot@484ea182 struct hotplug_slot { const s#hotplug_slot_ops * ops ; s#list_head slot_list ; s#pci_slot * pci_slot ; s#module * owner ; const char * mod_name ; }
s#hotplug_slot_ops struct hotplug_slot_ops { int ( * enable_slot ) ( s#hotplug_slot * ) ; int ( * disable_slot ) ( s#hotplug_slot * ) ; int ( * set_attention_status ) ( s#hotplug_slot * , t#u8 ) ; int ( * hardware_test ) ( s#hotplug_slot * , t#u32 ) ; int ( * get_power_status ) ( s#hotplug_slot * , t#u8 * ) ; int ( * get_attention_status ) ( s#hotplug_slot * , t#u8 * ) ; int ( * get_latch_status ) ( s#hotplug_slot * , t#u8 * ) ; int ( * get_adapter_status ) ( s#hotplug_slot * , t#u8 * ) ; int ( * reset_slot ) ( s#hotplug_slot * , t#bool ) ; int ( * force_power_slot ) ( s#hotplug_slot * , int ) ; unsigned long uek_reserved1 ; }
s#hrtimer struct hrtimer { s#timerqueue_node node ; t#ktime_t _softexpires ; e#hrtimer_restart ( * function ) ( s#hrtimer * ) ; s#hrtimer_clock_base * base ; t#u8 state ; t#u8 is_rel ; t#u8 is_soft ; t#u8 is_hard ; }
s#hrtimer_clock_base@65ed4b96 struct hrtimer_clock_base { s#hrtimer_cpu_base * cpu_base ; unsigned int index ; t#clockid_t clockid ; t#seqcount_raw_spinlock_t seq ; s#hrtimer * running ; s#timerqueue_head active ; t#ktime_t ( * get_time ) ( void ) ; t#ktime_t offset ; }
s#hrtimer_clock_base@f3ddec6f struct hrtimer_clock_base { UNKNOWN }
s#hrtimer_cpu_base struct hrtimer_cpu_base { t#raw_spinlock_t lock ; unsigned int cpu ; unsigned int active_bases ; unsigned int clock_was_set_seq ; unsigned int hres_active : 1 , in_hrtirq : 1 , hang_detected : 1 , softirq_activated : 1 , online : 1 ; unsigned int nr_events ; unsigned short nr_retries ; unsigned short nr_hangs ; unsigned int max_hang_time ; t#ktime_t expires_next ; s#hrtimer * next_timer ; t#ktime_t softirq_expires_next ; s#hrtimer * softirq_next_timer ; s#hrtimer_clock_base clock_base [ E#HRTIMER_MAX_CLOCK_BASES ] ; t#call_single_data_t csd ; }
s#hw_perf_event struct hw_perf_event { union { struct { t#u64 config ; t#u64 last_tag ; unsigned long config_base ; unsigned long event_base ; int event_base_rdpmc ; int idx ; int last_cpu ; int flags ; s#hw_perf_event_extra extra_reg ; s#hw_perf_event_extra branch_reg ; } ; struct { t#u64 aux_config ; } ; struct { s#hrtimer hrtimer ; } ; struct { s#list_head tp_list ; } ; struct { t#u64 pwr_acc ; t#u64 ptsc ; } ; struct { s#arch_hw_breakpoint info ; s#rhlist_head bp_list ; } ; struct { t#u8 iommu_bank ; t#u8 iommu_cntr ; t#u16 padding ; t#u64 conf ; t#u64 conf1 ; } ; } ; s#task_struct * target ; void * addr_filters ; unsigned long addr_filters_gen ; int state ; t#local64_t prev_count ; t#u64 sample_period ; union { struct { t#u64 last_period ; t#local64_t period_left ; } ; struct { t#u64 saved_metric ; t#u64 saved_slots ; } ; } ; t#u64 interrupts_seq ; t#u64 interrupts ; t#u64 freq_time_stamp ; t#u64 freq_count_stamp ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#hw_perf_event_extra struct hw_perf_event_extra { t#u64 config ; unsigned int reg ; int alloc ; int idx ; }
s#hw_port_info struct hw_port_info { s#net_device * lower_dev ; t#u32 port_id ; }
s#hw_stats_device_data struct hw_stats_device_data { UNKNOWN }
s#iattr struct iattr { unsigned int ia_valid ; t#umode_t ia_mode ; union { t#kuid_t ia_uid ; t#vfsuid_t ia_vfsuid ; } ; union { t#kgid_t ia_gid ; t#vfsgid_t ia_vfsgid ; } ; t#loff_t ia_size ; s#timespec64 ia_atime ; s#timespec64 ia_mtime ; s#timespec64 ia_ctime ; s#file * ia_file ; }
s#ib_ah struct ib_ah { s#ib_device * device ; s#ib_pd * pd ; s#ib_uobject * uobject ; const s#ib_gid_attr * sgid_attr ; e#rdma_ah_attr_type type ; }
s#ib_ah_attr struct ib_ah_attr { t#u16 dlid ; t#u8 src_path_bits ; }
s#ib_core_device struct ib_core_device { s#device dev ; t#possible_net_t rdma_net ; s#kobject * ports_kobj ; s#list_head port_list ; s#ib_device * owner ; }
s#ib_counters struct ib_counters { s#ib_device * device ; s#ib_uobject * uobject ; t#atomic_t usecnt ; }
s#ib_counters_read_attr struct ib_counters_read_attr { t#u64 * counters_buff ; t#u32 ncounters ; t#u32 flags ; }
s#ib_cq struct ib_cq { s#ib_device * device ; s#ib_ucq_object * uobject ; t#ib_comp_handler comp_handler ; void ( * event_handler ) ( s#ib_event * , void * ) ; void * cq_context ; int cqe ; unsigned int cqe_used ; t#atomic_t usecnt ; e#ib_poll_context poll_ctx ; s#ib_wc * wc ; s#list_head pool_entry ; union { s#irq_poll iop ; s#work_struct work ; } ; s#workqueue_struct * comp_wq ; s#dim * dim ; t#ktime_t timestamp ; t#u8 interrupt : 1 ; t#u8 shared : 1 ; unsigned int comp_vector ; s#rdma_restrack_entry res ; }
s#ib_cq_caps struct ib_cq_caps { t#u16 max_cq_moderation_count ; t#u16 max_cq_moderation_period ; }
s#ib_cq_init_attr struct ib_cq_init_attr { unsigned int cqe ; t#u32 comp_vector ; t#u32 flags ; }
s#ib_cqe struct ib_cqe { void ( * done ) ( s#ib_cq * , s#ib_wc * ) ; }
s#ib_device@8983e210 struct ib_device { UNKNOWN }
s#ib_device@b0505d27 struct ib_device { s#device * dma_device ; s#ib_device_ops ops ; char name [ 64 ] ; s#callback_head callback_head ; s#list_head event_handler_list ; s#rw_semaphore event_handler_rwsem ; t#spinlock_t qp_open_list_lock ; s#rw_semaphore client_data_rwsem ; s#xarray client_data ; s#mutex unregistration_lock ; t#rwlock_t cache_lock ; s#ib_port_data * port_data ; int num_comp_vectors ; t#bool can_balance_comp_vectors ; union { s#device dev ; s#ib_core_device coredev ; } ; const s#attribute_group * groups [ 4 ] ; t#u64 uverbs_cmd_mask ; char node_desc [ 64 ] ; t#__be64 node_guid ; t#u32 local_dma_lkey ; t#u16 is_switch : 1 ; t#u16 kverbs_provider : 1 ; t#u16 use_cq_dim : 1 ; t#u8 node_type ; t#u32 phys_port_cnt ; s#ib_device_attr attrs ; s#hw_stats_device_data * hw_stats_data ; s#rdmacg_device cg_device ; t#u32 index ; t#spinlock_t cq_pools_lock ; s#list_head cq_pools [ E#IB_POLL_LAST_POOL_TYPE + 1 ] ; s#rdma_restrack_root * res ; const s#uapi_definition * driver_def ; t#refcount_t refcount ; s#completion unreg_completion ; s#work_struct unregistration_work ; const s#rdma_link_ops * link_ops ; s#mutex compat_devs_mutex ; s#xarray compat_devs ; char iw_ifname [ 16 ] ; t#u32 iw_driver_flags ; t#u32 lag_flags ; s#mutex subdev_lock ; s#list_head subdev_list_head ; e#rdma_nl_dev_type type ; s#ib_device * parent ; s#list_head subdev_list ; e#rdma_nl_name_assign_type name_assign_type ; }
s#ib_device_attr struct ib_device_attr { t#u64 fw_ver ; t#__be64 sys_image_guid ; t#u64 max_mr_size ; t#u64 page_size_cap ; t#u32 vendor_id ; t#u32 vendor_part_id ; t#u32 hw_ver ; int max_qp ; int max_qp_wr ; t#u64 device_cap_flags ; t#u64 kernel_cap_flags ; int max_send_sge ; int max_recv_sge ; int max_sge_rd ; int max_cq ; int max_cqe ; int max_mr ; int max_pd ; int max_qp_rd_atom ; int max_ee_rd_atom ; int max_res_rd_atom ; int max_qp_init_rd_atom ; int max_ee_init_rd_atom ; e#ib_atomic_cap atomic_cap ; e#ib_atomic_cap masked_atomic_cap ; int max_ee ; int max_rdd ; int max_mw ; int max_raw_ipv6_qp ; int max_raw_ethy_qp ; int max_mcast_grp ; int max_mcast_qp_attach ; int max_total_mcast_qp_attach ; int max_ah ; int max_srq ; int max_srq_wr ; int max_srq_sge ; unsigned int max_fast_reg_page_list_len ; unsigned int max_pi_fast_reg_page_list_len ; t#u16 max_pkeys ; t#u8 local_ca_ack_delay ; int sig_prot_cap ; int sig_guard_cap ; s#ib_odp_caps odp_caps ; t#uint64_t timestamp_mask ; t#uint64_t hca_core_clock ; s#ib_rss_caps rss_caps ; t#u32 max_wq_type_rq ; t#u32 raw_packet_caps ; s#ib_tm_caps tm_caps ; s#ib_cq_caps cq_caps ; t#u64 max_dm_size ; t#u32 max_sgl_rd ; }
s#ib_device_modify struct ib_device_modify { t#u64 sys_image_guid ; char node_desc [ 64 ] ; }
s#ib_device_ops struct ib_device_ops { s#module * owner ; e#rdma_driver_id driver_id ; t#u32 uverbs_abi_ver ; unsigned int uverbs_no_driver_id_binding : 1 ; const s#attribute_group * device_group ; const s#attribute_group * * port_groups ; int ( * post_send ) ( s#ib_qp * , const s#ib_send_wr * , const s#ib_send_wr * * ) ; int ( * post_recv ) ( s#ib_qp * , const s#ib_recv_wr * , const s#ib_recv_wr * * ) ; void ( * drain_rq ) ( s#ib_qp * ) ; void ( * drain_sq ) ( s#ib_qp * ) ; int ( * poll_cq ) ( s#ib_cq * , int , s#ib_wc * ) ; int ( * peek_cq ) ( s#ib_cq * , int ) ; int ( * req_notify_cq ) ( s#ib_cq * , e#ib_cq_notify_flags ) ; int ( * post_srq_recv ) ( s#ib_srq * , const s#ib_recv_wr * , const s#ib_recv_wr * * ) ; int ( * process_mad ) ( s#ib_device * , int , t#u32 , const s#ib_wc * , const s#ib_grh * , const s#ib_mad * , s#ib_mad * , t#size_t * , t#u16 * ) ; int ( * query_device ) ( s#ib_device * , s#ib_device_attr * , s#ib_udata * ) ; int ( * modify_device ) ( s#ib_device * , int , s#ib_device_modify * ) ; void ( * get_dev_fw_str ) ( s#ib_device * , char * ) ; const s#cpumask * ( * get_vector_affinity ) ( s#ib_device * , int ) ; int ( * get_vector_irqn ) ( s#ib_device * , int ) ; int ( * query_port ) ( s#ib_device * , t#u32 , s#ib_port_attr * ) ; int ( * modify_port ) ( s#ib_device * , t#u32 , int , s#ib_port_modify * ) ; int ( * get_port_immutable ) ( s#ib_device * , t#u32 , s#ib_port_immutable * ) ; e#rdma_link_layer ( * get_link_layer ) ( s#ib_device * , t#u32 ) ; s#net_device * ( * get_netdev ) ( s#ib_device * , t#u32 ) ; s#net_device * ( * alloc_rdma_netdev ) ( s#ib_device * , t#u32 , e#rdma_netdev_t , const char * , unsigned char , void ( * ) ( s#net_device * ) ) ; s#ib_shpd * ( * alloc_shpd ) ( s#ib_device * , s#ib_pd * ) ; s#ib_pd * ( * share_pd ) ( s#ib_device * , s#ib_ucontext * , s#ib_udata * , s#ib_shpd * ) ; int ( * remove_shpd ) ( s#ib_device * , s#ib_shpd * , int ) ; int ( * rdma_netdev_get_params ) ( s#ib_device * , t#u32 , e#rdma_netdev_t , s#rdma_netdev_alloc_params * ) ; int ( * query_gid ) ( s#ib_device * , t#u32 , int , u#ib_gid * ) ; int ( * add_gid ) ( const s#ib_gid_attr * , void * * ) ; int ( * del_gid ) ( const s#ib_gid_attr * , void * * ) ; int ( * query_pkey ) ( s#ib_device * , t#u32 , t#u16 , t#u16 * ) ; int ( * alloc_ucontext ) ( s#ib_ucontext * , s#ib_udata * ) ; void ( * dealloc_ucontext ) ( s#ib_ucontext * ) ; int ( * mmap ) ( s#ib_ucontext * , s#vm_area_struct * ) ; void ( * mmap_free ) ( s#rdma_user_mmap_entry * ) ; void ( * disassociate_ucontext ) ( s#ib_ucontext * ) ; int ( * alloc_pd ) ( s#ib_pd * , s#ib_udata * ) ; int ( * dealloc_pd ) ( s#ib_pd * , s#ib_udata * ) ; int ( * create_ah ) ( s#ib_ah * , s#rdma_ah_init_attr * , s#ib_udata * ) ; int ( * create_user_ah ) ( s#ib_ah * , s#rdma_ah_init_attr * , s#ib_udata * ) ; int ( * modify_ah ) ( s#ib_ah * , s#rdma_ah_attr * ) ; int ( * query_ah ) ( s#ib_ah * , s#rdma_ah_attr * ) ; int ( * destroy_ah ) ( s#ib_ah * , t#u32 ) ; int ( * create_srq ) ( s#ib_srq * , s#ib_srq_init_attr * , s#ib_udata * ) ; int ( * modify_srq ) ( s#ib_srq * , s#ib_srq_attr * , e#ib_srq_attr_mask , s#ib_udata * ) ; int ( * query_srq ) ( s#ib_srq * , s#ib_srq_attr * ) ; int ( * destroy_srq ) ( s#ib_srq * , s#ib_udata * ) ; int ( * create_qp ) ( s#ib_qp * , s#ib_qp_init_attr * , s#ib_udata * ) ; int ( * modify_qp ) ( s#ib_qp * , s#ib_qp_attr * , int , s#ib_udata * ) ; int ( * query_qp ) ( s#ib_qp * , s#ib_qp_attr * , int , s#ib_qp_init_attr * ) ; int ( * destroy_qp ) ( s#ib_qp * , s#ib_udata * ) ; int ( * create_cq ) ( s#ib_cq * , const s#ib_cq_init_attr * , s#uverbs_attr_bundle * ) ; int ( * modify_cq ) ( s#ib_cq * , t#u16 , t#u16 ) ; int ( * destroy_cq ) ( s#ib_cq * , s#ib_udata * ) ; int ( * resize_cq ) ( s#ib_cq * , int , s#ib_udata * ) ; s#ib_mr * ( * get_dma_mr ) ( s#ib_pd * , int ) ; s#ib_mr * ( * reg_user_mr ) ( s#ib_pd * , t#u64 , t#u64 , t#u64 , int , s#ib_udata * ) ; s#ib_mr * ( * reg_user_mr_dmabuf ) ( s#ib_pd * , t#u64 , t#u64 , t#u64 , int , int , s#uverbs_attr_bundle * ) ; s#ib_mr * ( * rereg_user_mr ) ( s#ib_mr * , int , t#u64 , t#u64 , t#u64 , int , s#ib_pd * , s#ib_udata * ) ; int ( * dereg_mr ) ( s#ib_mr * , s#ib_udata * ) ; s#ib_mr * ( * alloc_mr ) ( s#ib_pd * , e#ib_mr_type , t#u32 ) ; s#ib_mr * ( * alloc_mr_integrity ) ( s#ib_pd * , t#u32 , t#u32 ) ; int ( * advise_mr ) ( s#ib_pd * , e#ib_uverbs_advise_mr_advice , t#u32 , s#ib_sge * , t#u32 , s#uverbs_attr_bundle * ) ; int ( * map_mr_sg ) ( s#ib_mr * , s#scatterlist * , int , unsigned int * ) ; int ( * check_mr_status ) ( s#ib_mr * , t#u32 , s#ib_mr_status * ) ; int ( * alloc_mw ) ( s#ib_mw * , s#ib_udata * ) ; int ( * dealloc_mw ) ( s#ib_mw * ) ; int ( * attach_mcast ) ( s#ib_qp * , u#ib_gid * , t#u16 ) ; int ( * detach_mcast ) ( s#ib_qp * , u#ib_gid * , t#u16 ) ; int ( * alloc_xrcd ) ( s#ib_xrcd * , s#ib_udata * ) ; int ( * dealloc_xrcd ) ( s#ib_xrcd * , s#ib_udata * ) ; s#ib_flow * ( * create_flow ) ( s#ib_qp * , s#ib_flow_attr * , s#ib_udata * ) ; int ( * destroy_flow ) ( s#ib_flow * ) ; int ( * destroy_flow_action ) ( s#ib_flow_action * ) ; int ( * set_vf_link_state ) ( s#ib_device * , int , t#u32 , int ) ; int ( * get_vf_config ) ( s#ib_device * , int , t#u32 , s#ifla_vf_info * ) ; int ( * get_vf_stats ) ( s#ib_device * , int , t#u32 , s#ifla_vf_stats * ) ; int ( * get_vf_guid ) ( s#ib_device * , int , t#u32 , s#ifla_vf_guid * , s#ifla_vf_guid * ) ; int ( * set_vf_guid ) ( s#ib_device * , int , t#u32 , t#u64 , int ) ; s#ib_wq * ( * create_wq ) ( s#ib_pd * , s#ib_wq_init_attr * , s#ib_udata * ) ; int ( * destroy_wq ) ( s#ib_wq * , s#ib_udata * ) ; int ( * modify_wq ) ( s#ib_wq * , s#ib_wq_attr * , t#u32 , s#ib_udata * ) ; int ( * create_rwq_ind_table ) ( s#ib_rwq_ind_table * , s#ib_rwq_ind_table_init_attr * , s#ib_udata * ) ; int ( * destroy_rwq_ind_table ) ( s#ib_rwq_ind_table * ) ; s#ib_dm * ( * alloc_dm ) ( s#ib_device * , s#ib_ucontext * , s#ib_dm_alloc_attr * , s#uverbs_attr_bundle * ) ; int ( * dealloc_dm ) ( s#ib_dm * , s#uverbs_attr_bundle * ) ; s#ib_mr * ( * reg_dm_mr ) ( s#ib_pd * , s#ib_dm * , s#ib_dm_mr_attr * , s#uverbs_attr_bundle * ) ; int ( * create_counters ) ( s#ib_counters * , s#uverbs_attr_bundle * ) ; int ( * destroy_counters ) ( s#ib_counters * ) ; int ( * read_counters ) ( s#ib_counters * , s#ib_counters_read_attr * , s#uverbs_attr_bundle * ) ; int ( * map_mr_sg_pi ) ( s#ib_mr * , s#scatterlist * , int , unsigned int * , s#scatterlist * , int , unsigned int * ) ; s#rdma_hw_stats * ( * alloc_hw_device_stats ) ( s#ib_device * ) ; s#rdma_hw_stats * ( * alloc_hw_port_stats ) ( s#ib_device * , t#u32 ) ; int ( * get_hw_stats ) ( s#ib_device * , s#rdma_hw_stats * , t#u32 , int ) ; int ( * clear_hw_stats ) ( s#ib_device * , t#u32 ) ; int ( * modify_hw_stat ) ( s#ib_device * , t#u32 , unsigned int , t#bool ) ; int ( * fill_res_mr_entry ) ( s#sk_buff * , s#ib_mr * ) ; int ( * fill_res_mr_entry_raw ) ( s#sk_buff * , s#ib_mr * ) ; int ( * fill_res_cq_entry ) ( s#sk_buff * , s#ib_cq * ) ; int ( * fill_res_cq_entry_raw ) ( s#sk_buff * , s#ib_cq * ) ; int ( * fill_res_qp_entry ) ( s#sk_buff * , s#ib_qp * ) ; int ( * fill_res_qp_entry_raw ) ( s#sk_buff * , s#ib_qp * ) ; int ( * fill_res_cm_id_entry ) ( s#sk_buff * , s#rdma_cm_id * ) ; int ( * fill_res_srq_entry ) ( s#sk_buff * , s#ib_srq * ) ; int ( * fill_res_srq_entry_raw ) ( s#sk_buff * , s#ib_srq * ) ; int ( * enable_driver ) ( s#ib_device * ) ; void ( * dealloc_driver ) ( s#ib_device * ) ; void ( * iw_add_ref ) ( s#ib_qp * ) ; void ( * iw_rem_ref ) ( s#ib_qp * ) ; s#ib_qp * ( * iw_get_qp ) ( s#ib_device * , int ) ; int ( * iw_connect ) ( s#iw_cm_id * , s#iw_cm_conn_param * ) ; int ( * iw_accept ) ( s#iw_cm_id * , s#iw_cm_conn_param * ) ; int ( * iw_reject ) ( s#iw_cm_id * , const void * , t#u8 ) ; int ( * iw_create_listen ) ( s#iw_cm_id * , int ) ; int ( * iw_destroy_listen ) ( s#iw_cm_id * ) ; int ( * counter_bind_qp ) ( s#rdma_counter * , s#ib_qp * ) ; int ( * counter_unbind_qp ) ( s#ib_qp * ) ; int ( * counter_dealloc ) ( s#rdma_counter * ) ; s#rdma_hw_stats * ( * counter_alloc_stats ) ( s#rdma_counter * ) ; int ( * counter_update_stats ) ( s#rdma_counter * ) ; int ( * fill_stat_mr_entry ) ( s#sk_buff * , s#ib_mr * ) ; int ( * query_ucontext ) ( s#ib_ucontext * , s#uverbs_attr_bundle * ) ; int ( * get_numa_node ) ( s#ib_device * ) ; s#ib_device * ( * add_sub_dev ) ( s#ib_device * , e#rdma_nl_dev_type , const char * ) ; void ( * del_sub_dev ) ( s#ib_device * ) ; t#size_t size_ib_ah ; t#size_t size_ib_counters ; t#size_t size_ib_cq ; t#size_t size_ib_mw ; t#size_t size_ib_pd ; t#size_t size_ib_qp ; t#size_t size_ib_rwq_ind_table ; t#size_t size_ib_srq ; t#size_t size_ib_ucontext ; t#size_t size_ib_xrcd ; }
s#ib_dm struct ib_dm { s#ib_device * device ; t#u32 length ; t#u32 flags ; s#ib_uobject * uobject ; t#atomic_t usecnt ; }
s#ib_dm_alloc_attr struct ib_dm_alloc_attr { t#u64 length ; t#u32 alignment ; t#u32 flags ; }
s#ib_dm_mr_attr struct ib_dm_mr_attr { t#u64 length ; t#u64 offset ; t#u32 access_flags ; }
s#ib_event struct ib_event { s#ib_device * device ; union { s#ib_cq * cq ; s#ib_qp * qp ; s#ib_srq * srq ; s#ib_wq * wq ; t#u32 port_num ; } element ; e#ib_event_type event ; }
s#ib_event_handler struct ib_event_handler { s#ib_device * device ; void ( * handler ) ( s#ib_event_handler * , s#ib_event * ) ; s#list_head list ; }
s#ib_flow struct ib_flow { s#ib_qp * qp ; s#ib_device * device ; s#ib_uobject * uobject ; }
s#ib_flow_action struct ib_flow_action { s#ib_device * device ; s#ib_uobject * uobject ; e#ib_flow_action_type type ; t#atomic_t usecnt ; }
s#ib_flow_attr struct ib_flow_attr { e#ib_flow_attr_type type ; t#u16 size ; t#u16 priority ; t#u32 flags ; t#u8 num_of_specs ; t#u32 port ; u#ib_flow_spec flows [ ] ; }
s#ib_flow_esp_filter struct ib_flow_esp_filter { t#__be32 spi ; t#__be32 seq ; }
s#ib_flow_eth_filter struct ib_flow_eth_filter { t#u8 dst_mac [ 6 ] ; t#u8 src_mac [ 6 ] ; t#__be16 ether_type ; t#__be16 vlan_tag ; }
s#ib_flow_gre_filter struct ib_flow_gre_filter { t#__be16 c_ks_res0_ver ; t#__be16 protocol ; t#__be32 key ; }
s#ib_flow_ib_filter struct ib_flow_ib_filter { t#__be16 dlid ; t#__u8 sl ; }
s#ib_flow_ipv4_filter struct ib_flow_ipv4_filter { t#__be32 src_ip ; t#__be32 dst_ip ; t#u8 proto ; t#u8 tos ; t#u8 ttl ; t#u8 flags ; }
s#ib_flow_ipv6_filter struct ib_flow_ipv6_filter { t#u8 src_ip [ 16 ] ; t#u8 dst_ip [ 16 ] ; t#__be32 flow_label ; t#u8 next_hdr ; t#u8 traffic_class ; t#u8 hop_limit ; }
s#ib_flow_mpls_filter struct ib_flow_mpls_filter { t#__be32 tag ; }
s#ib_flow_spec_action_count struct ib_flow_spec_action_count { e#ib_flow_spec_type type ; t#u16 size ; s#ib_counters * counters ; }
s#ib_flow_spec_action_drop struct ib_flow_spec_action_drop { e#ib_flow_spec_type type ; t#u16 size ; }
s#ib_flow_spec_action_handle struct ib_flow_spec_action_handle { e#ib_flow_spec_type type ; t#u16 size ; s#ib_flow_action * act ; }
s#ib_flow_spec_action_tag struct ib_flow_spec_action_tag { e#ib_flow_spec_type type ; t#u16 size ; t#u32 tag_id ; }
s#ib_flow_spec_esp struct ib_flow_spec_esp { t#u32 type ; t#u16 size ; s#ib_flow_esp_filter val ; s#ib_flow_esp_filter mask ; }
s#ib_flow_spec_eth struct ib_flow_spec_eth { t#u32 type ; t#u16 size ; s#ib_flow_eth_filter val ; s#ib_flow_eth_filter mask ; }
s#ib_flow_spec_gre struct ib_flow_spec_gre { t#u32 type ; t#u16 size ; s#ib_flow_gre_filter val ; s#ib_flow_gre_filter mask ; }
s#ib_flow_spec_ib struct ib_flow_spec_ib { t#u32 type ; t#u16 size ; s#ib_flow_ib_filter val ; s#ib_flow_ib_filter mask ; }
s#ib_flow_spec_ipv4 struct ib_flow_spec_ipv4 { t#u32 type ; t#u16 size ; s#ib_flow_ipv4_filter val ; s#ib_flow_ipv4_filter mask ; }
s#ib_flow_spec_ipv6 struct ib_flow_spec_ipv6 { t#u32 type ; t#u16 size ; s#ib_flow_ipv6_filter val ; s#ib_flow_ipv6_filter mask ; }
s#ib_flow_spec_mpls struct ib_flow_spec_mpls { t#u32 type ; t#u16 size ; s#ib_flow_mpls_filter val ; s#ib_flow_mpls_filter mask ; }
s#ib_flow_spec_sniffer struct ib_flow_spec_sniffer { e#ib_flow_spec_type type ; t#u16 size ; t#u32 port_num ; t#bool is_rx ; }
s#ib_flow_spec_tcp_udp struct ib_flow_spec_tcp_udp { t#u32 type ; t#u16 size ; s#ib_flow_tcp_udp_filter val ; s#ib_flow_tcp_udp_filter mask ; }
s#ib_flow_spec_tunnel struct ib_flow_spec_tunnel { t#u32 type ; t#u16 size ; s#ib_flow_tunnel_filter val ; s#ib_flow_tunnel_filter mask ; }
s#ib_flow_tcp_udp_filter struct ib_flow_tcp_udp_filter { t#__be16 dst_port ; t#__be16 src_port ; }
s#ib_flow_tunnel_filter struct ib_flow_tunnel_filter { t#__be32 tunnel_id ; }
s#ib_gid_attr struct ib_gid_attr { s#net_device * ndev ; s#ib_device * device ; u#ib_gid gid ; e#ib_gid_type gid_type ; t#u16 index ; t#u32 port_num ; }
s#ib_gid_table struct ib_gid_table { UNKNOWN }
s#ib_global_route struct ib_global_route { const s#ib_gid_attr * sgid_attr ; u#ib_gid dgid ; t#u32 flow_label ; t#u8 sgid_index ; t#u8 hop_limit ; t#u8 traffic_class ; }
s#ib_grh struct ib_grh { t#__be32 version_tclass_flow ; t#__be16 paylen ; t#u8 next_hdr ; t#u8 hop_limit ; u#ib_gid sgid ; u#ib_gid dgid ; }
s#ib_mad@4c0e7e7e struct ib_mad { s#ib_mad_hdr mad_hdr ; t#u8 data [ E#IB_MGMT_MAD_DATA ] ; }
s#ib_mad@a9b3adf3 struct ib_mad { UNKNOWN }
s#ib_mad_hdr struct ib_mad_hdr { t#u8 base_version ; t#u8 mgmt_class ; t#u8 class_version ; t#u8 method ; t#__be16 status ; t#__be16 class_specific ; t#__be64 tid ; t#__be16 attr_id ; t#__be16 resv ; t#__be32 attr_mod ; }
s#ib_mr struct ib_mr { s#ib_device * device ; s#ib_pd * pd ; t#u32 lkey ; t#u32 rkey ; t#u64 iova ; t#u64 length ; unsigned int page_size ; e#ib_mr_type type ; t#bool need_inval ; union { s#ib_uobject * uobject ; s#list_head qp_entry ; } ; s#ib_dm * dm ; s#ib_sig_attrs * sig_attrs ; s#rdma_restrack_entry res ; }
s#ib_mr_status struct ib_mr_status { t#u32 fail_status ; s#ib_sig_err sig_err ; }
s#ib_mw struct ib_mw { s#ib_device * device ; s#ib_pd * pd ; s#ib_uobject * uobject ; t#u32 rkey ; e#ib_mw_type type ; }
s#ib_odp_caps struct ib_odp_caps { t#uint64_t general_caps ; struct { t#uint32_t rc_odp_caps ; t#uint32_t uc_odp_caps ; t#uint32_t ud_odp_caps ; t#uint32_t xrc_odp_caps ; } per_transport_caps ; }
s#ib_pd struct ib_pd { t#u32 local_dma_lkey ; t#u32 flags ; s#ib_device * device ; s#ib_uobject * uobject ; s#ib_shpd * shpd ; t#atomic_t usecnt ; t#u32 unsafe_global_rkey ; s#ib_mr * __internal_mr ; s#rdma_restrack_entry res ; }
s#ib_pkey_cache struct ib_pkey_cache { UNKNOWN }
s#ib_port struct ib_port { UNKNOWN }
s#ib_port_attr struct ib_port_attr { t#u64 subnet_prefix ; e#ib_port_state state ; e#ib_mtu max_mtu ; e#ib_mtu active_mtu ; t#u32 phys_mtu ; int gid_tbl_len ; unsigned int ip_gids : 1 ; t#u32 port_cap_flags ; t#u32 max_msg_sz ; t#u32 bad_pkey_cntr ; t#u32 qkey_viol_cntr ; t#u16 pkey_tbl_len ; t#u32 sm_lid ; t#u32 lid ; t#u8 lmc ; t#u8 max_vl_num ; t#u8 sm_sl ; t#u8 subnet_timeout ; t#u8 init_type_reply ; t#u8 active_width ; t#u16 active_speed ; t#u8 phys_state ; t#u16 port_cap_flags2 ; }
s#ib_port_cache struct ib_port_cache { t#u64 subnet_prefix ; s#ib_pkey_cache * pkey ; s#ib_gid_table * gid ; t#u8 lmc ; e#ib_port_state port_state ; }
s#ib_port_data struct ib_port_data { s#ib_device * ib_dev ; s#ib_port_immutable immutable ; t#spinlock_t pkey_list_lock ; t#spinlock_t netdev_lock ; s#list_head pkey_list ; s#ib_port_cache cache ; s#net_device * netdev ; t#netdevice_tracker netdev_tracker ; s#hlist_node ndev_hash_link ; s#rdma_port_counter port_counter ; s#ib_port * sysfs ; }
s#ib_port_immutable struct ib_port_immutable { int pkey_tbl_len ; int gid_tbl_len ; t#u32 core_cap_flags ; t#u32 max_mad_size ; }
s#ib_port_modify struct ib_port_modify { t#u32 set_port_cap_mask ; t#u32 clr_port_cap_mask ; t#u8 init_type ; }
s#ib_port_pkey struct ib_port_pkey { e#port_pkey_state state ; t#u16 pkey_index ; t#u32 port_num ; s#list_head qp_list ; s#list_head to_error_list ; s#ib_qp_security * sec ; }
s#ib_ports_pkeys struct ib_ports_pkeys { s#ib_port_pkey main ; s#ib_port_pkey alt ; }
s#ib_qp struct ib_qp { s#ib_device * device ; s#ib_pd * pd ; s#ib_cq * send_cq ; s#ib_cq * recv_cq ; t#spinlock_t mr_lock ; int mrs_used ; s#list_head rdma_mrs ; s#list_head sig_mrs ; s#ib_srq * srq ; s#completion srq_completion ; s#ib_xrcd * xrcd ; s#list_head xrcd_list ; t#atomic_t usecnt ; s#list_head open_list ; s#ib_qp * real_qp ; s#ib_uqp_object * uobject ; void ( * event_handler ) ( s#ib_event * , void * ) ; void ( * registered_event_handler ) ( s#ib_event * , void * ) ; void * qp_context ; const s#ib_gid_attr * av_sgid_attr ; const s#ib_gid_attr * alt_path_sgid_attr ; t#u32 qp_num ; t#u32 max_write_sge ; t#u32 max_read_sge ; e#ib_qp_type qp_type ; s#ib_rwq_ind_table * rwq_ind_tbl ; s#ib_qp_security * qp_sec ; t#u32 port ; t#bool integrity_en ; s#rdma_restrack_entry res ; s#rdma_counter * counter ; }
s#ib_qp_attr struct ib_qp_attr { e#ib_qp_state qp_state ; e#ib_qp_state cur_qp_state ; e#ib_mtu path_mtu ; e#ib_mig_state path_mig_state ; t#u32 qkey ; t#u32 rq_psn ; t#u32 sq_psn ; t#u32 dest_qp_num ; int qp_access_flags ; s#ib_qp_cap cap ; s#rdma_ah_attr ah_attr ; s#rdma_ah_attr alt_ah_attr ; t#u16 pkey_index ; t#u16 alt_pkey_index ; t#u8 en_sqd_async_notify ; t#u8 sq_draining ; t#u8 max_rd_atomic ; t#u8 max_dest_rd_atomic ; t#u8 min_rnr_timer ; t#u32 port_num ; t#u8 timeout ; t#u8 retry_cnt ; t#u8 rnr_retry ; t#u32 alt_port_num ; t#u8 alt_timeout ; t#u32 rate_limit ; s#net_device * xmit_slave ; }
s#ib_qp_cap struct ib_qp_cap { t#u32 max_send_wr ; t#u32 max_recv_wr ; t#u32 max_send_sge ; t#u32 max_recv_sge ; t#u32 max_inline_data ; t#u32 max_rdma_ctxs ; }
s#ib_qp_init_attr struct ib_qp_init_attr { void ( * event_handler ) ( s#ib_event * , void * ) ; void * qp_context ; s#ib_cq * send_cq ; s#ib_cq * recv_cq ; s#ib_srq * srq ; s#ib_xrcd * xrcd ; s#ib_qp_cap cap ; e#ib_sig_type sq_sig_type ; e#ib_qp_type qp_type ; t#u32 create_flags ; t#u32 port_num ; s#ib_rwq_ind_table * rwq_ind_tbl ; t#u32 source_qpn ; }
s#ib_qp_security struct ib_qp_security { s#ib_qp * qp ; s#ib_device * dev ; s#mutex mutex ; s#ib_ports_pkeys * ports_pkeys ; s#list_head shared_qp_list ; void * security ; t#bool destroying ; t#atomic_t error_list_count ; s#completion error_complete ; int error_comps_pending ; }
s#ib_rdmacg_object struct ib_rdmacg_object { s#rdma_cgroup * cg ; }
s#ib_recv_wr struct ib_recv_wr { s#ib_recv_wr * next ; union { t#u64 wr_id ; s#ib_cqe * wr_cqe ; } ; s#ib_sge * sg_list ; int num_sge ; }
s#ib_rss_caps struct ib_rss_caps { t#u32 supported_qpts ; t#u32 max_rwq_indirection_tables ; t#u32 max_rwq_indirection_table_size ; }
s#ib_rwq_ind_table struct ib_rwq_ind_table { s#ib_device * device ; s#ib_uobject * uobject ; t#atomic_t usecnt ; t#u32 ind_tbl_num ; t#u32 log_ind_tbl_size ; s#ib_wq * * ind_tbl ; }
s#ib_rwq_ind_table_init_attr struct ib_rwq_ind_table_init_attr { t#u32 log_ind_tbl_size ; s#ib_wq * * ind_tbl ; }
s#ib_send_wr struct ib_send_wr { s#ib_send_wr * next ; union { t#u64 wr_id ; s#ib_cqe * wr_cqe ; } ; s#ib_sge * sg_list ; int num_sge ; e#ib_wr_opcode opcode ; int send_flags ; union { t#__be32 imm_data ; t#u32 invalidate_rkey ; } ex ; }
s#ib_sge struct ib_sge { t#u64 addr ; t#u32 length ; t#u32 lkey ; }
s#ib_shpd struct ib_shpd { int idr_id ; s#ib_device * device ; int ref_count ; t#u64 share_key ; }
s#ib_sig_attrs struct ib_sig_attrs { t#u8 check_mask ; s#ib_sig_domain mem ; s#ib_sig_domain wire ; int meta_length ; }
s#ib_sig_domain struct ib_sig_domain { e#ib_signature_type sig_type ; union { s#ib_t10_dif_domain dif ; } sig ; }
s#ib_sig_err struct ib_sig_err { e#ib_sig_err_type err_type ; t#u32 expected ; t#u32 actual ; t#u64 sig_err_offset ; t#u32 key ; }
s#ib_srq struct ib_srq { s#ib_device * device ; s#ib_pd * pd ; s#ib_usrq_object * uobject ; void ( * event_handler ) ( s#ib_event * , void * ) ; void * srq_context ; e#ib_srq_type srq_type ; t#atomic_t usecnt ; struct { s#ib_cq * cq ; union { struct { s#ib_xrcd * xrcd ; t#u32 srq_num ; } xrc ; } ; } ext ; s#rdma_restrack_entry res ; }
s#ib_srq_attr struct ib_srq_attr { t#u32 max_wr ; t#u32 max_sge ; t#u32 srq_limit ; }
s#ib_srq_init_attr struct ib_srq_init_attr { void ( * event_handler ) ( s#ib_event * , void * ) ; void * srq_context ; s#ib_srq_attr attr ; e#ib_srq_type srq_type ; struct { s#ib_cq * cq ; union { struct { s#ib_xrcd * xrcd ; } xrc ; struct { t#u32 max_num_tags ; } tag_matching ; } ; } ext ; }
s#ib_t10_dif_domain struct ib_t10_dif_domain { e#ib_t10_dif_bg_type bg_type ; t#u16 pi_interval ; t#u16 bg ; t#u16 app_tag ; t#u32 ref_tag ; t#bool ref_remap ; t#bool app_escape ; t#bool ref_escape ; t#u16 apptag_check_mask ; }
s#ib_tm_caps struct ib_tm_caps { t#u32 max_rndv_hdr_size ; t#u32 max_num_tags ; t#u32 flags ; t#u32 max_ops ; t#u32 max_sge ; }
s#ib_ucontext struct ib_ucontext { s#ib_device * device ; s#ib_uverbs_file * ufile ; s#ib_rdmacg_object cg_obj ; s#rdma_restrack_entry res ; s#xarray mmap_xa ; }
s#ib_ucq_object@c3a0bd8a struct ib_ucq_object { s#ib_uevent_object uevent ; s#list_head comp_list ; t#u32 comp_events_reported ; }
s#ib_ucq_object@c5bb6d4d struct ib_ucq_object { UNKNOWN }
s#ib_udata struct ib_udata { const void * inbuf ; void * outbuf ; t#size_t inlen ; t#size_t outlen ; }
s#ib_uevent_object struct ib_uevent_object { s#ib_uobject uobject ; s#ib_uverbs_async_event_file * event_file ; s#list_head event_list ; t#u32 events_reported ; }
s#ib_uobject struct ib_uobject { t#u64 user_handle ; s#ib_uverbs_file * ufile ; s#ib_ucontext * context ; void * object ; s#list_head list ; s#ib_rdmacg_object cg_obj ; int id ; s#kref ref ; t#atomic_t usecnt ; s#callback_head rcu ; const s#uverbs_api_object * uapi_object ; }
s#ib_uqp_object@6ddfb3c8 struct ib_uqp_object { UNKNOWN }
s#ib_uqp_object@d972150a struct ib_uqp_object { s#ib_uevent_object uevent ; s#mutex mcast_lock ; s#list_head mcast_list ; s#ib_uxrcd_object * uxrcd ; }
s#ib_usrq_object@13ed46b4 struct ib_usrq_object { UNKNOWN }
s#ib_usrq_object@19ac41ab struct ib_usrq_object { s#ib_uevent_object uevent ; s#ib_uxrcd_object * uxrcd ; }
s#ib_uverbs_async_event_file struct ib_uverbs_async_event_file { s#ib_uobject uobj ; s#ib_uverbs_event_queue ev_queue ; s#ib_event_handler event_handler ; }
s#ib_uverbs_device struct ib_uverbs_device { t#refcount_t refcount ; t#u32 num_comp_vectors ; t#bool can_balance_comp_vectors ; s#completion comp ; s#device dev ; const s#attribute_group * groups [ 2 ] ; s#ib_device * ib_dev ; int devnum ; s#cdev cdev ; s#rb_root xrcd_tree ; s#mutex xrcd_tree_mutex ; s#srcu_struct disassociate_srcu ; s#mutex lists_mutex ; s#list_head uverbs_file_list ; s#uverbs_api * uapi ; }
s#ib_uverbs_event_queue struct ib_uverbs_event_queue { t#spinlock_t lock ; int is_closed ; t#wait_queue_head_t poll_wait ; s#fasync_struct * async_queue ; s#list_head event_list ; }
s#ib_uverbs_file@379d1e39 struct ib_uverbs_file { s#kref ref ; s#ib_uverbs_device * device ; s#mutex ucontext_lock ; s#ib_ucontext * ucontext ; s#ib_uverbs_async_event_file * default_async_file ; s#list_head list ; s#rw_semaphore hw_destroy_rwsem ; t#spinlock_t uobjects_lock ; s#list_head uobjects ; s#mutex umap_lock ; s#list_head umaps ; s#page * disassociate_page ; s#xarray idr ; s#mutex disassociation_lock ; }
s#ib_uverbs_file@7f1eb45e struct ib_uverbs_file { UNKNOWN }
s#ib_uwq_object@1aa0ea2b struct ib_uwq_object { s#ib_uevent_object uevent ; }
s#ib_uwq_object@66e50b0f struct ib_uwq_object { UNKNOWN }
s#ib_uxrcd_object struct ib_uxrcd_object { s#ib_uobject uobject ; t#atomic_t refcnt ; }
s#ib_wc struct ib_wc { union { t#u64 wr_id ; s#ib_cqe * wr_cqe ; } ; e#ib_wc_status status ; e#ib_wc_opcode opcode ; t#u32 vendor_err ; t#u32 byte_len ; s#ib_qp * qp ; union { t#__be32 imm_data ; t#u32 invalidate_rkey ; } ex ; t#u32 src_qp ; t#u32 slid ; int wc_flags ; t#u16 pkey_index ; t#u8 sl ; t#u8 dlid_path_bits ; t#u32 port_num ; t#u8 smac [ 6 ] ; t#u16 vlan_id ; t#u8 network_hdr_type ; }
s#ib_wq struct ib_wq { s#ib_device * device ; s#ib_uwq_object * uobject ; void * wq_context ; void ( * event_handler ) ( s#ib_event * , void * ) ; s#ib_pd * pd ; s#ib_cq * cq ; t#u32 wq_num ; e#ib_wq_state state ; e#ib_wq_type wq_type ; t#atomic_t usecnt ; }
s#ib_wq_attr struct ib_wq_attr { e#ib_wq_state wq_state ; e#ib_wq_state curr_wq_state ; t#u32 flags ; t#u32 flags_mask ; }
s#ib_wq_init_attr struct ib_wq_init_attr { void * wq_context ; e#ib_wq_type wq_type ; t#u32 max_wr ; t#u32 max_sge ; s#ib_cq * cq ; void ( * event_handler ) ( s#ib_event * , void * ) ; t#u32 create_flags ; }
s#ib_xrcd struct ib_xrcd { s#ib_device * device ; t#atomic_t usecnt ; s#inode * inode ; s#rw_semaphore tgt_qps_rwsem ; s#xarray tgt_qps ; }
s#icmp_mib struct icmp_mib { unsigned long mibs [ E#__ICMP_MIB_MAX ] ; }
s#icmpmsg_mib struct icmpmsg_mib { t#atomic_long_t mibs [ 512 ] ; }
s#icmpv6_mib struct icmpv6_mib { unsigned long mibs [ E#__ICMP6_MIB_MAX ] ; }
s#icmpv6_mib_device struct icmpv6_mib_device { t#atomic_long_t mibs [ E#__ICMP6_MIB_MAX ] ; }
s#icmpv6msg_mib struct icmpv6msg_mib { t#atomic_long_t mibs [ 512 ] ; }
s#icmpv6msg_mib_device struct icmpv6msg_mib_device { t#atomic_long_t mibs [ 512 ] ; }
s#idmap struct idmap { UNKNOWN }
s#idr struct idr { s#xarray idr_rt ; unsigned int idr_base ; unsigned int idr_next ; }
s#idt_bits struct idt_bits { t#u16 ist : 3 , zero : 5 , type : 5 , dpl : 2 , p : 1 ; }
s#ieee80211_channel struct ieee80211_channel { e#nl80211_band band ; t#u32 center_freq ; t#u16 freq_offset ; t#u16 hw_value ; t#u32 flags ; int max_antenna_gain ; int max_power ; int max_reg_power ; t#bool beacon_found ; t#u32 orig_flags ; int orig_mag , orig_mpwr ; e#nl80211_dfs_state dfs_state ; unsigned long dfs_state_entered ; unsigned int dfs_cac_ms ; t#s8 psd ; }
s#ieee80211_edmg struct ieee80211_edmg { t#u8 channels ; e#ieee80211_edmg_bw_config bw_config ; }
s#ieee80211_eht_cap_elem_fixed struct ieee80211_eht_cap_elem_fixed { t#u8 mac_cap_info [ 2 ] ; t#u8 phy_cap_info [ 9 ] ; }
s#ieee80211_eht_mcs_nss_supp struct ieee80211_eht_mcs_nss_supp { union { s#ieee80211_eht_mcs_nss_supp_20mhz_only only_20mhz ; struct { s#ieee80211_eht_mcs_nss_supp_bw _80 ; s#ieee80211_eht_mcs_nss_supp_bw _160 ; s#ieee80211_eht_mcs_nss_supp_bw _320 ; } __attribute__ ( ( __packed__ ) ) bw ; } __attribute__ ( ( __packed__ ) ) ; }
s#ieee80211_eht_mcs_nss_supp_20mhz_only struct ieee80211_eht_mcs_nss_supp_20mhz_only { union { struct { t#u8 rx_tx_mcs7_max_nss ; t#u8 rx_tx_mcs9_max_nss ; t#u8 rx_tx_mcs11_max_nss ; t#u8 rx_tx_mcs13_max_nss ; } ; t#u8 rx_tx_max_nss [ 4 ] ; } ; }
s#ieee80211_eht_mcs_nss_supp_bw struct ieee80211_eht_mcs_nss_supp_bw { union { struct { t#u8 rx_tx_mcs9_max_nss ; t#u8 rx_tx_mcs11_max_nss ; t#u8 rx_tx_mcs13_max_nss ; } ; t#u8 rx_tx_max_nss [ 3 ] ; } ; }
s#ieee80211_freq_range struct ieee80211_freq_range { t#u32 start_freq_khz ; t#u32 end_freq_khz ; t#u32 max_bandwidth_khz ; }
s#ieee80211_he_6ghz_capa struct ieee80211_he_6ghz_capa { t#__le16 capa ; }
s#ieee80211_he_cap_elem struct ieee80211_he_cap_elem { t#u8 mac_cap_info [ 6 ] ; t#u8 phy_cap_info [ 11 ] ; }
s#ieee80211_he_mcs_nss_supp struct ieee80211_he_mcs_nss_supp { t#__le16 rx_mcs_80 ; t#__le16 tx_mcs_80 ; t#__le16 rx_mcs_160 ; t#__le16 tx_mcs_160 ; t#__le16 rx_mcs_80p80 ; t#__le16 tx_mcs_80p80 ; }
s#ieee80211_ht_cap struct ieee80211_ht_cap { t#__le16 cap_info ; t#u8 ampdu_params_info ; s#ieee80211_mcs_info mcs ; t#__le16 extended_ht_cap_info ; t#__le32 tx_BF_cap_info ; t#u8 antenna_selection_info ; }
s#ieee80211_iface_combination struct ieee80211_iface_combination { const s#ieee80211_iface_limit * limits ; t#u32 num_different_channels ; t#u16 max_interfaces ; t#u8 n_limits ; t#bool beacon_int_infra_match ; t#u8 radar_detect_widths ; t#u8 radar_detect_regions ; t#u32 beacon_int_min_gcd ; }
s#ieee80211_iface_limit struct ieee80211_iface_limit { t#u16 max ; t#u16 types ; }
s#ieee80211_mcs_info struct ieee80211_mcs_info { t#u8 rx_mask [ 10 ] ; t#__le16 rx_highest ; t#u8 tx_params ; t#u8 reserved [ 3 ] ; }
s#ieee80211_power_rule struct ieee80211_power_rule { t#u32 max_antenna_gain ; t#u32 max_eirp ; }
s#ieee80211_rate struct ieee80211_rate { t#u32 flags ; t#u16 bitrate ; t#u16 hw_value , hw_value_short ; }
s#ieee80211_reg_rule struct ieee80211_reg_rule { s#ieee80211_freq_range freq_range ; s#ieee80211_power_rule power_rule ; s#ieee80211_wmm_rule wmm_rule ; t#u32 flags ; t#u32 dfs_cac_ms ; t#bool has_wmm ; t#s8 psd ; }
s#ieee80211_regdomain struct ieee80211_regdomain { s#callback_head callback_head ; t#u32 n_reg_rules ; char alpha2 [ 3 ] ; e#nl80211_dfs_regions dfs_region ; s#ieee80211_reg_rule reg_rules [ ] ; }
s#ieee80211_sband_iftype_data struct ieee80211_sband_iftype_data { t#u16 types_mask ; s#ieee80211_sta_he_cap he_cap ; s#ieee80211_he_6ghz_capa he_6ghz_capa ; s#ieee80211_sta_eht_cap eht_cap ; struct { const t#u8 * data ; unsigned int len ; } vendor_elems ; }
s#ieee80211_sta_eht_cap struct ieee80211_sta_eht_cap { t#bool has_eht ; s#ieee80211_eht_cap_elem_fixed eht_cap_elem ; s#ieee80211_eht_mcs_nss_supp eht_mcs_nss_supp ; t#u8 eht_ppe_thres [ 32 ] ; }
s#ieee80211_sta_he_cap struct ieee80211_sta_he_cap { t#bool has_he ; s#ieee80211_he_cap_elem he_cap_elem ; s#ieee80211_he_mcs_nss_supp he_mcs_nss_supp ; t#u8 ppe_thres [ 25 ] ; }
s#ieee80211_sta_ht_cap struct ieee80211_sta_ht_cap { t#u16 cap ; t#bool ht_supported ; t#u8 ampdu_factor ; t#u8 ampdu_density ; s#ieee80211_mcs_info mcs ; }
s#ieee80211_sta_s1g_cap struct ieee80211_sta_s1g_cap { t#bool s1g ; t#u8 cap [ 10 ] ; t#u8 nss_mcs [ 5 ] ; }
s#ieee80211_sta_vht_cap struct ieee80211_sta_vht_cap { t#bool vht_supported ; t#u32 cap ; s#ieee80211_vht_mcs_info vht_mcs ; }
s#ieee80211_supported_band struct ieee80211_supported_band { s#ieee80211_channel * channels ; s#ieee80211_rate * bitrates ; e#nl80211_band band ; int n_channels ; int n_bitrates ; s#ieee80211_sta_ht_cap ht_cap ; s#ieee80211_sta_vht_cap vht_cap ; s#ieee80211_sta_s1g_cap s1g_cap ; s#ieee80211_edmg edmg_cap ; t#u16 n_iftype_data ; const s#ieee80211_sband_iftype_data * iftype_data ; }
s#ieee80211_txrx_stypes struct ieee80211_txrx_stypes { t#u16 tx , rx ; }
s#ieee80211_vht_cap struct ieee80211_vht_cap { t#__le32 vht_cap_info ; s#ieee80211_vht_mcs_info supp_mcs ; }
s#ieee80211_vht_mcs_info struct ieee80211_vht_mcs_info { t#__le16 rx_mcs_map ; t#__le16 rx_highest ; t#__le16 tx_mcs_map ; t#__le16 tx_highest ; }
s#ieee80211_wmm_ac struct ieee80211_wmm_ac { t#u16 cw_min ; t#u16 cw_max ; t#u16 cot ; t#u8 aifsn ; }
s#ieee80211_wmm_rule struct ieee80211_wmm_rule { s#ieee80211_wmm_ac client [ 4 ] ; s#ieee80211_wmm_ac ap [ 4 ] ; }
s#ieee802154_addr struct ieee802154_addr { t#u8 mode ; t#__le16 pan_id ; union { t#__le16 short_addr ; t#__le64 extended_addr ; } ; }
s#ieee802154_pan_device struct ieee802154_pan_device { t#__le16 pan_id ; t#u8 mode ; t#__le16 short_addr ; t#__le64 extended_addr ; s#list_head node ; }
s#ieee_ets struct ieee_ets { t#__u8 willing ; t#__u8 ets_cap ; t#__u8 cbs ; t#__u8 tc_tx_bw [ 8 ] ; t#__u8 tc_rx_bw [ 8 ] ; t#__u8 tc_tsa [ 8 ] ; t#__u8 prio_tc [ 8 ] ; t#__u8 tc_reco_bw [ 8 ] ; t#__u8 tc_reco_tsa [ 8 ] ; t#__u8 reco_prio_tc [ 8 ] ; }
s#ieee_maxrate struct ieee_maxrate { t#__u64 tc_maxrate [ 8 ] ; }
s#ieee_pfc struct ieee_pfc { t#__u8 pfc_cap ; t#__u8 pfc_en ; t#__u8 mbc ; t#__u16 delay ; t#__u64 requests [ 8 ] ; t#__u64 indications [ 8 ] ; }
s#ieee_qcn struct ieee_qcn { t#__u8 rpg_enable [ 8 ] ; t#__u32 rppp_max_rps [ 8 ] ; t#__u32 rpg_time_reset [ 8 ] ; t#__u32 rpg_byte_reset [ 8 ] ; t#__u32 rpg_threshold [ 8 ] ; t#__u32 rpg_max_rate [ 8 ] ; t#__u32 rpg_ai_rate [ 8 ] ; t#__u32 rpg_hai_rate [ 8 ] ; t#__u32 rpg_gd [ 8 ] ; t#__u32 rpg_min_dec_fac [ 8 ] ; t#__u32 rpg_min_rate [ 8 ] ; t#__u32 cndd_state_machine [ 8 ] ; }
s#ieee_qcn_stats struct ieee_qcn_stats { t#__u64 rppp_rp_centiseconds [ 8 ] ; t#__u32 rppp_created_rps [ 8 ] ; }
s#if_settings struct if_settings { unsigned int type ; unsigned int size ; union { t#raw_hdlc_proto * raw_hdlc ; t#cisco_proto * cisco ; t#fr_proto * fr ; t#fr_proto_pvc * fr_pvc ; t#fr_proto_pvc_info * fr_pvc_info ; t#x25_hdlc_proto * x25 ; t#sync_serial_settings * sync ; t#te1_settings * te1 ; } ifs_ifsu ; }
s#ifacaddr6 struct ifacaddr6 { s#in6_addr aca_addr ; s#fib6_info * aca_rt ; s#ifacaddr6 * aca_next ; s#hlist_node aca_addr_lst ; int aca_users ; t#refcount_t aca_refcnt ; unsigned long aca_cstamp ; unsigned long aca_tstamp ; s#callback_head rcu ; }
s#ifla_vf_guid struct ifla_vf_guid { t#__u32 vf ; t#__u64 guid ; }
s#ifla_vf_info struct ifla_vf_info { t#__u32 vf ; t#__u8 mac [ 32 ] ; t#__u32 vlan ; t#__u32 qos ; t#__u32 spoofchk ; t#__u32 linkstate ; t#__u32 min_tx_rate ; t#__u32 max_tx_rate ; t#__u32 rss_query_en ; t#__u32 trusted ; t#__be16 vlan_proto ; }
s#ifla_vf_stats struct ifla_vf_stats { t#__u64 rx_packets ; t#__u64 tx_packets ; t#__u64 rx_bytes ; t#__u64 tx_bytes ; t#__u64 broadcast ; t#__u64 multicast ; t#__u64 rx_dropped ; t#__u64 tx_dropped ; }
s#ifmap struct ifmap { unsigned long mem_start ; unsigned long mem_end ; unsigned short base_addr ; unsigned char irq ; unsigned char dma ; unsigned char port ; }
s#ifmcaddr6 struct ifmcaddr6 { s#in6_addr mca_addr ; s#inet6_dev * idev ; s#ifmcaddr6 * next ; s#ip6_sf_list * mca_sources ; s#ip6_sf_list * mca_tomb ; unsigned int mca_sfmode ; unsigned char mca_crcount ; unsigned long mca_sfcount [ 2 ] ; s#delayed_work mca_work ; unsigned int mca_flags ; int mca_users ; t#refcount_t mca_refcnt ; unsigned long mca_cstamp ; unsigned long mca_tstamp ; s#callback_head rcu ; }
s#ifreq struct ifreq { union { char ifrn_name [ 16 ] ; } ifr_ifrn ; union { s#sockaddr ifru_addr ; s#sockaddr ifru_dstaddr ; s#sockaddr ifru_broadaddr ; s#sockaddr ifru_netmask ; s#sockaddr ifru_hwaddr ; short ifru_flags ; int ifru_ivalue ; int ifru_mtu ; s#ifmap ifru_map ; char ifru_slave [ 16 ] ; char ifru_newname [ 16 ] ; void * ifru_data ; s#if_settings ifru_settings ; } ifr_ifru ; }
s#in6_addr@52a16b22 struct in6_addr { union { t#__u8 u6_addr8 [ 16 ] ; t#__be16 u6_addr16 [ 8 ] ; t#__be32 u6_addr32 [ 4 ] ; } in6_u ; }
s#in6_addr@d91c0c20 struct in6_addr { UNKNOWN }
s#in_addr struct in_addr { t#__be32 s_addr ; }
s#in_device@467287f3 struct in_device { s#net_device * dev ; t#netdevice_tracker dev_tracker ; t#refcount_t refcnt ; int dead ; s#in_ifaddr * ifa_list ; s#ip_mc_list * mc_list ; s#ip_mc_list * * mc_hash ; int mc_count ; t#spinlock_t mc_tomb_lock ; s#ip_mc_list * mc_tomb ; unsigned long mr_v1_seen ; unsigned long mr_v2_seen ; unsigned long mr_maxdelay ; unsigned long mr_qi ; unsigned long mr_qri ; unsigned char mr_qrv ; unsigned char mr_gq_running ; t#u32 mr_ifc_count ; s#timer_list mr_gq_timer ; s#timer_list mr_ifc_timer ; s#neigh_parms * arp_parms ; s#ipv4_devconf cnf ; s#callback_head callback_head ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#in_device@e840243a struct in_device { UNKNOWN }
s#in_ifaddr struct in_ifaddr { s#hlist_node hash ; s#in_ifaddr * ifa_next ; s#in_device * ifa_dev ; s#callback_head callback_head ; t#__be32 ifa_local ; t#__be32 ifa_address ; t#__be32 ifa_mask ; t#__u32 ifa_rt_priority ; t#__be32 ifa_broadcast ; unsigned char ifa_scope ; unsigned char ifa_prefixlen ; unsigned char ifa_proto ; t#__u32 ifa_flags ; char ifa_label [ 16 ] ; t#__u32 ifa_valid_lft ; t#__u32 ifa_preferred_lft ; unsigned long ifa_cstamp ; unsigned long ifa_tstamp ; }
s#inet6_dev@2fdc6d2e struct inet6_dev { s#net_device * dev ; t#netdevice_tracker dev_tracker ; s#list_head addr_list ; s#ifmcaddr6 * mc_list ; s#ifmcaddr6 * mc_tomb ; unsigned char mc_qrv ; unsigned char mc_gq_running ; unsigned char mc_ifc_count ; unsigned char mc_dad_count ; unsigned long mc_v1_seen ; unsigned long mc_qi ; unsigned long mc_qri ; unsigned long mc_maxdelay ; s#delayed_work mc_gq_work ; s#delayed_work mc_ifc_work ; s#delayed_work mc_dad_work ; s#delayed_work mc_query_work ; s#delayed_work mc_report_work ; s#sk_buff_head mc_query_queue ; s#sk_buff_head mc_report_queue ; t#spinlock_t mc_query_lock ; t#spinlock_t mc_report_lock ; s#mutex mc_lock ; s#ifacaddr6 * ac_list ; t#rwlock_t lock ; t#refcount_t refcnt ; t#__u32 if_flags ; int dead ; t#u32 desync_factor ; s#list_head tempaddr_list ; s#in6_addr token ; s#neigh_parms * nd_parms ; s#ipv6_devconf cnf ; s#ipv6_devstat stats ; s#timer_list rs_timer ; t#__s32 rs_interval ; t#__u8 rs_probes ; unsigned long tstamp ; s#callback_head rcu ; unsigned int ra_mtu ; }
s#inet6_dev@fbc129b1 struct inet6_dev { UNKNOWN }
s#inet_bind_hashbucket struct inet_bind_hashbucket { t#spinlock_t lock ; s#hlist_head chain ; }
s#inet_ehash_bucket struct inet_ehash_bucket { s#hlist_nulls_head chain ; }
s#inet_frag_queue struct inet_frag_queue { s#rhash_head node ; union { s#frag_v4_compare_key v4 ; s#frag_v6_compare_key v6 ; } key ; s#timer_list timer ; t#spinlock_t lock ; t#refcount_t refcnt ; s#rb_root rb_fragments ; s#sk_buff * fragments_tail ; s#sk_buff * last_run_head ; t#ktime_t stamp ; int len ; int meat ; t#u8 tstamp_type ; t#__u8 flags ; t#u16 max_size ; s#fqdir * fqdir ; s#callback_head rcu ; }
s#inet_frags struct inet_frags { unsigned int qsize ; void ( * constructor ) ( s#inet_frag_queue * , const void * ) ; void ( * destructor ) ( s#inet_frag_queue * ) ; void ( * frag_expire ) ( s#timer_list * ) ; s#kmem_cache * frags_cachep ; const char * frags_cache_name ; s#rhashtable_params rhash_params ; t#refcount_t refcnt ; s#completion completion ; }
s#inet_hashinfo@b8c86004 struct inet_hashinfo { UNKNOWN }
s#inet_hashinfo@f8eabb77 struct inet_hashinfo { s#inet_ehash_bucket * ehash ; t#spinlock_t * ehash_locks ; unsigned int ehash_mask ; unsigned int ehash_locks_mask ; s#kmem_cache * bind_bucket_cachep ; s#inet_bind_hashbucket * bhash ; s#kmem_cache * bind2_bucket_cachep ; s#inet_bind_hashbucket * bhash2 ; unsigned int bhash_size ; unsigned int lhash2_mask ; s#inet_listen_hashbucket * lhash2 ; t#bool pernet ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#inet_listen_hashbucket struct inet_listen_hashbucket { t#spinlock_t lock ; s#hlist_nulls_head nulls_head ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#inet_peer_base@34625d11 struct inet_peer_base { UNKNOWN }
s#inet_peer_base@b794a578 struct inet_peer_base { s#rb_root rb_root ; t#seqlock_t lock ; int total ; }
s#inet_timewait_death_row struct inet_timewait_death_row { t#refcount_t tw_refcount ; s#inet_hashinfo * hashinfo __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; int sysctl_max_tw_buckets ; }
s#inode@1197d713 struct inode { UNKNOWN }
s#inode@4761f272 struct inode { t#umode_t i_mode ; unsigned short i_opflags ; t#kuid_t i_uid ; t#kgid_t i_gid ; unsigned int i_flags ; s#posix_acl * i_acl ; s#posix_acl * i_default_acl ; const s#inode_operations * i_op ; s#super_block * i_sb ; s#address_space * i_mapping ; void * i_security ; unsigned long i_ino ; union { const unsigned int i_nlink ; unsigned int __i_nlink ; } ; t#dev_t i_rdev ; t#loff_t i_size ; t#time64_t i_atime_sec ; t#time64_t i_mtime_sec ; t#time64_t i_ctime_sec ; t#u32 i_atime_nsec ; t#u32 i_mtime_nsec ; t#u32 i_ctime_nsec ; t#u32 i_generation ; t#spinlock_t i_lock ; unsigned short i_bytes ; t#u8 i_blkbits ; e#rw_hint i_write_hint ; t#blkcnt_t i_blocks ; t#u32 i_state ; s#rw_semaphore i_rwsem ; unsigned long dirtied_when ; unsigned long dirtied_time_when ; s#hlist_node i_hash ; s#list_head i_io_list ; s#bdi_writeback * i_wb ; int i_wb_frn_winner ; t#u16 i_wb_frn_avg_time ; t#u16 i_wb_frn_history ; s#list_head i_lru ; s#list_head i_sb_list ; s#list_head i_wb_list ; union { s#hlist_head i_dentry ; s#callback_head i_rcu ; } ; t#atomic64_t i_version ; t#atomic64_t i_sequence ; t#atomic_t i_count ; t#atomic_t i_dio_count ; t#atomic_t i_writecount ; t#atomic_t i_readcount ; union { const s#file_operations * i_fop ; void ( * free_inode ) ( s#inode * ) ; } ; s#file_lock_context * i_flctx ; s#address_space i_data ; s#list_head i_devices ; union { s#pipe_inode_info * i_pipe ; s#cdev * i_cdev ; char * i_link ; unsigned i_dir_seq ; } ; t#__u32 i_fsnotify_mask ; s#fsnotify_mark_connector * i_fsnotify_marks ; s#fscrypt_inode_info * i_crypt_info ; s#fsverity_info * i_verity_info ; void * i_private ; }
s#inode_operations struct inode_operations { s#dentry * ( * lookup ) ( s#inode * , s#dentry * , unsigned int ) ; const char * ( * get_link ) ( s#dentry * , s#inode * , s#delayed_call * ) ; int ( * permission ) ( s#mnt_idmap * , s#inode * , int ) ; s#posix_acl * ( * get_inode_acl ) ( s#inode * , int , t#bool ) ; int ( * readlink ) ( s#dentry * , char * , int ) ; int ( * create ) ( s#mnt_idmap * , s#inode * , s#dentry * , t#umode_t , t#bool ) ; int ( * link ) ( s#dentry * , s#inode * , s#dentry * ) ; int ( * unlink ) ( s#inode * , s#dentry * ) ; int ( * symlink ) ( s#mnt_idmap * , s#inode * , s#dentry * , const char * ) ; int ( * mkdir ) ( s#mnt_idmap * , s#inode * , s#dentry * , t#umode_t ) ; int ( * rmdir ) ( s#inode * , s#dentry * ) ; int ( * mknod ) ( s#mnt_idmap * , s#inode * , s#dentry * , t#umode_t , t#dev_t ) ; int ( * rename ) ( s#mnt_idmap * , s#inode * , s#dentry * , s#inode * , s#dentry * , unsigned int ) ; int ( * setattr ) ( s#mnt_idmap * , s#dentry * , s#iattr * ) ; int ( * getattr ) ( s#mnt_idmap * , const s#path * , s#kstat * , t#u32 , unsigned int ) ; t#ssize_t ( * listxattr ) ( s#dentry * , char * , t#size_t ) ; int ( * fiemap ) ( s#inode * , s#fiemap_extent_info * , t#u64 , t#u64 ) ; int ( * update_time ) ( s#inode * , int ) ; int ( * atomic_open ) ( s#inode * , s#dentry * , s#file * , unsigned , t#umode_t ) ; int ( * tmpfile ) ( s#mnt_idmap * , s#inode * , s#file * , t#umode_t ) ; s#posix_acl * ( * get_acl ) ( s#mnt_idmap * , s#dentry * , int ) ; int ( * set_acl ) ( s#mnt_idmap * , s#dentry * , s#posix_acl * , int ) ; int ( * fileattr_set ) ( s#mnt_idmap * , s#dentry * , s#fileattr * ) ; int ( * fileattr_get ) ( s#dentry * , s#fileattr * ) ; s#offset_ctx * ( * get_offset_ctx ) ( s#inode * ) ; }
s#io_alloc_cache struct io_alloc_cache { void * * entries ; unsigned int nr_cached ; unsigned int max_cached ; t#size_t elem_size ; }
s#io_bitmap@ce3b45cd struct io_bitmap { UNKNOWN }
s#io_bitmap@fd172377 struct io_bitmap { t#u64 sequence ; t#refcount_t refcnt ; unsigned int max ; unsigned long bitmap [ ( ( 65536 / 8 ) / sizeof ( long ) ) ] ; }
s#io_buffer struct io_buffer { UNKNOWN }
s#io_buffer_list struct io_buffer_list { UNKNOWN }
s#io_cmd_data struct io_cmd_data { s#file * file ; t#__u8 data [ 56 ] ; }
s#io_comp_batch@dd097e59 struct io_comp_batch { UNKNOWN }
s#io_comp_batch@ea2dcf26 struct io_comp_batch { s#request * req_list ; t#bool need_ts ; void ( * complete ) ( s#io_comp_batch * ) ; }
s#io_context@3741925f struct io_context { UNKNOWN }
s#io_context@e59e5b32 struct io_context { t#atomic_long_t refcount ; t#atomic_t active_ref ; unsigned short ioprio ; t#spinlock_t lock ; s#xarray icq_tree ; s#io_cq * icq_hint ; s#hlist_head icq_list ; s#work_struct release_work ; }
s#io_cq struct io_cq { s#request_queue * q ; s#io_context * ioc ; union { s#list_head q_node ; s#kmem_cache * __rcu_icq_cache ; } ; union { s#hlist_node ioc_node ; s#callback_head __rcu_head ; } ; unsigned int flags ; }
s#io_cqe struct io_cqe { t#__u64 user_data ; t#__s32 res ; union { t#__u32 flags ; int fd ; } ; }
s#io_ev_fd struct io_ev_fd { UNKNOWN }
s#io_file_table struct io_file_table { s#io_fixed_file * files ; unsigned long * bitmap ; unsigned int alloc_hint ; }
s#io_fixed_file struct io_fixed_file { unsigned long file_ptr ; }
s#io_hash_bucket struct io_hash_bucket { t#spinlock_t lock ; s#hlist_head list ; }
s#io_hash_table struct io_hash_table { s#io_hash_bucket * hbs ; unsigned hash_bits ; }
s#io_kiocb struct io_kiocb { union { s#file * file ; s#io_cmd_data cmd ; } ; t#u8 opcode ; t#u8 iopoll_completed ; t#u16 buf_index ; unsigned nr_tw ; t#io_req_flags_t flags ; s#io_cqe cqe ; s#io_ring_ctx * ctx ; s#task_struct * task ; union { s#io_mapped_ubuf * imu ; s#io_buffer * kbuf ; s#io_buffer_list * buf_list ; } ; union { s#io_wq_work_node comp_list ; t#__poll_t apoll_events ; } ; s#io_rsrc_node * rsrc_node ; t#atomic_t refs ; t#bool cancel_seq_set ; s#io_task_work io_task_work ; s#hlist_node hash_node ; s#async_poll * apoll ; void * async_data ; t#atomic_t poll_refs ; s#io_kiocb * link ; const s#cred * creds ; s#io_wq_work work ; struct { t#u64 extra1 ; t#u64 extra2 ; } big_cqe ; }
s#io_mapped_ubuf@2f7e3a2f struct io_mapped_ubuf { t#u64 ubuf ; unsigned int len ; unsigned int nr_bvecs ; unsigned int folio_shift ; t#refcount_t refs ; unsigned long acct_pages ; s#bio_vec bvec [ ] ; }
s#io_mapped_ubuf@42ab5e51 struct io_mapped_ubuf { UNKNOWN }
s#io_restriction struct io_restriction { unsigned long register_op [ ( ( ( E#IORING_REGISTER_LAST ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long sqe_op [ ( ( ( E#IORING_OP_LAST ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; t#u8 sqe_flags_allowed ; t#u8 sqe_flags_required ; t#bool registered ; }
s#io_ring_ctx struct io_ring_ctx { struct { unsigned int flags ; unsigned int drain_next : 1 ; unsigned int restricted : 1 ; unsigned int off_timeout_used : 1 ; unsigned int drain_active : 1 ; unsigned int has_evfd : 1 ; unsigned int task_complete : 1 ; unsigned int lockless_cq : 1 ; unsigned int syscall_iopoll : 1 ; unsigned int poll_activated : 1 ; unsigned int drain_disabled : 1 ; unsigned int compat : 1 ; unsigned int iowq_limits_set : 1 ; s#task_struct * submitter_task ; s#io_rings * rings ; s#percpu_ref refs ; t#clockid_t clockid ; e#tk_offsets clock_offset ; e#task_work_notify_mode notify_method ; unsigned sq_thread_idle ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; struct { s#mutex uring_lock ; t#u32 * sq_array ; s#io_uring_sqe * sq_sqes ; unsigned cached_sq_head ; unsigned sq_entries ; s#io_rsrc_node * rsrc_node ; t#atomic_t cancel_seq ; t#bool poll_multi_queue ; s#io_wq_work_list iopoll_list ; s#io_file_table file_table ; s#io_mapped_ubuf * * user_bufs ; unsigned nr_user_files ; unsigned nr_user_bufs ; s#io_submit_state submit_state ; s#xarray io_bl_xa ; s#io_hash_table cancel_table_locked ; s#io_alloc_cache apoll_cache ; s#io_alloc_cache netmsg_cache ; s#io_alloc_cache rw_cache ; s#io_alloc_cache uring_cache ; s#hlist_head cancelable_uring_cmd ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; struct { s#io_uring_cqe * cqe_cached ; s#io_uring_cqe * cqe_sentinel ; unsigned cached_cq_tail ; unsigned cq_entries ; s#io_ev_fd * io_ev_fd ; unsigned cq_extra ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; struct { s#llist_head work_llist ; unsigned long check_cq ; t#atomic_t cq_wait_nr ; t#atomic_t cq_timeouts ; s#wait_queue_head cq_wait ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; struct { t#spinlock_t timeout_lock ; s#list_head timeout_list ; s#list_head ltimeout_list ; unsigned cq_last_tm_flush ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; t#spinlock_t completion_lock ; s#list_head io_buffers_comp ; s#list_head cq_overflow_list ; s#io_hash_table cancel_table ; s#hlist_head waitid_list ; s#hlist_head futex_list ; s#io_alloc_cache futex_cache ; const s#cred * sq_creds ; s#io_sq_data * sq_data ; s#wait_queue_head sqo_sq_wait ; s#list_head sqd_list ; unsigned int file_alloc_start ; unsigned int file_alloc_end ; s#list_head io_buffers_cache ; s#wait_queue_head poll_wq ; s#io_restriction restrictions ; s#io_rsrc_data * file_data ; s#io_rsrc_data * buf_data ; s#list_head rsrc_ref_list ; s#io_alloc_cache rsrc_node_cache ; s#wait_queue_head rsrc_quiesce_wq ; unsigned rsrc_quiesce ; t#u32 pers_next ; s#xarray personalities ; s#io_wq_hash * hash_map ; s#user_struct * user ; s#mm_struct * mm_account ; s#llist_head fallback_llist ; s#delayed_work fallback_work ; s#work_struct exit_work ; s#list_head tctx_list ; s#completion ref_comp ; t#u32 iowq_limits [ 2 ] ; s#callback_head poll_wq_task_work ; s#list_head defer_list ; s#io_alloc_cache msg_cache ; t#spinlock_t msg_lock ; s#list_head napi_list ; t#spinlock_t napi_lock ; t#ktime_t napi_busy_poll_dt ; t#bool napi_prefer_busy_poll ; t#bool napi_enabled ; s#hlist_head napi_ht [ 1 << ( 4 ) ] ; unsigned evfd_last_cq_tail ; unsigned short n_ring_pages ; unsigned short n_sqe_pages ; s#page * * ring_pages ; s#page * * sqe_pages ; }
s#io_rings struct io_rings { s#io_uring sq , cq ; t#u32 sq_ring_mask , cq_ring_mask ; t#u32 sq_ring_entries , cq_ring_entries ; t#u32 sq_dropped ; t#atomic_t sq_flags ; t#u32 cq_flags ; t#u32 cq_overflow ; s#io_uring_cqe cqes [ ] __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; }
s#io_rsrc_data@54f82f1c struct io_rsrc_data { UNKNOWN }
s#io_rsrc_data@85eac6f2 struct io_rsrc_data { s#io_ring_ctx * ctx ; t#u64 * * tags ; unsigned int nr ; t#u16 rsrc_type ; t#bool quiesce ; }
s#io_rsrc_node@92ed44e3 struct io_rsrc_node { UNKNOWN }
s#io_rsrc_node@c7f93dfc struct io_rsrc_node { s#io_ring_ctx * ctx ; int refs ; t#bool empty ; t#u16 type ; s#list_head node ; s#io_rsrc_put item ; }
s#io_rsrc_put struct io_rsrc_put { t#u64 tag ; union { void * rsrc ; s#file * file ; s#io_mapped_ubuf * buf ; } ; }
s#io_sq_data struct io_sq_data { UNKNOWN }
s#io_submit_link struct io_submit_link { s#io_kiocb * head ; s#io_kiocb * last ; }
s#io_submit_state struct io_submit_state { s#io_wq_work_node free_list ; s#io_wq_work_list compl_reqs ; s#io_submit_link link ; t#bool plug_started ; t#bool need_plug ; t#bool cq_flush ; unsigned short submit_nr ; s#blk_plug plug ; }
s#io_task_work struct io_task_work { s#llist_node node ; t#io_req_tw_func_t func ; }
s#io_tlb_area struct io_tlb_area { UNKNOWN }
s#io_tlb_mem@5df2ff14 struct io_tlb_mem { UNKNOWN }
s#io_tlb_mem@98b9c64d struct io_tlb_mem { s#io_tlb_pool defpool ; unsigned long nslabs ; s#dentry * debugfs ; t#bool force_bounce ; t#bool for_alloc ; t#bool can_grow ; t#u64 phys_limit ; t#spinlock_t lock ; s#list_head pools ; s#work_struct dyn_alloc ; t#atomic_long_t total_used ; t#atomic_long_t used_hiwater ; t#atomic_long_t transient_nslabs ; }
s#io_tlb_pool struct io_tlb_pool { t#phys_addr_t start ; t#phys_addr_t end ; void * vaddr ; unsigned long nslabs ; t#bool late_alloc ; unsigned int nareas ; unsigned int area_nslabs ; s#io_tlb_area * areas ; s#io_tlb_slot * slots ; s#list_head node ; s#callback_head rcu ; t#bool transient ; }
s#io_tlb_slot struct io_tlb_slot { UNKNOWN }
s#io_tw_state struct io_tw_state { }
s#io_uring struct io_uring { t#u32 head ; t#u32 tail ; }
s#io_uring_cmd@1826dcda struct io_uring_cmd { UNKNOWN }
s#io_uring_cmd@3430702a struct io_uring_cmd { s#file * file ; const s#io_uring_sqe * sqe ; void ( * task_work_cb ) ( s#io_uring_cmd * , unsigned ) ; t#u32 cmd_op ; t#u32 flags ; t#u8 pdu [ 32 ] ; }
s#io_uring_cqe struct io_uring_cqe { t#__u64 user_data ; t#__s32 res ; t#__u32 flags ; t#__u64 big_cqe [ ] ; }
s#io_uring_sqe struct io_uring_sqe { t#__u8 opcode ; t#__u8 flags ; t#__u16 ioprio ; t#__s32 fd ; union { t#__u64 off ; t#__u64 addr2 ; struct { t#__u32 cmd_op ; t#__u32 __pad1 ; } ; } ; union { t#__u64 addr ; t#__u64 splice_off_in ; struct { t#__u32 level ; t#__u32 optname ; } ; } ; t#__u32 len ; union { t#__kernel_rwf_t rw_flags ; t#__u32 fsync_flags ; t#__u16 poll_events ; t#__u32 poll32_events ; t#__u32 sync_range_flags ; t#__u32 msg_flags ; t#__u32 timeout_flags ; t#__u32 accept_flags ; t#__u32 cancel_flags ; t#__u32 open_flags ; t#__u32 statx_flags ; t#__u32 fadvise_advice ; t#__u32 splice_flags ; t#__u32 rename_flags ; t#__u32 unlink_flags ; t#__u32 hardlink_flags ; t#__u32 xattr_flags ; t#__u32 msg_ring_flags ; t#__u32 uring_cmd_flags ; t#__u32 waitid_flags ; t#__u32 futex_flags ; t#__u32 install_fd_flags ; t#__u32 nop_flags ; } ; t#__u64 user_data ; union { t#__u16 buf_index ; t#__u16 buf_group ; } __attribute__ ( ( packed ) ) ; t#__u16 personality ; union { t#__s32 splice_fd_in ; t#__u32 file_index ; t#__u32 optlen ; struct { t#__u16 addr_len ; t#__u16 __pad3 [ 1 ] ; } ; } ; union { struct { t#__u64 addr3 ; t#__u64 __pad2 [ 1 ] ; } ; struct { t#__u64 attr_ptr ; t#__u64 attr_type_mask ; } ; t#__u64 optval ; t#__u8 cmd [ 0 ] ; } ; }
s#io_uring_task@d2aed70f struct io_uring_task { int cached_refs ; const s#io_ring_ctx * last ; s#io_wq * io_wq ; s#file * registered_rings [ 16 ] ; s#xarray xa ; s#wait_queue_head wait ; t#atomic_t in_cancel ; t#atomic_t inflight_tracked ; s#percpu_counter inflight ; struct { s#llist_head task_list ; s#callback_head task_work ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; }
s#io_uring_task@e43ec8a1 struct io_uring_task { UNKNOWN }
s#io_wq struct io_wq { UNKNOWN }
s#io_wq_hash@be5016f3 struct io_wq_hash { UNKNOWN }
s#io_wq_hash@e3bd1a1d struct io_wq_hash { t#refcount_t refs ; unsigned long map ; s#wait_queue_head wait ; }
s#io_wq_work struct io_wq_work { s#io_wq_work_node list ; t#atomic_t flags ; int cancel_seq ; }
s#io_wq_work_list struct io_wq_work_list { s#io_wq_work_node * first ; s#io_wq_work_node * last ; }
s#io_wq_work_node struct io_wq_work_node { s#io_wq_work_node * next ; }
s#ioam6_pernet_data@8656808a struct ioam6_pernet_data { s#mutex lock ; s#rhashtable namespaces ; s#rhashtable schemas ; }
s#ioam6_pernet_data@8c68a5b8 struct ioam6_pernet_data { UNKNOWN }
s#ioapic_alloc_info struct ioapic_alloc_info { int pin ; int node ; t#u32 is_level : 1 ; t#u32 active_low : 1 ; t#u32 valid : 1 ; }
s#iomap@136b11c4 struct iomap { t#u64 addr ; t#loff_t offset ; t#u64 length ; t#u16 type ; t#u16 flags ; s#block_device * bdev ; s#dax_device * dax_dev ; void * inline_data ; void * private ; const s#iomap_folio_ops * folio_ops ; t#u64 validity_cookie ; }
s#iomap@3288b49c struct iomap { UNKNOWN }
s#iomap_folio_ops struct iomap_folio_ops { s#folio * ( * get_folio ) ( s#iomap_iter * , t#loff_t , unsigned ) ; void ( * put_folio ) ( s#inode * , t#loff_t , unsigned , s#folio * ) ; t#bool ( * iomap_valid ) ( s#inode * , const s#iomap * ) ; }
s#iomap_iter struct iomap_iter { s#inode * inode ; t#loff_t pos ; t#u64 len ; t#s64 processed ; unsigned flags ; s#iomap iomap ; s#iomap srcmap ; void * private ; }
s#iommu_attach_handle struct iommu_attach_handle { s#iommu_domain * domain ; }
s#iommu_device struct iommu_device { s#list_head list ; const s#iommu_ops * ops ; s#fwnode_handle * fwnode ; s#device * dev ; s#iommu_group * singleton_group ; t#u32 max_pasids ; }
s#iommu_dirty_bitmap struct iommu_dirty_bitmap { s#iova_bitmap * bitmap ; s#iommu_iotlb_gather * gather ; }
s#iommu_dirty_ops struct iommu_dirty_ops { int ( * set_dirty_tracking ) ( s#iommu_domain * , t#bool ) ; int ( * read_and_clear_dirty ) ( s#iommu_domain * , unsigned long , t#size_t , unsigned long , s#iommu_dirty_bitmap * ) ; }
s#iommu_dma_cookie struct iommu_dma_cookie { UNKNOWN }
s#iommu_domain@45bfc195 struct iommu_domain { UNKNOWN }
s#iommu_domain@5cec7dba struct iommu_domain { unsigned type ; const s#iommu_domain_ops * ops ; const s#iommu_dirty_ops * dirty_ops ; const s#iommu_ops * owner ; unsigned long pgsize_bitmap ; s#iommu_domain_geometry geometry ; s#iommu_dma_cookie * iova_cookie ; int ( * iopf_handler ) ( s#iopf_group * ) ; void * fault_data ; union { struct { t#iommu_fault_handler_t handler ; void * handler_token ; } ; struct { s#mm_struct * mm ; int users ; s#list_head next ; } ; } ; }
s#iommu_domain_geometry struct iommu_domain_geometry { t#dma_addr_t aperture_start ; t#dma_addr_t aperture_end ; t#bool force_aperture ; }
s#iommu_domain_ops struct iommu_domain_ops { int ( * attach_dev ) ( s#iommu_domain * , s#device * ) ; int ( * set_dev_pasid ) ( s#iommu_domain * , s#device * , t#ioasid_t ) ; int ( * map_pages ) ( s#iommu_domain * , unsigned long , t#phys_addr_t , t#size_t , t#size_t , int , t#gfp_t , t#size_t * ) ; t#size_t ( * unmap_pages ) ( s#iommu_domain * , unsigned long , t#size_t , t#size_t , s#iommu_iotlb_gather * ) ; void ( * flush_iotlb_all ) ( s#iommu_domain * ) ; int ( * iotlb_sync_map ) ( s#iommu_domain * , unsigned long , t#size_t ) ; void ( * iotlb_sync ) ( s#iommu_domain * , s#iommu_iotlb_gather * ) ; int ( * cache_invalidate_user ) ( s#iommu_domain * , s#iommu_user_data_array * ) ; t#phys_addr_t ( * iova_to_phys ) ( s#iommu_domain * , t#dma_addr_t ) ; t#bool ( * enforce_cache_coherency ) ( s#iommu_domain * ) ; int ( * enable_nesting ) ( s#iommu_domain * ) ; int ( * set_pgtable_quirks ) ( s#iommu_domain * , unsigned long ) ; void ( * free ) ( s#iommu_domain * ) ; }
s#iommu_fault struct iommu_fault { t#u32 type ; s#iommu_fault_page_request prm ; }
s#iommu_fault_page_request struct iommu_fault_page_request { t#u32 flags ; t#u32 pasid ; t#u32 grpid ; t#u32 perm ; t#u64 addr ; t#u64 private_data [ 2 ] ; }
s#iommu_fault_param struct iommu_fault_param { s#mutex lock ; t#refcount_t users ; s#callback_head rcu ; s#device * dev ; s#iopf_queue * queue ; s#list_head queue_list ; s#list_head partial ; s#list_head faults ; }
s#iommu_fwspec struct iommu_fwspec { s#fwnode_handle * iommu_fwnode ; t#u32 flags ; unsigned int num_ids ; t#u32 ids [ ] ; }
s#iommu_group struct iommu_group { UNKNOWN }
s#iommu_iotlb_gather struct iommu_iotlb_gather { unsigned long start ; unsigned long end ; t#size_t pgsize ; s#list_head freelist ; t#bool queued ; }
s#iommu_mm_data@7eced742 struct iommu_mm_data { UNKNOWN }
s#iommu_mm_data@b2cc622d struct iommu_mm_data { t#u32 pasid ; s#list_head sva_domains ; }
s#iommu_ops struct iommu_ops { t#bool ( * capable ) ( s#device * , e#iommu_cap ) ; void * ( * hw_info ) ( s#device * , t#u32 * , t#u32 * ) ; s#iommu_domain * ( * domain_alloc ) ( unsigned ) ; s#iommu_domain * ( * domain_alloc_user ) ( s#device * , t#u32 , s#iommu_domain * , const s#iommu_user_data * ) ; s#iommu_domain * ( * domain_alloc_paging ) ( s#device * ) ; s#iommu_domain * ( * domain_alloc_sva ) ( s#device * , s#mm_struct * ) ; s#iommu_device * ( * probe_device ) ( s#device * ) ; void ( * release_device ) ( s#device * ) ; void ( * probe_finalize ) ( s#device * ) ; s#iommu_group * ( * device_group ) ( s#device * ) ; void ( * get_resv_regions ) ( s#device * , s#list_head * ) ; int ( * of_xlate ) ( s#device * , const s#of_phandle_args * ) ; t#bool ( * is_attach_deferred ) ( s#device * ) ; int ( * dev_enable_feat ) ( s#device * , e#iommu_dev_features ) ; int ( * dev_disable_feat ) ( s#device * , e#iommu_dev_features ) ; void ( * page_response ) ( s#device * , s#iopf_fault * , s#iommu_page_response * ) ; int ( * def_domain_type ) ( s#device * ) ; void ( * remove_dev_pasid ) ( s#device * , t#ioasid_t , s#iommu_domain * ) ; const s#iommu_domain_ops * default_domain_ops ; unsigned long pgsize_bitmap ; s#module * owner ; s#iommu_domain * identity_domain ; s#iommu_domain * blocked_domain ; s#iommu_domain * release_domain ; s#iommu_domain * default_domain ; t#u8 user_pasid_table : 1 ; }
s#iommu_page_response struct iommu_page_response { t#u32 pasid ; t#u32 grpid ; t#u32 code ; }
s#iommu_user_data struct iommu_user_data { unsigned int type ; void * uptr ; t#size_t len ; }
s#iommu_user_data_array struct iommu_user_data_array { unsigned int type ; void * uptr ; t#size_t entry_len ; t#u32 entry_num ; }
s#iopf_fault struct iopf_fault { s#iommu_fault fault ; s#list_head list ; }
s#iopf_group struct iopf_group { s#iopf_fault last_fault ; s#list_head faults ; t#size_t fault_count ; s#list_head pending_node ; s#work_struct work ; s#iommu_attach_handle * attach_handle ; s#iommu_fault_param * fault_param ; s#list_head node ; t#u32 cookie ; }
s#iopf_queue struct iopf_queue { s#workqueue_struct * wq ; s#list_head devices ; s#mutex lock ; }
s#iov_iter@76413666 struct iov_iter { UNKNOWN }
s#iov_iter@aa255615 struct iov_iter { t#u8 iter_type ; t#bool nofault ; t#bool data_source ; t#size_t iov_offset ; union { s#iovec __ubuf_iovec ; struct { union { const s#iovec * __iov ; const s#kvec * kvec ; const s#bio_vec * bvec ; const s#folio_queue * folioq ; s#xarray * xarray ; void * ubuf ; } ; t#size_t count ; } ; } ; union { unsigned long nr_segs ; t#u8 folioq_slot ; t#loff_t xarray_start ; } ; }
s#iova_bitmap struct iova_bitmap { UNKNOWN }
s#iovec struct iovec { void * iov_base ; t#__kernel_size_t iov_len ; }
s#ip6_sf_list struct ip6_sf_list { s#ip6_sf_list * sf_next ; s#in6_addr sf_addr ; unsigned long sf_count [ 2 ] ; unsigned char sf_gsresp ; unsigned char sf_oldin ; unsigned char sf_crcount ; s#callback_head rcu ; }
s#ip_conntrack_stat struct ip_conntrack_stat { unsigned int found ; unsigned int invalid ; unsigned int insert ; unsigned int insert_failed ; unsigned int clash_resolve ; unsigned int drop ; unsigned int early_drop ; unsigned int error ; unsigned int expect_new ; unsigned int expect_create ; unsigned int expect_delete ; unsigned int search_restart ; unsigned int chaintoolong ; }
s#ip_ct_sctp struct ip_ct_sctp { e#sctp_conntrack state ; t#__be32 vtag [ E#IP_CT_DIR_MAX ] ; t#u8 init [ E#IP_CT_DIR_MAX ] ; t#u8 last_dir ; t#u8 flags ; }
s#ip_ct_tcp struct ip_ct_tcp { s#ip_ct_tcp_state seen [ 2 ] ; t#u_int8_t state ; t#u_int8_t last_dir ; t#u_int8_t retrans ; t#u_int8_t last_index ; t#u_int32_t last_seq ; t#u_int32_t last_ack ; t#u_int32_t last_end ; t#u_int16_t last_win ; t#u_int8_t last_wscale ; t#u_int8_t last_flags ; }
s#ip_ct_tcp_state struct ip_ct_tcp_state { t#u_int32_t td_end ; t#u_int32_t td_maxend ; t#u_int32_t td_maxwin ; t#u_int32_t td_maxack ; t#u_int8_t td_scale ; t#u_int8_t flags ; }
s#ip_mc_list@055d3767 struct ip_mc_list { s#in_device * interface ; t#__be32 multiaddr ; unsigned int sfmode ; s#ip_sf_list * sources ; s#ip_sf_list * tomb ; unsigned long sfcount [ 2 ] ; union { s#ip_mc_list * next ; s#ip_mc_list * next_rcu ; } ; s#ip_mc_list * next_hash ; s#timer_list timer ; int users ; t#refcount_t refcnt ; t#spinlock_t lock ; char tm_running ; char reporter ; char unsolicit_count ; char loaded ; unsigned char gsquery ; unsigned char crcount ; s#callback_head rcu ; }
s#ip_mc_list@f9cf7620 struct ip_mc_list { UNKNOWN }
s#ip_ra_chain@9f3c7244 struct ip_ra_chain { UNKNOWN }
s#ip_ra_chain@b9bbe5c8 struct ip_ra_chain { s#ip_ra_chain * next ; s#sock * sk ; union { void ( * destructor ) ( s#sock * ) ; s#sock * saved_sk ; } ; s#callback_head rcu ; }
s#ip_sf_list struct ip_sf_list { s#ip_sf_list * sf_next ; unsigned long sf_count [ 2 ] ; t#__be32 sf_inaddr ; unsigned char sf_gsresp ; unsigned char sf_oldin ; unsigned char sf_crcount ; }
s#ip_tunnel_encap struct ip_tunnel_encap { t#u16 type ; t#u16 flags ; t#__be16 sport ; t#__be16 dport ; }
s#ip_tunnel_info@4daf0583 struct ip_tunnel_info { UNKNOWN }
s#ip_tunnel_info@6e37f39f struct ip_tunnel_info { s#ip_tunnel_key key ; s#ip_tunnel_encap encap ; s#dst_cache dst_cache ; t#u8 options_len ; t#u8 mode ; }
s#ip_tunnel_key struct ip_tunnel_key { t#__be64 tun_id ; union { struct { t#__be32 src ; t#__be32 dst ; } ipv4 ; struct { s#in6_addr src ; s#in6_addr dst ; } ipv6 ; } u ; unsigned long tun_flags [ ( ( ( E#__IP_TUNNEL_FLAG_NUM ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; t#__be32 label ; t#u32 nhid ; t#u8 tos ; t#u8 ttl ; t#__be16 tp_src ; t#__be16 tp_dst ; t#__u8 flow_flags ; }
s#ip_tunnel_parm_kern@07919ad2 struct ip_tunnel_parm_kern { char name [ 16 ] ; unsigned long i_flags [ ( ( ( E#__IP_TUNNEL_FLAG_NUM ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long o_flags [ ( ( ( E#__IP_TUNNEL_FLAG_NUM ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; t#__be32 i_key ; t#__be32 o_key ; int link ; s#iphdr iph ; }
s#ip_tunnel_parm_kern@cca4cb16 struct ip_tunnel_parm_kern { UNKNOWN }
s#ip_vs_app struct ip_vs_app { s#list_head a_list ; int type ; char * name ; t#__u16 protocol ; s#module * module ; s#list_head incs_list ; s#list_head p_list ; s#ip_vs_app * app ; t#__be16 port ; t#atomic_t usecnt ; s#callback_head callback_head ; int ( * pkt_out ) ( s#ip_vs_app * , s#ip_vs_conn * , s#sk_buff * , int * , s#ip_vs_iphdr * ) ; int ( * pkt_in ) ( s#ip_vs_app * , s#ip_vs_conn * , s#sk_buff * , int * , s#ip_vs_iphdr * ) ; int ( * init_conn ) ( s#ip_vs_app * , s#ip_vs_conn * ) ; int ( * done_conn ) ( s#ip_vs_app * , s#ip_vs_conn * ) ; int ( * bind_conn ) ( s#ip_vs_app * , s#ip_vs_conn * , s#ip_vs_protocol * ) ; void ( * unbind_conn ) ( s#ip_vs_app * , s#ip_vs_conn * ) ; int * timeout_table ; int * timeouts ; int timeouts_size ; int ( * conn_schedule ) ( s#sk_buff * , s#ip_vs_app * , int * , s#ip_vs_conn * * ) ; s#ip_vs_conn * ( * conn_in_get ) ( const s#sk_buff * , s#ip_vs_app * , const s#iphdr * , int ) ; s#ip_vs_conn * ( * conn_out_get ) ( const s#sk_buff * , s#ip_vs_app * , const s#iphdr * , int ) ; int ( * state_transition ) ( s#ip_vs_conn * , int , const s#sk_buff * , s#ip_vs_app * ) ; void ( * timeout_change ) ( s#ip_vs_app * , int ) ; }
s#ip_vs_conn struct ip_vs_conn { s#hlist_node c_list ; t#__be16 cport ; t#__be16 dport ; t#__be16 vport ; t#u16 af ; u#nf_inet_addr caddr ; u#nf_inet_addr vaddr ; u#nf_inet_addr daddr ; volatile t#__u32 flags ; t#__u16 protocol ; t#__u16 daf ; s#netns_ipvs * ipvs ; t#refcount_t refcnt ; s#timer_list timer ; volatile unsigned long timeout ; t#spinlock_t lock ; volatile t#__u16 state ; volatile t#__u16 old_state ; t#__u32 fwmark ; unsigned long sync_endtime ; s#ip_vs_conn * control ; t#atomic_t n_control ; s#ip_vs_dest * dest ; t#atomic_t in_pkts ; int ( * packet_xmit ) ( s#sk_buff * , s#ip_vs_conn * , s#ip_vs_protocol * , s#ip_vs_iphdr * ) ; s#ip_vs_app * app ; void * app_data ; union { struct { s#ip_vs_seq in_seq ; s#ip_vs_seq out_seq ; } ; struct { s#ip_vs_seq in_seq ; s#ip_vs_seq out_seq ; } sync_conn_opt ; } ; const s#ip_vs_pe * pe ; char * pe_data ; t#__u8 pe_data_len ; s#callback_head callback_head ; }
s#ip_vs_conn_param struct ip_vs_conn_param { s#netns_ipvs * ipvs ; const u#nf_inet_addr * caddr ; const u#nf_inet_addr * vaddr ; t#__be16 cport ; t#__be16 vport ; t#__u16 protocol ; t#u16 af ; const s#ip_vs_pe * pe ; char * pe_data ; t#__u8 pe_data_len ; }
s#ip_vs_counters struct ip_vs_counters { t#u64_stats_t conns ; t#u64_stats_t inpkts ; t#u64_stats_t outpkts ; t#u64_stats_t inbytes ; t#u64_stats_t outbytes ; }
s#ip_vs_cpu_stats struct ip_vs_cpu_stats { s#ip_vs_counters cnt ; s#u64_stats_sync syncp ; }
s#ip_vs_dest struct ip_vs_dest { s#list_head n_list ; s#hlist_node d_list ; t#u16 af ; t#__be16 port ; u#nf_inet_addr addr ; volatile unsigned int flags ; t#atomic_t conn_flags ; t#atomic_t weight ; t#atomic_t last_weight ; t#__u16 tun_type ; t#__be16 tun_port ; t#__u16 tun_flags ; t#refcount_t refcnt ; s#ip_vs_stats stats ; unsigned long idle_start ; t#atomic_t activeconns ; t#atomic_t inactconns ; t#atomic_t persistconns ; t#__u32 u_threshold ; t#__u32 l_threshold ; t#spinlock_t dst_lock ; s#ip_vs_dest_dst * dest_dst ; s#ip_vs_service * svc ; t#__u16 protocol ; t#__be16 vport ; u#nf_inet_addr vaddr ; t#__u32 vfwmark ; s#callback_head callback_head ; s#list_head t_list ; unsigned int in_rs_table : 1 ; }
s#ip_vs_dest_dst struct ip_vs_dest_dst { s#dst_entry * dst_cache ; t#u32 dst_cookie ; u#nf_inet_addr dst_saddr ; s#callback_head callback_head ; }
s#ip_vs_est_kt_data struct ip_vs_est_kt_data { s#netns_ipvs * ipvs ; s#task_struct * task ; s#ip_vs_est_tick_data * ticks [ 50 ] ; unsigned long avail [ ( ( ( 50 ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long est_timer ; s#ip_vs_stats * calc_stats ; int tick_len [ 50 ] ; int id ; int chain_max ; int tick_max ; int est_count ; int est_max_count ; int add_row ; int est_row ; }
s#ip_vs_est_tick_data struct ip_vs_est_tick_data { s#callback_head callback_head ; s#hlist_head chains [ 1 ] ; unsigned long present [ ( ( ( 1 ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long full [ ( ( ( 1 ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; int chain_len [ 1 ] ; }
s#ip_vs_estimator struct ip_vs_estimator { s#hlist_node list ; t#u64 last_inbytes ; t#u64 last_outbytes ; t#u64 last_conns ; t#u64 last_inpkts ; t#u64 last_outpkts ; t#u64 cps ; t#u64 inpps ; t#u64 outpps ; t#u64 inbps ; t#u64 outbps ; t#s32 ktid : 16 , ktrow : 8 , ktcid : 8 ; }
s#ip_vs_iphdr struct ip_vs_iphdr { int hdr_flags ; t#__u32 off ; t#__u32 len ; t#__u16 fragoffs ; t#__s16 protocol ; t#__s32 flags ; u#nf_inet_addr saddr ; u#nf_inet_addr daddr ; }
s#ip_vs_kstats struct ip_vs_kstats { t#u64 conns ; t#u64 inpkts ; t#u64 outpkts ; t#u64 inbytes ; t#u64 outbytes ; t#u64 cps ; t#u64 inpps ; t#u64 outpps ; t#u64 inbps ; t#u64 outbps ; }
s#ip_vs_pe struct ip_vs_pe { s#list_head n_list ; char * name ; t#atomic_t refcnt ; s#module * module ; int ( * fill_param ) ( s#ip_vs_conn_param * , s#sk_buff * ) ; t#bool ( * ct_match ) ( const s#ip_vs_conn_param * , s#ip_vs_conn * ) ; t#u32 ( * hashkey_raw ) ( const s#ip_vs_conn_param * , t#u32 , t#bool ) ; int ( * show_pe_data ) ( const s#ip_vs_conn * , char * ) ; s#ip_vs_conn * ( * conn_out ) ( s#ip_vs_service * , s#ip_vs_dest * , s#sk_buff * , const s#ip_vs_iphdr * , t#__be16 , t#__be16 ) ; }
s#ip_vs_proto_data struct ip_vs_proto_data { s#ip_vs_proto_data * next ; s#ip_vs_protocol * pp ; int * timeout_table ; t#atomic_t appcnt ; s#tcp_states_t * tcp_state_table ; }
s#ip_vs_protocol struct ip_vs_protocol { s#ip_vs_protocol * next ; char * name ; t#u16 protocol ; t#u16 num_states ; int dont_defrag ; void ( * init ) ( s#ip_vs_protocol * ) ; void ( * exit ) ( s#ip_vs_protocol * ) ; int ( * init_netns ) ( s#netns_ipvs * , s#ip_vs_proto_data * ) ; void ( * exit_netns ) ( s#netns_ipvs * , s#ip_vs_proto_data * ) ; int ( * conn_schedule ) ( s#netns_ipvs * , int , s#sk_buff * , s#ip_vs_proto_data * , int * , s#ip_vs_conn * * , s#ip_vs_iphdr * ) ; s#ip_vs_conn * ( * conn_in_get ) ( s#netns_ipvs * , int , const s#sk_buff * , const s#ip_vs_iphdr * ) ; s#ip_vs_conn * ( * conn_out_get ) ( s#netns_ipvs * , int , const s#sk_buff * , const s#ip_vs_iphdr * ) ; int ( * snat_handler ) ( s#sk_buff * , s#ip_vs_protocol * , s#ip_vs_conn * , s#ip_vs_iphdr * ) ; int ( * dnat_handler ) ( s#sk_buff * , s#ip_vs_protocol * , s#ip_vs_conn * , s#ip_vs_iphdr * ) ; const char * ( * state_name ) ( int ) ; void ( * state_transition ) ( s#ip_vs_conn * , int , const s#sk_buff * , s#ip_vs_proto_data * ) ; int ( * register_app ) ( s#netns_ipvs * , s#ip_vs_app * ) ; void ( * unregister_app ) ( s#netns_ipvs * , s#ip_vs_app * ) ; int ( * app_conn_bind ) ( s#ip_vs_conn * ) ; void ( * debug_packet ) ( int , s#ip_vs_protocol * , const s#sk_buff * , int , const char * ) ; void ( * timeout_change ) ( s#ip_vs_proto_data * , int ) ; }
s#ip_vs_scheduler struct ip_vs_scheduler { s#list_head n_list ; char * name ; t#atomic_t refcnt ; s#module * module ; int ( * init_service ) ( s#ip_vs_service * ) ; void ( * done_service ) ( s#ip_vs_service * ) ; int ( * add_dest ) ( s#ip_vs_service * , s#ip_vs_dest * ) ; int ( * del_dest ) ( s#ip_vs_service * , s#ip_vs_dest * ) ; int ( * upd_dest ) ( s#ip_vs_service * , s#ip_vs_dest * ) ; s#ip_vs_dest * ( * schedule ) ( s#ip_vs_service * , const s#sk_buff * , s#ip_vs_iphdr * ) ; }
s#ip_vs_seq struct ip_vs_seq { t#__u32 init_seq ; t#__u32 delta ; t#__u32 previous_delta ; }
s#ip_vs_service struct ip_vs_service { s#hlist_node s_list ; s#hlist_node f_list ; t#atomic_t refcnt ; t#u16 af ; t#__u16 protocol ; u#nf_inet_addr addr ; t#__be16 port ; t#__u32 fwmark ; unsigned int flags ; unsigned int timeout ; t#__be32 netmask ; s#netns_ipvs * ipvs ; s#list_head destinations ; t#__u32 num_dests ; s#ip_vs_stats stats ; s#ip_vs_scheduler * scheduler ; t#spinlock_t sched_lock ; void * sched_data ; s#ip_vs_pe * pe ; int conntrack_afmask ; s#callback_head callback_head ; }
s#ip_vs_stats struct ip_vs_stats { s#ip_vs_kstats kstats ; s#ip_vs_estimator est ; s#ip_vs_cpu_stats * cpustats ; t#spinlock_t lock ; s#ip_vs_kstats kstats0 ; }
s#ip_vs_stats_rcu struct ip_vs_stats_rcu { s#ip_vs_stats s ; s#callback_head callback_head ; }
s#ip_vs_sync_buff struct ip_vs_sync_buff { UNKNOWN }
s#ip_vs_sync_thread_data struct ip_vs_sync_thread_data { UNKNOWN }
s#ipc_namespace struct ipc_namespace { UNKNOWN }
s#iphdr struct iphdr { t#__u8 ihl : 4 , version : 4 ; t#__u8 tos ; t#__be16 tot_len ; t#__be16 id ; t#__be16 frag_off ; t#__u8 ttl ; t#__u8 protocol ; t#__sum16 check ; union { struct { t#__be32 saddr ; t#__be32 daddr ; } ; struct { t#__be32 saddr ; t#__be32 daddr ; } addrs ; } ; }
s#ipstats_mib struct ipstats_mib { t#u64 mibs [ E#__IPSTATS_MIB_MAX ] ; s#u64_stats_sync syncp ; }
s#ipv4_devconf@565485a8 struct ipv4_devconf { void * sysctl ; int data [ ( E#__IPV4_DEVCONF_MAX - 1 ) ] ; unsigned long state [ ( ( ( ( E#__IPV4_DEVCONF_MAX - 1 ) ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; }
s#ipv4_devconf@97093f25 struct ipv4_devconf { UNKNOWN }
s#ipv6_devconf@7893195b struct ipv6_devconf { UNKNOWN }
s#ipv6_devconf@b2d0f0de struct ipv6_devconf { t#__u8 __cacheline_group_begin__ipv6_devconf_read_txrx [ 0 ] ; t#__s32 disable_ipv6 ; t#__s32 hop_limit ; t#__s32 mtu6 ; t#__s32 forwarding ; t#__s32 disable_policy ; t#__s32 proxy_ndp ; t#__u8 __cacheline_group_end__ipv6_devconf_read_txrx [ 0 ] ; t#__s32 accept_ra ; t#__s32 accept_redirects ; t#__s32 autoconf ; t#__s32 dad_transmits ; t#__s32 rtr_solicits ; t#__s32 rtr_solicit_interval ; t#__s32 rtr_solicit_max_interval ; t#__s32 rtr_solicit_delay ; t#__s32 force_mld_version ; t#__s32 mldv1_unsolicited_report_interval ; t#__s32 mldv2_unsolicited_report_interval ; t#__s32 use_tempaddr ; t#__s32 temp_valid_lft ; t#__s32 temp_prefered_lft ; t#__s32 regen_min_advance ; t#__s32 regen_max_retry ; t#__s32 max_desync_factor ; t#__s32 max_addresses ; t#__s32 accept_ra_defrtr ; t#__u32 ra_defrtr_metric ; t#__s32 accept_ra_min_hop_limit ; t#__s32 accept_ra_min_lft ; t#__s32 accept_ra_pinfo ; t#__s32 ignore_routes_with_linkdown ; t#__s32 accept_ra_rtr_pref ; t#__s32 rtr_probe_interval ; t#__s32 accept_ra_rt_info_min_plen ; t#__s32 accept_ra_rt_info_max_plen ; t#__s32 accept_source_route ; t#__s32 accept_ra_from_local ; t#__s32 optimistic_dad ; t#__s32 use_optimistic ; t#atomic_t mc_forwarding ; t#__s32 drop_unicast_in_l2_multicast ; t#__s32 accept_dad ; t#__s32 force_tllao ; t#__s32 ndisc_notify ; t#__s32 suppress_frag_ndisc ; t#__s32 accept_ra_mtu ; t#__s32 drop_unsolicited_na ; t#__s32 accept_untracked_na ; s#ipv6_stable_secret stable_secret ; t#__s32 use_oif_addrs_only ; t#__s32 keep_addr_on_down ; t#__s32 seg6_enabled ; t#__u32 enhanced_dad ; t#__u32 addr_gen_mode ; t#__s32 ndisc_tclass ; t#__s32 rpl_seg_enabled ; t#__u32 ioam6_id ; t#__u32 ioam6_id_wide ; t#__u8 ioam6_enabled ; t#__u8 ndisc_evict_nocarrier ; t#__u8 ra_honor_pio_life ; t#__u8 ra_honor_pio_pflag ; s#ctl_table_header * sysctl_header ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; }
s#ipv6_devstat struct ipv6_devstat { s#proc_dir_entry * proc_dir_entry ; __typeof__ ( s#ipstats_mib ) * ipv6 ; __typeof__ ( s#icmpv6_mib_device ) * icmpv6dev ; __typeof__ ( s#icmpv6msg_mib_device ) * icmpv6msgdev ; }
s#ipv6_stable_secret struct ipv6_stable_secret { t#bool initialized ; s#in6_addr secret ; }
s#ipvs_master_sync_state struct ipvs_master_sync_state { s#list_head sync_queue ; s#ip_vs_sync_buff * sync_buff ; unsigned long sync_queue_len ; unsigned int sync_queue_delay ; s#delayed_work master_wakeup_work ; s#netns_ipvs * ipvs ; }
s#ipvs_sync_daemon_cfg struct ipvs_sync_daemon_cfg { u#nf_inet_addr mcast_group ; int syncid ; t#u16 sync_maxlen ; t#u16 mcast_port ; t#u8 mcast_af ; t#u8 mcast_ttl ; char mcast_ifn [ 16 ] ; }
s#irq_affinity_desc@55f280c4 struct irq_affinity_desc { UNKNOWN }
s#irq_affinity_desc@fe1e4133 struct irq_affinity_desc { s#cpumask mask ; unsigned int is_managed : 1 ; }
s#irq_affinity_notify@2a9cac88 struct irq_affinity_notify { unsigned int irq ; s#kref kref ; s#work_struct work ; void ( * notify ) ( s#irq_affinity_notify * , const t#cpumask_t * ) ; void ( * release ) ( s#kref * ) ; }
s#irq_affinity_notify@7c091feb struct irq_affinity_notify { UNKNOWN }
s#irq_alloc_info struct irq_alloc_info { e#irq_alloc_type type ; t#u32 flags ; t#u32 devid ; t#irq_hw_number_t hwirq ; const s#cpumask * mask ; s#msi_desc * desc ; void * data ; union { s#ioapic_alloc_info ioapic ; s#uv_alloc_info uv ; } ; }
s#irq_chip struct irq_chip { const char * name ; unsigned int ( * irq_startup ) ( s#irq_data * ) ; void ( * irq_shutdown ) ( s#irq_data * ) ; void ( * irq_enable ) ( s#irq_data * ) ; void ( * irq_disable ) ( s#irq_data * ) ; void ( * irq_ack ) ( s#irq_data * ) ; void ( * irq_mask ) ( s#irq_data * ) ; void ( * irq_mask_ack ) ( s#irq_data * ) ; void ( * irq_unmask ) ( s#irq_data * ) ; void ( * irq_eoi ) ( s#irq_data * ) ; int ( * irq_set_affinity ) ( s#irq_data * , const s#cpumask * , t#bool ) ; int ( * irq_retrigger ) ( s#irq_data * ) ; int ( * irq_set_type ) ( s#irq_data * , unsigned int ) ; int ( * irq_set_wake ) ( s#irq_data * , unsigned int ) ; void ( * irq_bus_lock ) ( s#irq_data * ) ; void ( * irq_bus_sync_unlock ) ( s#irq_data * ) ; void ( * irq_suspend ) ( s#irq_data * ) ; void ( * irq_resume ) ( s#irq_data * ) ; void ( * irq_pm_shutdown ) ( s#irq_data * ) ; void ( * irq_calc_mask ) ( s#irq_data * ) ; void ( * irq_print_chip ) ( s#irq_data * , s#seq_file * ) ; int ( * irq_request_resources ) ( s#irq_data * ) ; void ( * irq_release_resources ) ( s#irq_data * ) ; void ( * irq_compose_msi_msg ) ( s#irq_data * , s#msi_msg * ) ; void ( * irq_write_msi_msg ) ( s#irq_data * , s#msi_msg * ) ; int ( * irq_get_irqchip_state ) ( s#irq_data * , e#irqchip_irq_state , t#bool * ) ; int ( * irq_set_irqchip_state ) ( s#irq_data * , e#irqchip_irq_state , t#bool ) ; int ( * irq_set_vcpu_affinity ) ( s#irq_data * , void * ) ; void ( * ipi_send_single ) ( s#irq_data * , unsigned int ) ; void ( * ipi_send_mask ) ( s#irq_data * , const s#cpumask * ) ; int ( * irq_nmi_setup ) ( s#irq_data * ) ; void ( * irq_nmi_teardown ) ( s#irq_data * ) ; unsigned long flags ; }
s#irq_chip_generic struct irq_chip_generic { t#raw_spinlock_t lock ; void * reg_base ; t#u32 ( * reg_readl ) ( void * ) ; void ( * reg_writel ) ( t#u32 , void * ) ; void ( * suspend ) ( s#irq_chip_generic * ) ; void ( * resume ) ( s#irq_chip_generic * ) ; unsigned int irq_base ; unsigned int irq_cnt ; t#u32 mask_cache ; t#u32 wake_enabled ; t#u32 wake_active ; unsigned int num_ct ; void * private ; unsigned long installed ; unsigned long unused ; s#irq_domain * domain ; s#list_head list ; s#irq_chip_type chip_types [ ] ; }
s#irq_chip_regs struct irq_chip_regs { unsigned long enable ; unsigned long disable ; unsigned long mask ; unsigned long ack ; unsigned long eoi ; unsigned long type ; }
s#irq_chip_type struct irq_chip_type { s#irq_chip chip ; s#irq_chip_regs regs ; t#irq_flow_handler_t handler ; t#u32 type ; t#u32 mask_cache_priv ; t#u32 * mask_cache ; }
s#irq_common_data struct irq_common_data { unsigned int state_use_accessors ; unsigned int node ; void * handler_data ; s#msi_desc * msi_desc ; t#cpumask_var_t affinity ; t#cpumask_var_t effective_affinity ; }
s#irq_data@d5e32130 struct irq_data { UNKNOWN }
s#irq_data@f61673cf struct irq_data { t#u32 mask ; unsigned int irq ; t#irq_hw_number_t hwirq ; s#irq_common_data * common ; s#irq_chip * chip ; s#irq_domain * domain ; s#irq_data * parent_data ; void * chip_data ; }
s#irq_desc struct irq_desc { s#irq_common_data irq_common_data ; s#irq_data irq_data ; s#irqstat * kstat_irqs ; t#irq_flow_handler_t handle_irq ; s#irqaction * action ; unsigned int status_use_accessors ; unsigned int core_internal_state__do_not_mess_with_it ; unsigned int depth ; unsigned int wake_depth ; unsigned int tot_count ; unsigned int irq_count ; unsigned long last_unhandled ; unsigned int irqs_unhandled ; t#atomic_t threads_handled ; int threads_handled_last ; t#raw_spinlock_t lock ; s#cpumask * percpu_enabled ; const s#cpumask * percpu_affinity ; const s#cpumask * affinity_hint ; s#irq_affinity_notify * affinity_notify ; t#cpumask_var_t pending_mask ; unsigned long threads_oneshot ; t#atomic_t threads_active ; t#wait_queue_head_t wait_for_threads ; unsigned int nr_actions ; unsigned int no_suspend_depth ; unsigned int cond_suspend_depth ; unsigned int force_resume_depth ; s#proc_dir_entry * dir ; s#dentry * debugfs_file ; const char * dev_name ; s#callback_head rcu ; s#kobject kobj ; s#mutex request_mutex ; int parent_irq ; s#module * owner ; const char * name ; s#hlist_node resend_node ; }
s#irq_domain@27204fc0 struct irq_domain { UNKNOWN }
s#irq_domain@634338af struct irq_domain { s#list_head link ; const char * name ; const s#irq_domain_ops * ops ; void * host_data ; unsigned int flags ; unsigned int mapcount ; s#mutex mutex ; s#irq_domain * root ; s#fwnode_handle * fwnode ; e#irq_domain_bus_token bus_token ; s#irq_domain_chip_generic * gc ; s#device * dev ; s#device * pm_dev ; s#irq_domain * parent ; const s#msi_parent_ops * msi_parent_ops ; void ( * exit ) ( s#irq_domain * ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; t#irq_hw_number_t hwirq_max ; unsigned int revmap_size ; s#xarray revmap_tree ; s#irq_data * revmap [ ] ; }
s#irq_domain_chip_generic@0d384feb struct irq_domain_chip_generic { unsigned int irqs_per_chip ; unsigned int num_chips ; unsigned int irq_flags_to_clear ; unsigned int irq_flags_to_set ; e#irq_gc_flags gc_flags ; void ( * exit ) ( s#irq_chip_generic * ) ; s#irq_chip_generic * gc [ ] ; }
s#irq_domain_chip_generic@a950c4c2 struct irq_domain_chip_generic { UNKNOWN }
s#irq_domain_ops struct irq_domain_ops { int ( * match ) ( s#irq_domain * , s#device_node * , e#irq_domain_bus_token ) ; int ( * select ) ( s#irq_domain * , s#irq_fwspec * , e#irq_domain_bus_token ) ; int ( * map ) ( s#irq_domain * , unsigned int , t#irq_hw_number_t ) ; void ( * unmap ) ( s#irq_domain * , unsigned int ) ; int ( * xlate ) ( s#irq_domain * , s#device_node * , const t#u32 * , unsigned int , unsigned long * , unsigned int * ) ; int ( * alloc ) ( s#irq_domain * , unsigned int , unsigned int , void * ) ; void ( * free ) ( s#irq_domain * , unsigned int , unsigned int ) ; int ( * activate ) ( s#irq_domain * , s#irq_data * , t#bool ) ; void ( * deactivate ) ( s#irq_domain * , s#irq_data * ) ; int ( * translate ) ( s#irq_domain * , s#irq_fwspec * , unsigned long * , unsigned int * ) ; void ( * debug_show ) ( s#seq_file * , s#irq_domain * , s#irq_data * , int ) ; }
s#irq_fwspec struct irq_fwspec { s#fwnode_handle * fwnode ; int param_count ; t#u32 param [ 16 ] ; }
s#irq_poll struct irq_poll { s#list_head list ; unsigned long state ; int weight ; t#irq_poll_fn * poll ; }
s#irq_work struct irq_work { s#__call_single_node node ; void ( * func ) ( s#irq_work * ) ; s#rcuwait irqwait ; }
s#irqaction@ba286ba9 struct irqaction { t#irq_handler_t handler ; void * dev_id ; void * percpu_dev_id ; s#irqaction * next ; t#irq_handler_t thread_fn ; s#task_struct * thread ; s#irqaction * secondary ; unsigned int irq ; unsigned int flags ; unsigned long thread_flags ; unsigned long thread_mask ; const char * name ; s#proc_dir_entry * dir ; }
s#irqaction@d1da71ce struct irqaction { UNKNOWN }
s#irqstat struct irqstat { unsigned int cnt ; }
s#iw_cm_conn_param@488e5ced struct iw_cm_conn_param { const void * private_data ; t#u16 private_data_len ; t#u32 ord ; t#u32 ird ; t#u32 qpn ; }
s#iw_cm_conn_param@82ed8ed9 struct iw_cm_conn_param { UNKNOWN }
s#iw_cm_event struct iw_cm_event { e#iw_cm_event_type event ; int status ; s#__kernel_sockaddr_storage local_addr ; s#__kernel_sockaddr_storage remote_addr ; void * private_data ; void * provider_data ; t#u8 private_data_len ; t#u8 ord ; t#u8 ird ; }
s#iw_cm_id@0666316f struct iw_cm_id { UNKNOWN }
s#iw_cm_id@5e9cbfd2 struct iw_cm_id { t#iw_cm_handler cm_handler ; void * context ; s#ib_device * device ; s#__kernel_sockaddr_storage local_addr ; s#__kernel_sockaddr_storage remote_addr ; s#__kernel_sockaddr_storage m_local_addr ; s#__kernel_sockaddr_storage m_remote_addr ; void * provider_data ; t#iw_event_handler event_handler ; void ( * add_ref ) ( s#iw_cm_id * ) ; void ( * rem_ref ) ( s#iw_cm_id * ) ; t#u8 tos ; t#bool tos_set : 1 ; t#bool mapped : 1 ; t#bool afonly : 1 ; }
s#iw_discarded struct iw_discarded { t#__u32 nwid ; t#__u32 code ; t#__u32 fragment ; t#__u32 retries ; t#__u32 misc ; }
s#iw_freq struct iw_freq { t#__s32 m ; t#__s16 e ; t#__u8 i ; t#__u8 flags ; }
s#iw_handler_def@2758a185 struct iw_handler_def { const t#iw_handler * standard ; t#__u16 num_standard ; t#__u16 num_private ; t#__u16 num_private_args ; const t#iw_handler * private ; const s#iw_priv_args * private_args ; s#iw_statistics * ( * get_wireless_stats ) ( s#net_device * ) ; }
s#iw_handler_def@c89ad982 struct iw_handler_def { UNKNOWN }
s#iw_missed struct iw_missed { t#__u32 beacon ; }
s#iw_param struct iw_param { t#__s32 value ; t#__u8 fixed ; t#__u8 disabled ; t#__u16 flags ; }
s#iw_point struct iw_point { void * pointer ; t#__u16 length ; t#__u16 flags ; }
s#iw_priv_args struct iw_priv_args { t#__u32 cmd ; t#__u16 set_args ; t#__u16 get_args ; char name [ 16 ] ; }
s#iw_public_data@301f3163 struct iw_public_data { s#iw_spy_data * spy_data ; s#libipw_device * libipw ; }
s#iw_public_data@41c9989c struct iw_public_data { UNKNOWN }
s#iw_quality struct iw_quality { t#__u8 qual ; t#__u8 level ; t#__u8 noise ; t#__u8 updated ; }
s#iw_request_info struct iw_request_info { t#__u16 cmd ; t#__u16 flags ; }
s#iw_spy_data struct iw_spy_data { int spy_number ; t#u_char spy_address [ 8 ] [ 6 ] ; s#iw_quality spy_stat [ 8 ] ; s#iw_quality spy_thr_low ; s#iw_quality spy_thr_high ; t#u_char spy_thr_under [ 8 ] ; }
s#iw_statistics struct iw_statistics { t#__u16 status ; s#iw_quality qual ; s#iw_discarded discard ; s#iw_missed miss ; }
s#jump_entry struct jump_entry { t#s32 code ; t#s32 target ; long key ; }
s#k_sigaction struct k_sigaction { s#sigaction sa ; }
s#kernel_ethtool_coalesce struct kernel_ethtool_coalesce { t#u8 use_cqe_mode_tx ; t#u8 use_cqe_mode_rx ; t#u32 tx_aggr_max_bytes ; t#u32 tx_aggr_max_frames ; t#u32 tx_aggr_time_usecs ; }
s#kernel_ethtool_ringparam struct kernel_ethtool_ringparam { t#u32 rx_buf_len ; t#u8 tcp_data_split ; t#u8 tx_push ; t#u8 rx_push ; t#u32 cqe_size ; t#u32 tx_push_buf_len ; t#u32 tx_push_buf_max_len ; }
s#kernel_ethtool_ts_info struct kernel_ethtool_ts_info { t#u32 cmd ; t#u32 so_timestamping ; int phc_index ; e#hwtstamp_tx_types tx_types ; e#hwtstamp_rx_filters rx_filters ; }
s#kernel_hwtstamp_config@0606f718 struct kernel_hwtstamp_config { int flags ; int tx_type ; int rx_filter ; s#ifreq * ifr ; t#bool copied_to_user ; e#hwtstamp_source source ; }
s#kernel_hwtstamp_config@9fdcb0e7 struct kernel_hwtstamp_config { UNKNOWN }
s#kernel_param struct kernel_param { const char * name ; s#module * mod ; const s#kernel_param_ops * ops ; const t#u16 perm ; t#s8 level ; t#u8 flags ; union { void * arg ; const s#kparam_string * str ; const s#kparam_array * arr ; } ; }
s#kernel_param_ops struct kernel_param_ops { unsigned int flags ; int ( * set ) ( const char * , const s#kernel_param * ) ; int ( * get ) ( char * , const s#kernel_param * ) ; void ( * free ) ( void * ) ; }
s#kernel_pkey_params@1ee022fb struct kernel_pkey_params { UNKNOWN }
s#kernel_pkey_params@96107994 struct kernel_pkey_params { s#key * key ; const char * encoding ; const char * hash_algo ; char * info ; t#__u32 in_len ; union { t#__u32 out_len ; t#__u32 in2_len ; } ; e#kernel_pkey_operation op : 8 ; }
s#kernel_pkey_query@dc358d8c struct kernel_pkey_query { t#__u32 supported_ops ; t#__u32 key_size ; t#__u16 max_data_size ; t#__u16 max_sig_size ; t#__u16 max_enc_size ; t#__u16 max_dec_size ; }
s#kernel_pkey_query@e83d355e struct kernel_pkey_query { UNKNOWN }
s#kernel_siginfo struct kernel_siginfo { struct { int si_signo ; int si_errno ; int si_code ; u#__sifields _sifields ; } ; }
s#kernel_symbol@1688e719 struct kernel_symbol { int value_offset ; int name_offset ; int namespace_offset ; }
s#kernel_symbol@93dc0cff struct kernel_symbol { UNKNOWN }
s#kernfs_elem_attr struct kernfs_elem_attr { const s#kernfs_ops * ops ; s#kernfs_open_node * open ; t#loff_t size ; s#kernfs_node * notify_next ; }
s#kernfs_elem_dir struct kernfs_elem_dir { unsigned long subdirs ; s#rb_root children ; s#kernfs_root * root ; unsigned long rev ; }
s#kernfs_elem_symlink struct kernfs_elem_symlink { s#kernfs_node * target_kn ; }
s#kernfs_iattrs@58e69d36 struct kernfs_iattrs { UNKNOWN }
s#kernfs_iattrs@ff8b10e3 struct kernfs_iattrs { t#kuid_t ia_uid ; t#kgid_t ia_gid ; s#timespec64 ia_atime ; s#timespec64 ia_mtime ; s#timespec64 ia_ctime ; s#simple_xattrs xattrs ; t#atomic_t nr_user_xattrs ; t#atomic_t user_xattr_size ; }
s#kernfs_node struct kernfs_node { t#atomic_t count ; t#atomic_t active ; s#kernfs_node * parent ; const char * name ; s#rb_node rb ; const void * ns ; unsigned int hash ; unsigned short flags ; t#umode_t mode ; union { s#kernfs_elem_dir dir ; s#kernfs_elem_symlink symlink ; s#kernfs_elem_attr attr ; } ; t#u64 id ; void * priv ; s#kernfs_iattrs * iattr ; s#callback_head rcu ; }
s#kernfs_open_file struct kernfs_open_file { s#kernfs_node * kn ; s#file * file ; s#seq_file * seq_file ; void * priv ; s#mutex mutex ; s#mutex prealloc_mutex ; int event ; s#list_head list ; char * prealloc_buf ; t#size_t atomic_write_len ; t#bool mmapped : 1 ; t#bool released : 1 ; const s#vm_operations_struct * vm_ops ; }
s#kernfs_open_node struct kernfs_open_node { UNKNOWN }
s#kernfs_ops struct kernfs_ops { int ( * open ) ( s#kernfs_open_file * ) ; void ( * release ) ( s#kernfs_open_file * ) ; int ( * seq_show ) ( s#seq_file * , void * ) ; void * ( * seq_start ) ( s#seq_file * , t#loff_t * ) ; void * ( * seq_next ) ( s#seq_file * , void * , t#loff_t * ) ; void ( * seq_stop ) ( s#seq_file * , void * ) ; t#ssize_t ( * read ) ( s#kernfs_open_file * , char * , t#size_t , t#loff_t ) ; t#size_t atomic_write_len ; t#bool prealloc ; t#ssize_t ( * write ) ( s#kernfs_open_file * , char * , t#size_t , t#loff_t ) ; t#__poll_t ( * poll ) ( s#kernfs_open_file * , s#poll_table_struct * ) ; int ( * mmap ) ( s#kernfs_open_file * , s#vm_area_struct * ) ; t#loff_t ( * llseek ) ( s#kernfs_open_file * , t#loff_t , int ) ; }
s#kernfs_root@36eeb110 struct kernfs_root { UNKNOWN }
s#kernfs_root@cf50b0ad struct kernfs_root { s#kernfs_node * kn ; unsigned int flags ; s#idr ino_idr ; t#u32 last_id_lowbits ; t#u32 id_highbits ; s#kernfs_syscall_ops * syscall_ops ; s#list_head supers ; t#wait_queue_head_t deactivate_waitq ; s#rw_semaphore kernfs_rwsem ; s#rw_semaphore kernfs_iattr_rwsem ; s#rw_semaphore kernfs_supers_rwsem ; s#callback_head rcu ; }
s#kernfs_syscall_ops struct kernfs_syscall_ops { int ( * show_options ) ( s#seq_file * , s#kernfs_root * ) ; int ( * mkdir ) ( s#kernfs_node * , const char * , t#umode_t ) ; int ( * rmdir ) ( s#kernfs_node * ) ; int ( * rename ) ( s#kernfs_node * , s#kernfs_node * , const char * ) ; int ( * show_path ) ( s#seq_file * , s#kernfs_node * , s#kernfs_root * ) ; }
s#key@3d33306b struct key { UNKNOWN }
s#key@daa923af struct key { t#refcount_t usage ; t#key_serial_t serial ; union { s#list_head graveyard_link ; s#rb_node serial_node ; } ; s#watch_list * watchers ; s#rw_semaphore sem ; s#key_user * user ; void * security ; union { t#time64_t expiry ; t#time64_t revoked_at ; } ; t#time64_t last_used_at ; t#kuid_t uid ; t#kgid_t gid ; t#key_perm_t perm ; unsigned short quotalen ; unsigned short datalen ; short state ; unsigned long flags ; union { s#keyring_index_key index_key ; struct { unsigned long hash ; unsigned long len_desc ; s#key_type * type ; s#key_tag * domain_tag ; char * description ; } ; } ; union { u#key_payload payload ; struct { s#list_head name_link ; s#assoc_array keys ; } ; } ; s#key_restriction * restrict_link ; }
s#key_match_data struct key_match_data { t#bool ( * cmp ) ( const s#key * , const s#key_match_data * ) ; const void * raw_data ; void * preparsed ; unsigned lookup_type ; }
s#key_params struct key_params { const t#u8 * key ; const t#u8 * seq ; int key_len ; int seq_len ; t#u16 vlan_id ; t#u32 cipher ; e#nl80211_key_mode mode ; }
s#key_preparsed_payload struct key_preparsed_payload { const char * orig_description ; char * description ; u#key_payload payload ; const void * data ; t#size_t datalen ; t#size_t quotalen ; t#time64_t expiry ; }
s#key_restriction struct key_restriction { t#key_restrict_link_func_t check ; s#key * key ; s#key_type * keytype ; }
s#key_tag struct key_tag { s#callback_head rcu ; t#refcount_t usage ; t#bool removed ; }
s#key_type@856c83c0 struct key_type { UNKNOWN }
s#key_type@d979dd54 struct key_type { const char * name ; t#size_t def_datalen ; unsigned int flags ; int ( * vet_description ) ( const char * ) ; int ( * preparse ) ( s#key_preparsed_payload * ) ; void ( * free_preparse ) ( s#key_preparsed_payload * ) ; int ( * instantiate ) ( s#key * , s#key_preparsed_payload * ) ; int ( * update ) ( s#key * , s#key_preparsed_payload * ) ; int ( * match_preparse ) ( s#key_match_data * ) ; void ( * match_free ) ( s#key_match_data * ) ; void ( * revoke ) ( s#key * ) ; void ( * destroy ) ( s#key * ) ; void ( * describe ) ( const s#key * , s#seq_file * ) ; long ( * read ) ( const s#key * , char * , t#size_t ) ; t#request_key_actor_t request_key ; s#key_restriction * ( * lookup_restriction ) ( const char * ) ; int ( * asym_query ) ( const s#kernel_pkey_params * , s#kernel_pkey_query * ) ; int ( * asym_eds_op ) ( s#kernel_pkey_params * , const void * , void * ) ; int ( * asym_verify_signature ) ( s#kernel_pkey_params * , const void * , const void * ) ; s#list_head link ; s#lock_class_key lock_class ; }
s#key_user@35e5d8d6 struct key_user { UNKNOWN }
s#key_user@ce2adfb1 struct key_user { s#rb_node node ; s#mutex cons_lock ; t#spinlock_t lock ; t#refcount_t usage ; t#atomic_t nkeys ; t#atomic_t nikeys ; t#kuid_t uid ; int qnkeys ; int qnbytes ; }
s#keyring_index_key struct keyring_index_key { unsigned long hash ; union { struct { t#u16 desc_len ; char desc [ sizeof ( long ) - 2 ] ; } ; unsigned long x ; } ; s#key_type * type ; s#key_tag * domain_tag ; const char * description ; }
s#kiocb struct kiocb { s#file * ki_filp ; t#loff_t ki_pos ; void ( * ki_complete ) ( s#kiocb * , long ) ; void * private ; int ki_flags ; t#u16 ki_ioprio ; union { s#wait_page_queue * ki_waitq ; t#ssize_t ( * dio_complete ) ( void * ) ; } ; }
s#kioctx_table struct kioctx_table { UNKNOWN }
s#klist struct klist { t#spinlock_t k_lock ; s#list_head k_list ; void ( * get ) ( s#klist_node * ) ; void ( * put ) ( s#klist_node * ) ; }
s#klist_node struct klist_node { void * n_klist ; s#list_head n_node ; s#kref n_ref ; }
s#kmap_ctrl struct kmap_ctrl { }
s#kmem_cache@628730d2 struct kmem_cache { s#kmem_cache_cpu * cpu_slab ; t#slab_flags_t flags ; unsigned long min_partial ; unsigned int size ; unsigned int object_size ; s#reciprocal_value reciprocal_size ; unsigned int offset ; unsigned int cpu_partial ; unsigned int cpu_partial_slabs ; s#kmem_cache_order_objects oo ; s#kmem_cache_order_objects min ; t#gfp_t allocflags ; int refcount ; void ( * ctor ) ( void * ) ; unsigned int inuse ; unsigned int align ; unsigned int red_left_pad ; const char * name ; s#list_head list ; s#kobject kobj ; unsigned long random ; unsigned int remote_node_defrag_ratio ; unsigned int * random_seq ; unsigned int useroffset ; unsigned int usersize ; s#kmem_cache_node * node [ ( 1 << 10 ) ] ; }
s#kmem_cache@bb73f614 struct kmem_cache { UNKNOWN }
s#kmem_cache_args struct kmem_cache_args { unsigned int align ; unsigned int useroffset ; unsigned int usersize ; unsigned int freeptr_offset ; t#bool use_freeptr_offset ; void ( * ctor ) ( void * ) ; }
s#kmem_cache_cpu struct kmem_cache_cpu { UNKNOWN }
s#kmem_cache_node struct kmem_cache_node { UNKNOWN }
s#kmem_cache_order_objects struct kmem_cache_order_objects { unsigned int x ; }
s#kobj_ns_type_operations struct kobj_ns_type_operations { e#kobj_ns_type type ; t#bool ( * current_may_mount ) ( void ) ; void * ( * grab_current_ns ) ( void ) ; const void * ( * netlink_ns ) ( s#sock * ) ; const void * ( * initial_ns ) ( void ) ; void ( * drop_ns ) ( void * ) ; }
s#kobj_type struct kobj_type { void ( * release ) ( s#kobject * ) ; const s#sysfs_ops * sysfs_ops ; const s#attribute_group * * default_groups ; const s#kobj_ns_type_operations * ( * child_ns_type ) ( const s#kobject * ) ; const void * ( * namespace ) ( const s#kobject * ) ; void ( * get_ownership ) ( const s#kobject * , t#kuid_t * , t#kgid_t * ) ; }
s#kobj_uevent_env struct kobj_uevent_env { char * argv [ 3 ] ; char * envp [ 64 ] ; int envp_idx ; char buf [ 2048 ] ; int buflen ; }
s#kobject@1a5ace0a struct kobject { const char * name ; s#list_head entry ; s#kobject * parent ; s#kset * kset ; const s#kobj_type * ktype ; s#kernfs_node * sd ; s#kref kref ; unsigned int state_initialized : 1 ; unsigned int state_in_sysfs : 1 ; unsigned int state_add_uevent_sent : 1 ; unsigned int state_remove_uevent_sent : 1 ; unsigned int uevent_suppress : 1 ; }
s#kobject@e7f858ef struct kobject { UNKNOWN }
s#kparam_array struct kparam_array { unsigned int max ; unsigned int elemsize ; unsigned int * num ; const s#kernel_param_ops * ops ; void * elem ; }
s#kparam_string struct kparam_string { unsigned int maxlen ; char * string ; }
s#kqid struct kqid { union { t#kuid_t uid ; t#kgid_t gid ; t#kprojid_t projid ; } ; e#quota_type type ; }
s#kref struct kref { t#refcount_t refcount ; }
s#kset struct kset { s#list_head list ; t#spinlock_t list_lock ; s#kobject kobj ; const s#kset_uevent_ops * uevent_ops ; }
s#kset_uevent_ops struct kset_uevent_ops { int ( * const filter ) ( const s#kobject * ) ; const char * ( * const name ) ( const s#kobject * ) ; int ( * const uevent ) ( const s#kobject * , s#kobj_uevent_env * ) ; }
s#kstat struct kstat { t#u32 result_mask ; t#umode_t mode ; unsigned int nlink ; t#uint32_t blksize ; t#u64 attributes ; t#u64 attributes_mask ; t#u64 ino ; t#dev_t dev ; t#dev_t rdev ; t#kuid_t uid ; t#kgid_t gid ; t#loff_t size ; s#timespec64 atime ; s#timespec64 mtime ; s#timespec64 ctime ; s#timespec64 btime ; t#u64 blocks ; t#u64 mnt_id ; t#u32 dio_mem_align ; t#u32 dio_offset_align ; t#u64 change_cookie ; t#u64 subvol ; t#u32 atomic_write_unit_min ; t#u32 atomic_write_unit_max ; t#u32 atomic_write_segments_max ; }
s#kstatfs@195c0481 struct kstatfs { UNKNOWN }
s#kstatfs@3663e9fd struct kstatfs { long f_type ; long f_bsize ; t#u64 f_blocks ; t#u64 f_bfree ; t#u64 f_bavail ; t#u64 f_files ; t#u64 f_ffree ; t#__kernel_fsid_t f_fsid ; long f_namelen ; long f_frsize ; long f_flags ; long f_spare [ 4 ] ; }
s#ktermios struct ktermios { t#tcflag_t c_iflag ; t#tcflag_t c_oflag ; t#tcflag_t c_cflag ; t#tcflag_t c_lflag ; t#cc_t c_line ; t#cc_t c_cc [ 19 ] ; t#speed_t c_ispeed ; t#speed_t c_ospeed ; }
s#kvec struct kvec { void * iov_base ; t#size_t iov_len ; }
s#l3mdev_ops@705e73d8 struct l3mdev_ops { t#u32 ( * l3mdev_fib_table ) ( const s#net_device * ) ; s#sk_buff * ( * l3mdev_l3_rcv ) ( s#net_device * , s#sk_buff * , t#u16 ) ; s#sk_buff * ( * l3mdev_l3_out ) ( s#net_device * , s#sock * , s#sk_buff * , t#u16 ) ; s#dst_entry * ( * l3mdev_link_scope_lookup ) ( const s#net_device * , s#flowi6 * ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; }
s#l3mdev_ops@957f97dc struct l3mdev_ops { UNKNOWN }
s#latch_tree_node struct latch_tree_node { s#rb_node node [ 2 ] ; }
s#ld_semaphore struct ld_semaphore { t#atomic_long_t count ; t#raw_spinlock_t wait_lock ; unsigned int wait_readers ; s#list_head read_wait ; s#list_head write_wait ; }
s#ldt_struct@408584e6 struct ldt_struct { UNKNOWN }
s#ldt_struct@b304f10d struct ldt_struct { s#desc_struct * entries ; unsigned int nr_entries ; int slot ; }
s#lease_manager_operations struct lease_manager_operations { t#bool ( * lm_break ) ( s#file_lease * ) ; int ( * lm_change ) ( s#file_lease * , int , s#list_head * ) ; void ( * lm_setup ) ( s#file_lease * , void * * ) ; t#bool ( * lm_breaker_owns_lease ) ( s#file_lease * ) ; unsigned long uek_reserved1 ; }
s#led_classdev@8127762a struct led_classdev { UNKNOWN }
s#led_classdev@c5c4fbaa struct led_classdev { const char * name ; unsigned int brightness ; unsigned int max_brightness ; unsigned int color ; int flags ; unsigned long work_flags ; void ( * brightness_set ) ( s#led_classdev * , e#led_brightness ) ; int ( * brightness_set_blocking ) ( s#led_classdev * , e#led_brightness ) ; e#led_brightness ( * brightness_get ) ( s#led_classdev * ) ; int ( * blink_set ) ( s#led_classdev * , unsigned long * , unsigned long * ) ; int ( * pattern_set ) ( s#led_classdev * , s#led_pattern * , t#u32 , int ) ; int ( * pattern_clear ) ( s#led_classdev * ) ; s#device * dev ; const s#attribute_group * * groups ; s#list_head node ; const char * default_trigger ; unsigned long blink_delay_on , blink_delay_off ; s#timer_list blink_timer ; int blink_brightness ; int new_blink_brightness ; void ( * flash_resume ) ( s#led_classdev * ) ; s#work_struct set_brightness_work ; int delayed_set_value ; unsigned long delayed_delay_on ; unsigned long delayed_delay_off ; s#rw_semaphore trigger_lock ; s#led_trigger * trigger ; s#list_head trig_list ; void * trigger_data ; t#bool activated ; s#led_hw_trigger_type * trigger_type ; const char * hw_control_trigger ; int ( * hw_control_is_supported ) ( s#led_classdev * , unsigned long ) ; int ( * hw_control_set ) ( s#led_classdev * , unsigned long ) ; int ( * hw_control_get ) ( s#led_classdev * , unsigned long * ) ; s#device * ( * hw_control_get_device ) ( s#led_classdev * ) ; s#mutex led_access ; }
s#led_hw_trigger_type struct led_hw_trigger_type { int dummy ; }
s#led_pattern struct led_pattern { t#u32 delta_t ; int brightness ; }
s#led_trigger@34ee3f81 struct led_trigger { const char * name ; int ( * activate ) ( s#led_classdev * ) ; void ( * deactivate ) ( s#led_classdev * ) ; e#led_brightness brightness ; s#led_hw_trigger_type * trigger_type ; t#spinlock_t leddev_list_lock ; s#list_head led_cdevs ; s#list_head next_trig ; const s#attribute_group * * groups ; }
s#led_trigger@44943f2b struct led_trigger { UNKNOWN }
s#lib80211_crypt_data struct lib80211_crypt_data { s#list_head list ; const s#lib80211_crypto_ops * ops ; void * priv ; t#atomic_t refcnt ; }
s#lib80211_crypt_info struct lib80211_crypt_info { char * name ; t#spinlock_t * lock ; s#lib80211_crypt_data * crypt [ 4 ] ; int tx_keyidx ; s#list_head crypt_deinit_list ; s#timer_list crypt_deinit_timer ; int crypt_quiesced ; }
s#lib80211_crypto_ops struct lib80211_crypto_ops { const char * name ; s#list_head list ; void * ( * init ) ( int ) ; void ( * deinit ) ( void * ) ; int ( * encrypt_mpdu ) ( s#sk_buff * , int , void * ) ; int ( * decrypt_mpdu ) ( s#sk_buff * , int , void * ) ; int ( * encrypt_msdu ) ( s#sk_buff * , int , void * ) ; int ( * decrypt_msdu ) ( s#sk_buff * , int , int , void * ) ; int ( * set_key ) ( void * , int , t#u8 * , void * ) ; int ( * get_key ) ( void * , int , t#u8 * , void * ) ; void ( * print_stats ) ( s#seq_file * , void * ) ; unsigned long ( * get_flags ) ( void * ) ; unsigned long ( * set_flags ) ( unsigned long , void * ) ; int extra_mpdu_prefix_len , extra_mpdu_postfix_len ; int extra_msdu_prefix_len , extra_msdu_postfix_len ; s#module * owner ; }
s#libipw_action struct libipw_action { s#libipw_hdr_3addr_hdr header ; t#u8 category ; t#u8 action ; union { s#libipw_action_exchange exchange ; s#libipw_channel_switch channel_switch ; } format ; }
s#libipw_action_exchange struct libipw_action_exchange { t#u8 token ; }
s#libipw_assoc_response struct libipw_assoc_response { s#libipw_hdr_3addr_hdr header ; t#__le16 capability ; t#__le16 status ; t#__le16 aid ; t#u8 variable [ ] ; }
s#libipw_auth struct libipw_auth { s#libipw_hdr_3addr_hdr header ; t#__le16 algorithm ; t#__le16 transaction ; t#__le16 status ; t#u8 variable [ ] ; }
s#libipw_channel struct libipw_channel { t#u32 freq ; t#u8 channel ; t#u8 flags ; t#u8 max_power ; }
s#libipw_channel_switch struct libipw_channel_switch { t#u8 id ; t#u8 len ; t#u8 mode ; t#u8 channel ; t#u8 count ; }
s#libipw_csa struct libipw_csa { t#u8 mode ; t#u8 channel ; t#u8 count ; }
s#libipw_device@6a1ddd3d struct libipw_device { s#net_device * dev ; s#wireless_dev wdev ; s#libipw_security sec ; s#libipw_stats ieee_stats ; s#libipw_geo geo ; s#ieee80211_supported_band bg_band ; s#ieee80211_supported_band a_band ; s#list_head network_free_list ; s#list_head network_list ; s#libipw_network * networks [ 128 ] ; int scans ; int scan_age ; int iw_mode ; s#iw_spy_data spy_data ; t#spinlock_t lock ; int tx_headroom ; t#u32 config ; int open_wep ; int host_encrypt ; int host_encrypt_msdu ; int host_decrypt ; int host_mc_decrypt ; int host_strip_iv_icv ; int host_open_frag ; int ieee802_1x ; int wpa_enabled ; int drop_unencrypted ; int privacy_invoked ; t#size_t wpa_ie_len ; t#u8 * wpa_ie ; s#lib80211_crypt_info crypt_info ; int bcrx_sta_key ; s#libipw_frag_entry frag_cache [ 4 ] ; unsigned int frag_next_idx ; t#u16 fts ; t#u16 rts ; t#u8 bssid [ 6 ] ; e#libipw_state state ; int mode ; int modulation ; int freq_band ; int abg_true ; int perfect_rssi ; int worst_rssi ; t#u16 prev_seq_ctl ; void ( * set_security ) ( s#net_device * , s#libipw_security * ) ; t#netdev_tx_t ( * hard_start_xmit ) ( s#libipw_txb * , s#net_device * , int ) ; int ( * is_queue_full ) ( s#net_device * , int ) ; int ( * handle_management ) ( s#net_device * , s#libipw_network * , t#u16 ) ; int ( * is_qos_active ) ( s#net_device * , s#sk_buff * ) ; int ( * handle_auth ) ( s#net_device * , s#libipw_auth * ) ; int ( * handle_deauth ) ( s#net_device * , s#libipw_disassoc * ) ; int ( * handle_action ) ( s#net_device * , s#libipw_action * , s#libipw_rx_stats * ) ; int ( * handle_disassoc ) ( s#net_device * , s#libipw_disassoc * ) ; int ( * handle_beacon ) ( s#net_device * , s#libipw_probe_response * , s#libipw_network * ) ; int ( * handle_probe_response ) ( s#net_device * , s#libipw_probe_response * , s#libipw_network * ) ; int ( * handle_probe_request ) ( s#net_device * , s#libipw_probe_request * , s#libipw_rx_stats * ) ; int ( * handle_assoc_response ) ( s#net_device * , s#libipw_assoc_response * , s#libipw_network * ) ; int ( * handle_assoc_request ) ( s#net_device * ) ; int ( * handle_reassoc_request ) ( s#net_device * , s#libipw_reassoc_request * ) ; t#u8 priv [ ] ; }
s#libipw_device@70ed142f struct libipw_device { UNKNOWN }
s#libipw_disassoc struct libipw_disassoc { s#libipw_hdr_3addr_hdr header ; t#__le16 reason ; }
s#libipw_frag_entry struct libipw_frag_entry { unsigned long first_frag_time ; unsigned int seq ; unsigned int last_frag ; s#sk_buff * skb ; t#u8 src_addr [ 6 ] ; t#u8 dst_addr [ 6 ] ; }
s#libipw_geo struct libipw_geo { t#u8 name [ 4 ] ; t#u8 bg_channels ; t#u8 a_channels ; s#libipw_channel bg [ ( 14 - 1 + 1 ) ] ; s#libipw_channel a [ ( 165 - 34 + 1 ) ] ; }
s#libipw_hdr_3addr_hdr struct libipw_hdr_3addr_hdr { t#__le16 frame_ctl ; t#__le16 duration_id ; t#u8 addr1 [ 6 ] ; t#u8 addr2 [ 6 ] ; t#u8 addr3 [ 6 ] ; t#__le16 seq_ctl ; }
s#libipw_network struct libipw_network { t#u8 bssid [ 6 ] ; t#u8 channel ; t#u8 ssid [ 32 + 1 ] ; t#u8 ssid_len ; s#libipw_qos_data qos_data ; s#libipw_rx_stats stats ; t#u16 capability ; t#u8 rates [ ( ( u8 ) 12 ) ] ; t#u8 rates_len ; t#u8 rates_ex [ ( ( u8 ) 16 ) ] ; t#u8 rates_ex_len ; unsigned long last_scanned ; t#u8 mode ; t#u32 flags ; t#u32 last_associate ; t#u32 time_stamp [ 2 ] ; t#u16 beacon_interval ; t#u16 listen_interval ; t#u16 atim_window ; t#u8 erp_value ; t#u8 wpa_ie [ 64 ] ; t#size_t wpa_ie_len ; t#u8 rsn_ie [ 64 ] ; t#size_t rsn_ie_len ; s#libipw_tim_parameters tim ; t#u8 power_constraint ; s#libipw_tpc_report tpc_report ; s#libipw_csa csa ; s#libipw_quiet quiet ; s#list_head list ; }
s#libipw_probe_request struct libipw_probe_request { s#libipw_hdr_3addr_hdr header ; t#u8 variable [ ] ; }
s#libipw_probe_response struct libipw_probe_response { s#libipw_hdr_3addr_hdr header ; t#__le32 time_stamp [ 2 ] ; t#__le16 beacon_interval ; t#__le16 capability ; t#u8 variable [ ] ; }
s#libipw_qos_data struct libipw_qos_data { s#libipw_qos_parameters parameters ; int active ; int supported ; t#u8 param_count ; t#u8 old_param_count ; }
s#libipw_qos_parameters struct libipw_qos_parameters { t#__le16 cw_min [ 4 ] ; t#__le16 cw_max [ 4 ] ; t#u8 aifs [ 4 ] ; t#u8 flag [ 4 ] ; t#__le16 tx_op_limit [ 4 ] ; }
s#libipw_quiet struct libipw_quiet { t#u8 count ; t#u8 period ; t#u8 duration ; t#u8 offset ; }
s#libipw_reassoc_request struct libipw_reassoc_request { s#libipw_hdr_3addr_hdr header ; t#__le16 capability ; t#__le16 listen_interval ; t#u8 current_ap [ 6 ] ; t#u8 variable [ ] ; }
s#libipw_rx_stats struct libipw_rx_stats { t#u32 mac_time ; t#s8 rssi ; t#u8 signal ; t#u8 noise ; t#u16 rate ; t#u8 received_channel ; t#u8 control ; t#u8 mask ; t#u8 freq ; t#u16 len ; t#u64 tsf ; t#u32 beacon_time ; }
s#libipw_security struct libipw_security { t#u16 active_key : 2 , enabled : 1 , unicast_uses_group : 1 , encrypt : 1 ; t#u8 auth_mode ; t#u8 encode_alg [ 4 ] ; t#u8 key_sizes [ 4 ] ; t#u8 keys [ 4 ] [ 32 ] ; t#u8 level ; t#u16 flags ; }
s#libipw_stats struct libipw_stats { unsigned int tx_unicast_frames ; unsigned int tx_multicast_frames ; unsigned int tx_fragments ; unsigned int tx_unicast_octets ; unsigned int tx_multicast_octets ; unsigned int tx_deferred_transmissions ; unsigned int tx_single_retry_frames ; unsigned int tx_multiple_retry_frames ; unsigned int tx_retry_limit_exceeded ; unsigned int tx_discards ; unsigned int rx_unicast_frames ; unsigned int rx_multicast_frames ; unsigned int rx_fragments ; unsigned int rx_unicast_octets ; unsigned int rx_multicast_octets ; unsigned int rx_fcs_errors ; unsigned int rx_discards_no_buffer ; unsigned int tx_discards_wrong_sa ; unsigned int rx_discards_undecryptable ; unsigned int rx_message_in_msg_fragments ; unsigned int rx_message_in_bad_msg_fragments ; }
s#libipw_tim_parameters struct libipw_tim_parameters { t#u8 tim_count ; t#u8 tim_period ; }
s#libipw_tpc_report struct libipw_tpc_report { t#u8 transmit_power ; t#u8 link_margin ; }
s#libipw_txb struct libipw_txb { t#u8 nr_frags ; t#u8 encrypted ; t#u8 rts_included ; t#u8 reserved ; t#u16 frag_size ; t#u16 payload_size ; s#sk_buff * fragments [ ] ; }
s#linux_binfmt@aef01ecd struct linux_binfmt { UNKNOWN }
s#linux_binfmt@c068fab7 struct linux_binfmt { s#list_head lh ; s#module * module ; int ( * load_binary ) ( s#linux_binprm * ) ; int ( * load_shlib ) ( s#file * ) ; int ( * core_dump ) ( s#coredump_params * ) ; unsigned long min_coredump ; }
s#linux_binprm struct linux_binprm { s#vm_area_struct * vma ; unsigned long vma_pages ; unsigned long argmin ; s#mm_struct * mm ; unsigned long p ; unsigned int have_execfd : 1 , execfd_creds : 1 , secureexec : 1 , point_of_no_return : 1 , comm_from_dentry : 1 , accepts_preserved_mem : 1 ; s#file * executable ; s#file * interpreter ; s#file * file ; s#cred * cred ; int unsafe ; unsigned int per_clear ; int argc , envc ; const char * filename ; const char * interp ; const char * fdpath ; unsigned interp_flags ; int execfd ; unsigned long loader , exec ; s#rlimit rlim_stack ; char buf [ 256 ] ; }
s#linux_mib struct linux_mib { unsigned long mibs [ E#__LINUX_MIB_MAX ] ; }
s#linux_tls_mib struct linux_tls_mib { unsigned long mibs [ E#__LINUX_MIB_TLSMAX ] ; }
s#linux_xfrm_mib struct linux_xfrm_mib { unsigned long mibs [ E#__LINUX_MIB_XFRMMAX ] ; }
s#list_head struct list_head { s#list_head * next , * prev ; }
s#list_lru@45bb0e2c struct list_lru { s#list_lru_node * node ; s#list_head list ; int shrinker_id ; t#bool memcg_aware ; s#xarray xa ; }
s#list_lru@a08e643b struct list_lru { UNKNOWN }
s#list_lru_node struct list_lru_node { t#spinlock_t lock ; s#list_lru_one lru ; long nr_items ; }
s#list_lru_one struct list_lru_one { s#list_head list ; long nr_items ; }
s#llist_head struct llist_head { s#llist_node * first ; }
s#llist_node struct llist_node { s#llist_node * next ; }
s#load_weight struct load_weight { unsigned long weight ; t#u32 inv_weight ; }
s#local_ports struct local_ports { t#u32 range ; t#bool warned ; }
s#lock_class_key struct lock_class_key { }
s#lock_manager_operations struct lock_manager_operations { void * lm_mod_owner ; t#fl_owner_t ( * lm_get_owner ) ( t#fl_owner_t ) ; void ( * lm_put_owner ) ( t#fl_owner_t ) ; void ( * lm_notify ) ( s#file_lock * ) ; int ( * lm_grant ) ( s#file_lock * , int ) ; t#bool ( * lm_lock_expirable ) ( s#file_lock * ) ; void ( * lm_expire_lock ) ( void ) ; unsigned long uek_reserved1 ; }
s#lockdep_map struct lockdep_map { }
s#lockref struct lockref { union { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) lock_count ; struct { t#spinlock_t lock ; int count ; } ; } ; }
s#lru_gen_folio struct lru_gen_folio { unsigned long max_seq ; unsigned long min_seq [ 2 ] ; unsigned long timestamps [ 4U ] ; s#list_head folios [ 4U ] [ 2 ] [ 5 ] ; long nr_pages [ 4U ] [ 2 ] [ 5 ] ; unsigned long avg_refaulted [ 2 ] [ 4U ] ; unsigned long avg_total [ 2 ] [ 4U ] ; unsigned long protected [ 1U ] [ 2 ] [ 4U - 1 ] ; t#atomic_long_t evicted [ 1U ] [ 2 ] [ 4U ] ; t#atomic_long_t refaulted [ 1U ] [ 2 ] [ 4U ] ; t#bool enabled ; t#u8 gen ; t#u8 seg ; s#hlist_nulls_node list ; }
s#lru_gen_memcg struct lru_gen_memcg { unsigned long seq ; unsigned long nr_memcgs [ 3 ] ; s#hlist_nulls_head fifo [ 3 ] [ 8 ] ; t#spinlock_t lock ; }
s#lru_gen_mm_list struct lru_gen_mm_list { s#list_head fifo ; t#spinlock_t lock ; }
s#lru_gen_mm_state struct lru_gen_mm_state { unsigned long seq ; s#list_head * head ; s#list_head * tail ; unsigned long * filters [ 2 ] ; unsigned long stats [ 1U ] [ E#NR_MM_STATS ] ; }
s#lru_gen_mm_walk struct lru_gen_mm_walk { s#lruvec * lruvec ; unsigned long seq ; unsigned long next_addr ; int nr_pages [ 4U ] [ 2 ] [ 5 ] ; int mm_stats [ E#NR_MM_STATS ] ; int batched ; t#bool can_swap ; t#bool force_scan ; }
s#lruvec struct lruvec { s#list_head lists [ E#NR_LRU_LISTS ] ; t#spinlock_t lru_lock ; unsigned long anon_cost ; unsigned long file_cost ; t#atomic_long_t nonresident_age ; unsigned long refaults [ 2 ] ; unsigned long flags ; s#lru_gen_folio lrugen ; s#lru_gen_mm_state mm_state ; s#pglist_data * pgdat ; s#zswap_lruvec_state zswap_lruvec_state ; }
s#lruvec_stats struct lruvec_stats { UNKNOWN }
s#lruvec_stats_percpu struct lruvec_stats_percpu { UNKNOWN }
s#lwq struct lwq { t#spinlock_t lock ; s#llist_node * ready ; s#llist_head new ; }
s#lwq_node struct lwq_node { s#llist_node node ; }
s#lwtunnel_state@c2751f5a struct lwtunnel_state { UNKNOWN }
s#lwtunnel_state@e718e16c struct lwtunnel_state { t#__u16 type ; t#__u16 flags ; t#__u16 headroom ; t#atomic_t refcnt ; int ( * orig_output ) ( s#net * , s#sock * , s#sk_buff * ) ; int ( * orig_input ) ( s#sk_buff * ) ; s#callback_head rcu ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; t#__u8 data [ ] ; }
s#mac_address struct mac_address { t#u8 addr [ 6 ] ; }
s#macsec_context struct macsec_context { union { s#net_device * netdev ; s#phy_device * phydev ; } ; e#macsec_offload offload ; s#macsec_secy * secy ; s#macsec_rx_sc * rx_sc ; struct { t#bool update_pn ; unsigned char assoc_num ; t#u8 key [ 128 ] ; union { s#macsec_rx_sa * rx_sa ; s#macsec_tx_sa * tx_sa ; } ; } sa ; union { s#macsec_tx_sc_stats * tx_sc_stats ; s#macsec_tx_sa_stats * tx_sa_stats ; s#macsec_rx_sc_stats * rx_sc_stats ; s#macsec_rx_sa_stats * rx_sa_stats ; s#macsec_dev_stats * dev_stats ; } stats ; }
s#macsec_dev_stats struct macsec_dev_stats { t#__u64 OutPktsUntagged ; t#__u64 InPktsUntagged ; t#__u64 OutPktsTooLong ; t#__u64 InPktsNoTag ; t#__u64 InPktsBadTag ; t#__u64 InPktsUnknownSCI ; t#__u64 InPktsNoSCI ; t#__u64 InPktsOverrun ; }
s#macsec_info struct macsec_info { t#sci_t sci ; }
s#macsec_key struct macsec_key { t#u8 id [ 16 ] ; s#crypto_aead * tfm ; t#salt_t salt ; }
s#macsec_ops@4adf4f40 struct macsec_ops { int ( * mdo_dev_open ) ( s#macsec_context * ) ; int ( * mdo_dev_stop ) ( s#macsec_context * ) ; int ( * mdo_add_secy ) ( s#macsec_context * ) ; int ( * mdo_upd_secy ) ( s#macsec_context * ) ; int ( * mdo_del_secy ) ( s#macsec_context * ) ; int ( * mdo_add_rxsc ) ( s#macsec_context * ) ; int ( * mdo_upd_rxsc ) ( s#macsec_context * ) ; int ( * mdo_del_rxsc ) ( s#macsec_context * ) ; int ( * mdo_add_rxsa ) ( s#macsec_context * ) ; int ( * mdo_upd_rxsa ) ( s#macsec_context * ) ; int ( * mdo_del_rxsa ) ( s#macsec_context * ) ; int ( * mdo_add_txsa ) ( s#macsec_context * ) ; int ( * mdo_upd_txsa ) ( s#macsec_context * ) ; int ( * mdo_del_txsa ) ( s#macsec_context * ) ; int ( * mdo_get_dev_stats ) ( s#macsec_context * ) ; int ( * mdo_get_tx_sc_stats ) ( s#macsec_context * ) ; int ( * mdo_get_tx_sa_stats ) ( s#macsec_context * ) ; int ( * mdo_get_rx_sc_stats ) ( s#macsec_context * ) ; int ( * mdo_get_rx_sa_stats ) ( s#macsec_context * ) ; int ( * mdo_insert_tx_tag ) ( s#phy_device * , s#sk_buff * ) ; unsigned int needed_headroom ; unsigned int needed_tailroom ; t#bool rx_uses_md_dst ; }
s#macsec_ops@c7967aeb struct macsec_ops { UNKNOWN }
s#macsec_rx_sa struct macsec_rx_sa { s#macsec_key key ; t#ssci_t ssci ; t#spinlock_t lock ; union { t#pn_t next_pn_halves ; t#u64 next_pn ; } ; t#refcount_t refcnt ; t#bool active ; s#macsec_rx_sa_stats * stats ; s#macsec_rx_sc * sc ; s#callback_head rcu ; }
s#macsec_rx_sa_stats struct macsec_rx_sa_stats { t#__u32 InPktsOK ; t#__u32 InPktsInvalid ; t#__u32 InPktsNotValid ; t#__u32 InPktsNotUsingSA ; t#__u32 InPktsUnusedSA ; }
s#macsec_rx_sc struct macsec_rx_sc { s#macsec_rx_sc * next ; t#sci_t sci ; t#bool active ; s#macsec_rx_sa * sa [ 4 ] ; s#pcpu_rx_sc_stats * stats ; t#refcount_t refcnt ; s#callback_head callback_head ; }
s#macsec_rx_sc_stats struct macsec_rx_sc_stats { t#__u64 InOctetsValidated ; t#__u64 InOctetsDecrypted ; t#__u64 InPktsUnchecked ; t#__u64 InPktsDelayed ; t#__u64 InPktsOK ; t#__u64 InPktsInvalid ; t#__u64 InPktsLate ; t#__u64 InPktsNotValid ; t#__u64 InPktsNotUsingSA ; t#__u64 InPktsUnusedSA ; }
s#macsec_secy struct macsec_secy { s#net_device * netdev ; unsigned int n_rx_sc ; t#sci_t sci ; t#u16 key_len ; t#u16 icv_len ; e#macsec_validation_type validate_frames ; t#bool xpn ; t#bool operational ; t#bool protect_frames ; t#bool replay_protect ; t#u32 replay_window ; s#macsec_tx_sc tx_sc ; s#macsec_rx_sc * rx_sc ; }
s#macsec_tx_sa struct macsec_tx_sa { s#macsec_key key ; t#ssci_t ssci ; t#spinlock_t lock ; union { t#pn_t next_pn_halves ; t#u64 next_pn ; } ; t#refcount_t refcnt ; t#bool active ; s#macsec_tx_sa_stats * stats ; s#callback_head rcu ; }
s#macsec_tx_sa_stats struct macsec_tx_sa_stats { t#__u32 OutPktsProtected ; t#__u32 OutPktsEncrypted ; }
s#macsec_tx_sc struct macsec_tx_sc { t#bool active ; t#u8 encoding_sa ; t#bool encrypt ; t#bool send_sci ; t#bool end_station ; t#bool scb ; s#macsec_tx_sa * sa [ 4 ] ; s#pcpu_tx_sc_stats * stats ; s#metadata_dst * md_dst ; }
s#macsec_tx_sc_stats struct macsec_tx_sc_stats { t#__u64 OutPktsProtected ; t#__u64 OutPktsEncrypted ; t#__u64 OutOctetsProtected ; t#__u64 OutOctetsEncrypted ; }
s#maple_tree struct maple_tree { union { t#spinlock_t ma_lock ; t#lockdep_map_p ma_external_lock ; } ; unsigned int ma_flags ; void * ma_root ; }
s#match_token struct match_token { int token ; const char * pattern ; }
s#math_emu_info struct math_emu_info { long ___orig_eip ; s#pt_regs * regs ; }
s#mdio_bus_stats struct mdio_bus_stats { t#u64_stats_t transfers ; t#u64_stats_t errors ; t#u64_stats_t writes ; t#u64_stats_t reads ; s#u64_stats_sync syncp ; }
s#mdio_device struct mdio_device { s#device dev ; s#mii_bus * bus ; char modalias [ 32 ] ; int ( * bus_match ) ( s#device * , const s#device_driver * ) ; void ( * device_free ) ( s#mdio_device * ) ; void ( * device_remove ) ( s#mdio_device * ) ; int addr ; int flags ; int reset_state ; s#gpio_desc * reset_gpio ; s#reset_control * reset_ctrl ; unsigned int reset_assert_delay ; unsigned int reset_deassert_delay ; }
s#mdio_driver_common struct mdio_driver_common { s#device_driver driver ; int flags ; }
s#mem_cgroup@3b7d487b struct mem_cgroup { UNKNOWN }
s#mem_cgroup@bdd3f063 struct mem_cgroup { s#cgroup_subsys_state css ; s#mem_cgroup_id id ; s#page_counter memory ; union { s#page_counter swap ; s#page_counter memsw ; } ; s#list_head memory_peaks ; s#list_head swap_peaks ; t#spinlock_t peaks_lock ; s#work_struct high_work ; unsigned long zswap_max ; t#bool zswap_writeback ; s#vmpressure vmpressure ; t#bool oom_group ; int swappiness ; s#cgroup_file events_file ; s#cgroup_file events_local_file ; s#cgroup_file swap_events_file ; s#memcg_vmstats * vmstats ; t#atomic_long_t memory_events [ E#MEMCG_NR_MEMORY_EVENTS ] ; t#atomic_long_t memory_events_local [ E#MEMCG_NR_MEMORY_EVENTS ] ; unsigned long socket_pressure ; int kmemcg_id ; s#obj_cgroup * objcg ; s#obj_cgroup * orig_objcg ; s#list_head objcg_list ; s#memcg_vmstats_percpu * vmstats_percpu ; s#list_head cgwb_list ; s#wb_domain cgwb_domain ; s#memcg_cgwb_frn cgwb_frn [ 4 ] ; s#deferred_split deferred_split_queue ; s#lru_gen_mm_list mm_list ; s#page_counter kmem ; s#page_counter tcpmem ; s#memcg1_events_percpu * events_percpu ; unsigned long soft_limit ; t#bool oom_lock ; int under_oom ; int oom_kill_disable ; s#mutex thresholds_lock ; s#mem_cgroup_thresholds thresholds ; s#mem_cgroup_thresholds memsw_thresholds ; s#list_head oom_notify ; unsigned long move_charge_at_immigrate ; t#spinlock_t move_lock ; unsigned long move_lock_flags ; t#bool tcpmem_active ; int tcpmem_pressure ; t#atomic_t moving_account ; s#task_struct * move_lock_task ; s#list_head event_list ; t#spinlock_t event_list_lock ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; s#mem_cgroup_per_node * nodeinfo [ ] ; }
s#mem_cgroup_id struct mem_cgroup_id { int id ; t#refcount_t ref ; }
s#mem_cgroup_per_node struct mem_cgroup_per_node { s#mem_cgroup * memcg ; s#lruvec_stats_percpu * lruvec_stats_percpu ; s#lruvec_stats * lruvec_stats ; s#shrinker_info * shrinker_info ; s#rb_node tree_node ; unsigned long usage_in_excess ; t#bool on_tree ; s#lruvec lruvec ; s#cacheline_padding _pad2_ ; unsigned long lru_zone_size [ 5 ] [ E#NR_LRU_LISTS ] ; s#mem_cgroup_reclaim_iter iter ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#mem_cgroup_reclaim_iter struct mem_cgroup_reclaim_iter { s#mem_cgroup * position ; t#atomic_t generation ; }
s#mem_cgroup_threshold struct mem_cgroup_threshold { s#eventfd_ctx * eventfd ; unsigned long threshold ; }
s#mem_cgroup_threshold_ary struct mem_cgroup_threshold_ary { int current_threshold ; unsigned int size ; s#mem_cgroup_threshold entries [ ] ; }
s#mem_cgroup_thresholds struct mem_cgroup_thresholds { s#mem_cgroup_threshold_ary * primary ; s#mem_cgroup_threshold_ary * spare ; }
s#mem_dqblk struct mem_dqblk { t#qsize_t dqb_bhardlimit ; t#qsize_t dqb_bsoftlimit ; t#qsize_t dqb_curspace ; t#qsize_t dqb_rsvspace ; t#qsize_t dqb_ihardlimit ; t#qsize_t dqb_isoftlimit ; t#qsize_t dqb_curinodes ; t#time64_t dqb_btime ; t#time64_t dqb_itime ; }
s#mem_dqinfo struct mem_dqinfo { s#quota_format_type * dqi_format ; int dqi_fmt_id ; s#list_head dqi_dirty_list ; unsigned long dqi_flags ; unsigned int dqi_bgrace ; unsigned int dqi_igrace ; t#qsize_t dqi_max_spc_limit ; t#qsize_t dqi_max_ino_limit ; void * dqi_priv ; }
s#memcg1_events_percpu struct memcg1_events_percpu { UNKNOWN }
s#memcg_cgwb_frn struct memcg_cgwb_frn { t#u64 bdi_id ; int memcg_id ; t#u64 at ; s#wb_completion done ; }
s#memcg_vmstats struct memcg_vmstats { UNKNOWN }
s#memcg_vmstats_percpu struct memcg_vmstats_percpu { UNKNOWN }
s#memory_failure_stats struct memory_failure_stats { unsigned long total ; unsigned long ignored ; unsigned long failed ; unsigned long delayed ; unsigned long recovered ; }
s#memory_tier struct memory_tier { UNKNOWN }
s#mempolicy@66376883 struct mempolicy { UNKNOWN }
s#mempolicy@b3ae8fa5 struct mempolicy { t#atomic_t refcnt ; unsigned short mode ; unsigned short flags ; t#nodemask_t nodes ; int home_node ; union { t#nodemask_t cpuset_mems_allowed ; t#nodemask_t user_nodemask ; } w ; }
s#mempool_s struct mempool_s { t#spinlock_t lock ; int min_nr ; int curr_nr ; void * * elements ; void * pool_data ; t#mempool_alloc_t * alloc ; t#mempool_free_t * free ; t#wait_queue_head_t wait ; }
s#merkle_tree_params struct merkle_tree_params { const s#fsverity_hash_alg * hash_alg ; const t#u8 * hashstate ; unsigned int digest_size ; unsigned int block_size ; unsigned int hashes_per_block ; unsigned int blocks_per_page ; t#u8 log_digestsize ; t#u8 log_blocksize ; t#u8 log_arity ; t#u8 log_blocks_per_page ; unsigned int num_levels ; t#u64 tree_size ; unsigned long tree_pages ; unsigned long level_start [ 8 ] ; }
s#metadata_dst@84ab130f struct metadata_dst { UNKNOWN }
s#metadata_dst@8b17fc32 struct metadata_dst { s#dst_entry dst ; e#metadata_type type ; union { s#ip_tunnel_info tun_info ; s#hw_port_info port_info ; s#macsec_info macsec_info ; s#xfrm_md_info xfrm_info ; } u ; }
s#mii_bus struct mii_bus { s#module * owner ; const char * name ; char id [ 61 ] ; void * priv ; int ( * read ) ( s#mii_bus * , int , int ) ; int ( * write ) ( s#mii_bus * , int , int , t#u16 ) ; int ( * read_c45 ) ( s#mii_bus * , int , int , int ) ; int ( * write_c45 ) ( s#mii_bus * , int , int , int , t#u16 ) ; int ( * reset ) ( s#mii_bus * ) ; s#mdio_bus_stats stats [ 32 ] ; s#mutex mdio_lock ; s#device * parent ; enum { MDIOBUS_ALLOCATED = 1 , MDIOBUS_REGISTERED , MDIOBUS_UNREGISTERED , MDIOBUS_RELEASED , } state ; s#device dev ; s#mdio_device * mdio_map [ 32 ] ; t#u32 phy_mask ; t#u32 phy_ignore_ta_mask ; int irq [ 32 ] ; int reset_delay_us ; int reset_post_delay_us ; s#gpio_desc * reset_gpiod ; s#mutex shared_lock ; s#phy_package_shared * shared [ 32 ] ; }
s#mii_timestamper struct mii_timestamper { t#bool ( * rxtstamp ) ( s#mii_timestamper * , s#sk_buff * , int ) ; void ( * txtstamp ) ( s#mii_timestamper * , s#sk_buff * , int ) ; int ( * hwtstamp ) ( s#mii_timestamper * , s#kernel_hwtstamp_config * , s#netlink_ext_ack * ) ; void ( * link_state ) ( s#mii_timestamper * , s#phy_device * ) ; int ( * ts_info ) ( s#mii_timestamper * , s#kernel_ethtool_ts_info * ) ; s#device * device ; }
s#mm_cid struct mm_cid { t#u64 time ; int cid ; }
s#mm_struct@92a23cf0 struct mm_struct { struct { struct { t#atomic_t mm_count ; } __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; s#maple_tree mm_mt ; unsigned long mmap_base ; unsigned long mmap_legacy_base ; unsigned long mmap_compat_base ; unsigned long mmap_compat_legacy_base ; unsigned long task_size ; t#pgd_t * pgd ; t#atomic_t membarrier_state ; t#atomic_t mm_users ; s#mm_cid * pcpu_cid ; unsigned long mm_cid_next_scan ; t#atomic_long_t pgtables_bytes ; int map_count ; t#spinlock_t page_table_lock ; s#rw_semaphore mmap_lock ; s#list_head mmlist ; int mm_lock_seq ; unsigned long hiwater_rss ; unsigned long hiwater_vm ; unsigned long total_vm ; unsigned long locked_vm ; t#atomic64_t pinned_vm ; unsigned long data_vm ; unsigned long exec_vm ; unsigned long stack_vm ; unsigned long def_flags ; t#seqcount_t write_protect_seq ; t#spinlock_t arg_lock ; unsigned long start_code , end_code , start_data , end_data ; unsigned long start_brk , brk , start_stack ; unsigned long arg_start , arg_end , env_start , env_end ; unsigned long saved_auxv [ ( 2 * ( 3 + 22 + 1 ) ) ] ; s#percpu_counter rss_stat [ E#NR_MM_COUNTERS ] ; s#linux_binfmt * binfmt ; t#mm_context_t context ; unsigned long flags ; t#spinlock_t ioctx_lock ; s#kioctx_table * ioctx_table ; s#task_struct * owner ; s#user_namespace * user_ns ; s#file * exe_file ; s#mmu_notifier_subscriptions * notifier_subscriptions ; unsigned long numa_next_scan ; unsigned long numa_scan_offset ; int numa_scan_seq ; t#atomic_t tlb_flush_pending ; t#atomic_t tlb_flush_batched ; s#uprobes_state uprobes_state ; t#atomic_long_t hugetlb_usage ; s#work_struct async_put_work ; s#iommu_mm_data * iommu_mm ; unsigned long ksm_merging_pages ; unsigned long ksm_rmap_items ; t#atomic_long_t ksm_zero_pages ; struct { s#list_head list ; unsigned long bitmap ; s#mem_cgroup * memcg ; } lru_gen ; } __attribute__ ( ( __designated_init__ ) ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; unsigned long cpu_bitmap [ ] ; }
s#mm_struct@e28a1365 struct mm_struct { UNKNOWN }
s#mmu_gather struct mmu_gather { s#mm_struct * mm ; s#mmu_table_batch * batch ; unsigned long start ; unsigned long end ; unsigned int fullmm : 1 ; unsigned int need_flush_all : 1 ; unsigned int freed_tables : 1 ; unsigned int delayed_rmap : 1 ; unsigned int cleared_ptes : 1 ; unsigned int cleared_pmds : 1 ; unsigned int cleared_puds : 1 ; unsigned int cleared_p4ds : 1 ; unsigned int vma_exec : 1 ; unsigned int vma_huge : 1 ; unsigned int vma_pfn : 1 ; unsigned int batch_count ; s#mmu_gather_batch * active ; s#mmu_gather_batch local ; s#page * __pages [ 8 ] ; }
s#mmu_gather_batch struct mmu_gather_batch { s#mmu_gather_batch * next ; unsigned int nr ; unsigned int max ; s#encoded_page * encoded_pages [ ] ; }
s#mmu_notifier_subscriptions struct mmu_notifier_subscriptions { UNKNOWN }
s#mmu_table_batch struct mmu_table_batch { s#callback_head rcu ; unsigned int nr ; void * tables [ ] ; }
s#mnt_idmap struct mnt_idmap { UNKNOWN }
s#mnt_namespace@13467d86 struct mnt_namespace { UNKNOWN }
s#mnt_namespace@ced81a6d struct mnt_namespace { s#ns_common ns ; s#mount * root ; s#rb_root mounts ; s#user_namespace * user_ns ; s#ucounts * ucounts ; t#u64 seq ; t#wait_queue_head_t poll ; t#u64 event ; unsigned int nr_mounts ; unsigned int pending_mounts ; s#rb_node mnt_ns_tree_node ; t#refcount_t passive ; }
s#mnt_pcp struct mnt_pcp { int mnt_count ; int mnt_writers ; }
s#mod_arch_specific struct mod_arch_specific { unsigned int num_orcs ; int * orc_unwind_ip ; s#orc_entry * orc_unwind ; }
s#mod_kallsyms struct mod_kallsyms { t#Elf64_Sym * symtab ; unsigned int num_symtab ; char * strtab ; char * typetab ; }
s#mod_tree_node struct mod_tree_node { s#module * mod ; s#latch_tree_node node ; }
s#module@689a97e0 struct module { UNKNOWN }
s#module@7b5e330f struct module { e#module_state state ; s#list_head list ; char name [ ( 64 - sizeof ( unsigned long ) ) ] ; s#module_kobject mkobj ; s#module_attribute * modinfo_attrs ; const char * version ; const char * srcversion ; s#kobject * holders_dir ; const s#kernel_symbol * syms ; const t#s32 * crcs ; unsigned int num_syms ; s#mutex param_lock ; s#kernel_param * kp ; unsigned int num_kp ; unsigned int num_gpl_syms ; const s#kernel_symbol * gpl_syms ; const t#s32 * gpl_crcs ; t#bool using_gplonly_symbols ; t#bool sig_ok ; t#bool async_probe_requested ; unsigned int num_exentries ; s#exception_table_entry * extable ; int ( * init ) ( void ) ; s#module_memory mem [ E#MOD_MEM_NUM_TYPES ] __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; s#mod_arch_specific arch ; unsigned long taints ; unsigned num_bugs ; s#list_head bug_list ; s#bug_entry * bug_table ; s#mod_kallsyms * kallsyms ; s#mod_kallsyms core_kallsyms ; s#module_sect_attrs * sect_attrs ; s#module_notes_attrs * notes_attrs ; char * args ; void * percpu ; unsigned int percpu_size ; void * noinstr_text_start ; unsigned int noinstr_text_size ; unsigned int num_tracepoints ; t#tracepoint_ptr_t * tracepoints_ptrs ; unsigned int num_srcu_structs ; s#srcu_struct * * srcu_struct_ptrs ; unsigned int num_bpf_raw_events ; s#bpf_raw_event_map * bpf_raw_events ; unsigned int btf_data_size ; unsigned int btf_base_data_size ; void * btf_data ; void * btf_base_data ; s#jump_entry * jump_entries ; unsigned int num_jump_entries ; unsigned int num_trace_bprintk_fmt ; const char * * trace_bprintk_fmt_start ; s#trace_event_call * * trace_events ; unsigned int num_trace_events ; s#trace_eval_map * * trace_evals ; unsigned int num_trace_evals ; unsigned int num_ftrace_callsites ; unsigned long * ftrace_callsites ; void * kprobes_text_start ; unsigned int kprobes_text_size ; unsigned long * kprobe_blacklist ; unsigned int num_kprobe_blacklist ; int num_static_call_sites ; s#static_call_site * static_call_sites ; unsigned int printk_index_size ; s#pi_entry * * printk_index_start ; s#list_head source_list ; s#list_head target_list ; void ( * exit ) ( void ) ; t#atomic_t refcnt ; s#error_injection_entry * ei_funcs ; unsigned int num_ei_funcs ; s#_ddebug_info dyndbg_info ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; }
s#module_attribute struct module_attribute { s#attribute attr ; t#ssize_t ( * show ) ( s#module_attribute * , s#module_kobject * , char * ) ; t#ssize_t ( * store ) ( s#module_attribute * , s#module_kobject * , const char * , t#size_t ) ; void ( * setup ) ( s#module * , const char * ) ; int ( * test ) ( s#module * ) ; void ( * free ) ( s#module * ) ; }
s#module_kobject struct module_kobject { s#kobject kobj ; s#module * mod ; s#kobject * drivers_dir ; s#module_param_attrs * mp ; s#completion * kobj_completion ; }
s#module_memory struct module_memory { void * base ; unsigned int size ; s#mod_tree_node mtn ; }
s#module_notes_attrs struct module_notes_attrs { UNKNOWN }
s#module_param_attrs struct module_param_attrs { UNKNOWN }
s#module_sect_attrs struct module_sect_attrs { UNKNOWN }
s#mount struct mount { s#hlist_node mnt_hash ; s#mount * mnt_parent ; s#dentry * mnt_mountpoint ; s#vfsmount mnt ; union { s#rb_node mnt_node ; s#callback_head mnt_rcu ; s#llist_node mnt_llist ; } ; s#mnt_pcp * mnt_pcp ; s#list_head mnt_mounts ; s#list_head mnt_child ; s#list_head mnt_instance ; const char * mnt_devname ; s#list_head mnt_list ; s#list_head mnt_expire ; s#list_head mnt_share ; s#list_head mnt_slave_list ; s#list_head mnt_slave ; s#mount * mnt_master ; s#mnt_namespace * mnt_ns ; s#mountpoint * mnt_mp ; union { s#hlist_node mnt_mp_list ; s#hlist_node mnt_umount ; } ; s#list_head mnt_umounting ; s#fsnotify_mark_connector * mnt_fsnotify_marks ; t#__u32 mnt_fsnotify_mask ; int mnt_id ; t#u64 mnt_id_unique ; int mnt_group_id ; int mnt_expiry_mark ; s#hlist_head mnt_pins ; s#hlist_head mnt_stuck_children ; }
s#mountpoint struct mountpoint { s#hlist_node m_hash ; s#dentry * m_dentry ; s#hlist_head m_list ; int m_count ; }
s#mpls_dev@2c594785 struct mpls_dev { int input_enabled ; s#net_device * dev ; s#mpls_pcpu_stats * stats ; s#ctl_table_header * sysctl ; s#callback_head rcu ; }
s#mpls_dev@ecb506b0 struct mpls_dev { UNKNOWN }
s#mpls_link_stats struct mpls_link_stats { t#__u64 rx_packets ; t#__u64 tx_packets ; t#__u64 rx_bytes ; t#__u64 tx_bytes ; t#__u64 rx_errors ; t#__u64 tx_errors ; t#__u64 rx_dropped ; t#__u64 tx_dropped ; t#__u64 rx_noroute ; }
s#mpls_nh struct mpls_nh { s#net_device * nh_dev ; unsigned int nh_flags ; t#u8 nh_labels ; t#u8 nh_via_alen ; t#u8 nh_via_table ; t#u8 nh_reserved1 ; t#u32 nh_label [ ] ; }
s#mpls_pcpu_stats struct mpls_pcpu_stats { s#mpls_link_stats stats ; s#u64_stats_sync syncp ; }
s#mpls_route@0a0560c6 struct mpls_route { s#callback_head rt_rcu ; t#u8 rt_protocol ; t#u8 rt_payload_type ; t#u8 rt_max_alen ; t#u8 rt_ttl_propagate ; t#u8 rt_nhn ; t#u8 rt_nhn_alive ; t#u8 rt_nh_size ; t#u8 rt_via_offset ; t#u8 rt_reserved1 ; s#mpls_nh rt_nh [ ] ; }
s#mpls_route@6bce9b55 struct mpls_route { UNKNOWN }
s#mptcp_mib@2d812ab8 struct mptcp_mib { unsigned long mibs [ E#__MPTCP_MIB_MAX ] ; }
s#mptcp_mib@32deb1cd struct mptcp_mib { UNKNOWN }
s#mq_attr struct mq_attr { t#__kernel_long_t mq_flags ; t#__kernel_long_t mq_maxmsg ; t#__kernel_long_t mq_msgsize ; t#__kernel_long_t mq_curmsgs ; t#__kernel_long_t __reserved [ 4 ] ; }
s#mrp_applicant struct mrp_applicant { s#mrp_application * app ; s#net_device * dev ; s#timer_list join_timer ; s#timer_list periodic_timer ; t#spinlock_t lock ; s#sk_buff_head queue ; s#sk_buff * pdu ; s#rb_root mad ; s#callback_head rcu ; t#bool active ; }
s#mrp_application struct mrp_application { e#mrp_applications type ; unsigned int maxattr ; s#packet_type pkttype ; unsigned char group_address [ 6 ] ; t#u8 version ; }
s#mrp_port@670475f3 struct mrp_port { s#mrp_applicant * applicants [ ( E#__MRP_APPLICATION_MAX - 1 ) + 1 ] ; s#callback_head rcu ; }
s#mrp_port@e05e7d57 struct mrp_port { UNKNOWN }
s#msghdr struct msghdr { void * msg_name ; int msg_namelen ; int msg_inq ; s#iov_iter msg_iter ; union { void * msg_control ; void * msg_control_user ; } ; t#bool msg_control_is_user : 1 ; t#bool msg_get_inq : 1 ; unsigned int msg_flags ; t#__kernel_size_t msg_controllen ; s#kiocb * msg_iocb ; s#ubuf_info * msg_ubuf ; int ( * sg_from_iter ) ( s#sk_buff * , s#iov_iter * , t#size_t ) ; }
s#msi_desc@44af7c7e struct msi_desc { unsigned int irq ; unsigned int nvec_used ; s#device * dev ; s#msi_msg msg ; s#irq_affinity_desc * affinity ; const void * iommu_cookie ; s#device_attribute * sysfs_attrs ; void ( * write_msi_msg ) ( s#msi_desc * , void * ) ; void * write_msi_msg_data ; t#u16 msi_index ; union { s#pci_msi_desc pci ; s#msi_desc_data data ; } ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#msi_desc@9f5aa3f4 struct msi_desc { UNKNOWN }
s#msi_desc_data struct msi_desc_data { u#msi_domain_cookie dcookie ; u#msi_instance_cookie icookie ; }
s#msi_device_data struct msi_device_data { UNKNOWN }
s#msi_domain_info struct msi_domain_info { t#u32 flags ; e#irq_domain_bus_token bus_token ; unsigned int hwsize ; s#msi_domain_ops * ops ; s#irq_chip * chip ; void * chip_data ; t#irq_flow_handler_t handler ; void * handler_data ; const char * handler_name ; void * data ; }
s#msi_domain_ops struct msi_domain_ops { t#irq_hw_number_t ( * get_hwirq ) ( s#msi_domain_info * , t#msi_alloc_info_t * ) ; int ( * msi_init ) ( s#irq_domain * , s#msi_domain_info * , unsigned int , t#irq_hw_number_t , t#msi_alloc_info_t * ) ; void ( * msi_free ) ( s#irq_domain * , s#msi_domain_info * , unsigned int ) ; int ( * msi_prepare ) ( s#irq_domain * , s#device * , int , t#msi_alloc_info_t * ) ; void ( * prepare_desc ) ( s#irq_domain * , t#msi_alloc_info_t * , s#msi_desc * ) ; void ( * set_desc ) ( t#msi_alloc_info_t * , s#msi_desc * ) ; int ( * domain_alloc_irqs ) ( s#irq_domain * , s#device * , int ) ; void ( * domain_free_irqs ) ( s#irq_domain * , s#device * ) ; void ( * msi_post_free ) ( s#irq_domain * , s#device * ) ; int ( * msi_translate ) ( s#irq_domain * , s#irq_fwspec * , t#irq_hw_number_t * , unsigned int * ) ; }
s#msi_msg@32144411 struct msi_msg { UNKNOWN }
s#msi_msg@6a0c952c struct msi_msg { union { t#u32 address_lo ; t#arch_msi_msg_addr_lo_t arch_addr_lo ; } ; union { t#u32 address_hi ; t#arch_msi_msg_addr_hi_t arch_addr_hi ; } ; union { t#u32 data ; t#arch_msi_msg_data_t arch_data ; } ; }
s#msi_parent_ops@145ca724 struct msi_parent_ops { t#u32 supported_flags ; t#u32 required_flags ; t#u32 bus_select_token ; t#u32 bus_select_mask ; const char * prefix ; t#bool ( * init_dev_msi_info ) ( s#device * , s#irq_domain * , s#irq_domain * , s#msi_domain_info * ) ; }
s#msi_parent_ops@81cb3481 struct msi_parent_ops { UNKNOWN }
s#mtd_debug_info struct mtd_debug_info { s#dentry * dfs_dir ; }
s#mtd_ecc_stats struct mtd_ecc_stats { t#__u32 corrected ; t#__u32 failed ; t#__u32 badblocks ; t#__u32 bbtblocks ; }
s#mtd_erase_region_info struct mtd_erase_region_info { t#uint64_t offset ; t#uint32_t erasesize ; t#uint32_t numblocks ; unsigned long * lockmap ; }
s#mtd_info@8095bfdb struct mtd_info { UNKNOWN }
s#mtd_info@cfc1666f struct mtd_info { t#u_char type ; t#uint32_t flags ; t#uint64_t size ; t#uint32_t erasesize ; t#uint32_t writesize ; t#uint32_t writebufsize ; t#uint32_t oobsize ; t#uint32_t oobavail ; unsigned int erasesize_shift ; unsigned int writesize_shift ; unsigned int erasesize_mask ; unsigned int writesize_mask ; unsigned int bitflip_threshold ; const char * name ; int index ; const s#mtd_ooblayout_ops * ooblayout ; const s#mtd_pairing_scheme * pairing ; unsigned int ecc_step_size ; unsigned int ecc_strength ; int numeraseregions ; s#mtd_erase_region_info * eraseregions ; int ( * _erase ) ( s#mtd_info * , s#erase_info * ) ; int ( * _point ) ( s#mtd_info * , t#loff_t , t#size_t , t#size_t * , void * * , t#resource_size_t * ) ; int ( * _unpoint ) ( s#mtd_info * , t#loff_t , t#size_t ) ; int ( * _read ) ( s#mtd_info * , t#loff_t , t#size_t , t#size_t * , t#u_char * ) ; int ( * _write ) ( s#mtd_info * , t#loff_t , t#size_t , t#size_t * , const t#u_char * ) ; int ( * _panic_write ) ( s#mtd_info * , t#loff_t , t#size_t , t#size_t * , const t#u_char * ) ; int ( * _read_oob ) ( s#mtd_info * , t#loff_t , s#mtd_oob_ops * ) ; int ( * _write_oob ) ( s#mtd_info * , t#loff_t , s#mtd_oob_ops * ) ; int ( * _get_fact_prot_info ) ( s#mtd_info * , t#size_t , t#size_t * , s#otp_info * ) ; int ( * _read_fact_prot_reg ) ( s#mtd_info * , t#loff_t , t#size_t , t#size_t * , t#u_char * ) ; int ( * _get_user_prot_info ) ( s#mtd_info * , t#size_t , t#size_t * , s#otp_info * ) ; int ( * _read_user_prot_reg ) ( s#mtd_info * , t#loff_t , t#size_t , t#size_t * , t#u_char * ) ; int ( * _write_user_prot_reg ) ( s#mtd_info * , t#loff_t , t#size_t , t#size_t * , const t#u_char * ) ; int ( * _lock_user_prot_reg ) ( s#mtd_info * , t#loff_t , t#size_t ) ; int ( * _erase_user_prot_reg ) ( s#mtd_info * , t#loff_t , t#size_t ) ; int ( * _writev ) ( s#mtd_info * , const s#kvec * , unsigned long , t#loff_t , t#size_t * ) ; void ( * _sync ) ( s#mtd_info * ) ; int ( * _lock ) ( s#mtd_info * , t#loff_t , t#uint64_t ) ; int ( * _unlock ) ( s#mtd_info * , t#loff_t , t#uint64_t ) ; int ( * _is_locked ) ( s#mtd_info * , t#loff_t , t#uint64_t ) ; int ( * _block_isreserved ) ( s#mtd_info * , t#loff_t ) ; int ( * _block_isbad ) ( s#mtd_info * , t#loff_t ) ; int ( * _block_markbad ) ( s#mtd_info * , t#loff_t ) ; int ( * _max_bad_blocks ) ( s#mtd_info * , t#loff_t , t#size_t ) ; int ( * _suspend ) ( s#mtd_info * ) ; void ( * _resume ) ( s#mtd_info * ) ; void ( * _reboot ) ( s#mtd_info * ) ; int ( * _get_device ) ( s#mtd_info * ) ; void ( * _put_device ) ( s#mtd_info * ) ; t#bool oops_panic_write ; s#notifier_block reboot_notifier ; s#mtd_ecc_stats ecc_stats ; int subpage_sft ; void * priv ; s#module * owner ; s#device dev ; s#kref refcnt ; s#mtd_debug_info dbg ; s#nvmem_device * nvmem ; s#nvmem_device * otp_user_nvmem ; s#nvmem_device * otp_factory_nvmem ; s#mtd_info * parent ; s#list_head partitions ; s#mtd_part part ; s#mtd_master master ; }
s#mtd_master struct mtd_master { s#mutex partitions_lock ; s#mutex chrdev_lock ; unsigned int suspended : 1 ; }
s#mtd_oob_ops struct mtd_oob_ops { unsigned int mode ; t#size_t len ; t#size_t retlen ; t#size_t ooblen ; t#size_t oobretlen ; t#uint32_t ooboffs ; t#uint8_t * datbuf ; t#uint8_t * oobbuf ; s#mtd_req_stats * stats ; }
s#mtd_oob_region struct mtd_oob_region { t#u32 offset ; t#u32 length ; }
s#mtd_ooblayout_ops struct mtd_ooblayout_ops { int ( * ecc ) ( s#mtd_info * , int , s#mtd_oob_region * ) ; int ( * free ) ( s#mtd_info * , int , s#mtd_oob_region * ) ; }
s#mtd_pairing_info struct mtd_pairing_info { int pair ; int group ; }
s#mtd_pairing_scheme struct mtd_pairing_scheme { int ngroups ; int ( * get_info ) ( s#mtd_info * , int , s#mtd_pairing_info * ) ; int ( * get_wunit ) ( s#mtd_info * , const s#mtd_pairing_info * ) ; }
s#mtd_part struct mtd_part { s#list_head node ; t#u64 offset ; t#u64 size ; t#u32 flags ; }
s#mtd_req_stats struct mtd_req_stats { unsigned int uncorrectable_errors ; unsigned int corrected_bitflips ; unsigned int max_bitflips ; }
s#mutex struct mutex { t#atomic_long_t owner ; t#raw_spinlock_t wait_lock ; s#optimistic_spin_queue osq ; s#list_head wait_list ; }
s#nameidata struct nameidata { UNKNOWN }
s#napi_struct struct napi_struct { s#list_head poll_list ; unsigned long state ; int weight ; t#u32 defer_hard_irqs_count ; unsigned long gro_bitmask ; int ( * poll ) ( s#napi_struct * , int ) ; int poll_owner ; int list_owner ; s#net_device * dev ; s#gro_list gro_hash [ 8 ] ; s#sk_buff * skb ; s#list_head rx_list ; int rx_count ; unsigned int napi_id ; s#hrtimer timer ; s#task_struct * thread ; s#list_head dev_list ; s#hlist_node napi_hash_node ; int irq ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#nd_opt_hdr struct nd_opt_hdr { t#__u8 nd_opt_type ; t#__u8 nd_opt_len ; }
s#ndisc_ops@397a4195 struct ndisc_ops { UNKNOWN }
s#ndisc_ops@5f578ea9 struct ndisc_ops { int ( * parse_options ) ( const s#net_device * , s#nd_opt_hdr * , s#ndisc_options * ) ; void ( * update ) ( const s#net_device * , s#neighbour * , t#u32 , t#u8 , const s#ndisc_options * ) ; int ( * opt_addr_space ) ( const s#net_device * , t#u8 , s#neighbour * , t#u8 * , t#u8 * * ) ; void ( * fill_addr_option ) ( const s#net_device * , s#sk_buff * , t#u8 , const t#u8 * ) ; void ( * prefix_rcv_add_addr ) ( s#net * , s#net_device * , const s#prefix_info * , s#inet6_dev * , s#in6_addr * , int , t#u32 , t#bool , t#bool , t#__u32 , t#u32 , t#bool ) ; }
s#ndisc_options struct ndisc_options { s#nd_opt_hdr * nd_opt_array [ E#__ND_OPT_ARRAY_MAX ] ; s#nd_opt_hdr * nd_opts_ri ; s#nd_opt_hdr * nd_opts_ri_end ; s#nd_opt_hdr * nd_useropts ; s#nd_opt_hdr * nd_useropts_end ; s#nd_opt_hdr * nd_802154_opt_array [ E#ND_OPT_TARGET_LL_ADDR + 1 ] ; }
s#ndmsg struct ndmsg { t#__u8 ndm_family ; t#__u8 ndm_pad1 ; t#__u16 ndm_pad2 ; t#__s32 ndm_ifindex ; t#__u16 ndm_state ; t#__u8 ndm_flags ; t#__u8 ndm_type ; }
s#neigh_hash_table struct neigh_hash_table { s#neighbour * * hash_buckets ; unsigned int hash_shift ; t#__u32 hash_rnd [ 4 ] ; s#callback_head rcu ; }
s#neigh_ops struct neigh_ops { int family ; void ( * solicit ) ( s#neighbour * , s#sk_buff * ) ; void ( * error_report ) ( s#neighbour * , s#sk_buff * ) ; int ( * output ) ( s#neighbour * , s#sk_buff * ) ; int ( * connected_output ) ( s#neighbour * , s#sk_buff * ) ; }
s#neigh_parms@19878e97 struct neigh_parms { t#possible_net_t net ; s#net_device * dev ; t#netdevice_tracker dev_tracker ; s#list_head list ; int ( * neigh_setup ) ( s#neighbour * ) ; s#neigh_table * tbl ; void * sysctl_table ; int dead ; t#refcount_t refcnt ; s#callback_head callback_head ; int reachable_time ; t#u32 qlen ; int data [ ( E#NEIGH_VAR_LOCKTIME + 1 ) ] ; unsigned long data_state [ ( ( ( ( E#NEIGH_VAR_LOCKTIME + 1 ) ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; }
s#neigh_parms@3fe62c7d struct neigh_parms { UNKNOWN }
s#neigh_statistics struct neigh_statistics { unsigned long allocs ; unsigned long destroys ; unsigned long hash_grows ; unsigned long res_failed ; unsigned long lookups ; unsigned long hits ; unsigned long rcv_probes_mcast ; unsigned long rcv_probes_ucast ; unsigned long periodic_gc_runs ; unsigned long forced_gc_runs ; unsigned long unres_discards ; unsigned long table_fulls ; }
s#neigh_table struct neigh_table { int family ; unsigned int entry_size ; unsigned int key_len ; t#__be16 protocol ; t#__u32 ( * hash ) ( const void * , const s#net_device * , t#__u32 * ) ; t#bool ( * key_eq ) ( const s#neighbour * , const void * ) ; int ( * constructor ) ( s#neighbour * ) ; int ( * pconstructor ) ( s#pneigh_entry * ) ; void ( * pdestructor ) ( s#pneigh_entry * ) ; void ( * proxy_redo ) ( s#sk_buff * ) ; int ( * is_multicast ) ( const void * ) ; t#bool ( * allow_add ) ( const s#net_device * , s#netlink_ext_ack * ) ; char * id ; s#neigh_parms parms ; s#list_head parms_list ; int gc_interval ; int gc_thresh1 ; int gc_thresh2 ; int gc_thresh3 ; unsigned long last_flush ; s#delayed_work gc_work ; s#delayed_work managed_work ; s#timer_list proxy_timer ; s#sk_buff_head proxy_queue ; t#atomic_t entries ; t#atomic_t gc_entries ; s#list_head gc_list ; s#list_head managed_list ; t#rwlock_t lock ; unsigned long last_rand ; s#neigh_statistics * stats ; s#neigh_hash_table * nht ; s#pneigh_entry * * phash_buckets ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#neighbour@8167d134 struct neighbour { UNKNOWN }
s#neighbour@b77debc9 struct neighbour { s#neighbour * next ; s#neigh_table * tbl ; s#neigh_parms * parms ; unsigned long confirmed ; unsigned long updated ; t#rwlock_t lock ; t#refcount_t refcnt ; unsigned int arp_queue_len_bytes ; s#sk_buff_head arp_queue ; s#timer_list timer ; unsigned long used ; t#atomic_t probes ; t#u8 nud_state ; t#u8 type ; t#u8 dead ; t#u8 protocol ; t#u32 flags ; t#seqlock_t ha_lock ; unsigned char ha [ ( ( ( ( 32 ) ) + ( ( __typeof__ ( ( 32 ) ) ) ( ( sizeof ( unsigned long ) ) ) - 1 ) ) & ~ ( ( __typeof__ ( ( 32 ) ) ) ( ( sizeof ( unsigned long ) ) ) - 1 ) ) ] __attribute__ ( ( __aligned__ ( 8 ) ) ) ; s#hh_cache hh ; int ( * output ) ( s#neighbour * , s#sk_buff * ) ; const s#neigh_ops * ops ; s#list_head gc_list ; s#list_head managed_list ; s#callback_head rcu ; s#net_device * dev ; t#netdevice_tracker dev_tracker ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; t#u8 primary_key [ ] ; }
s#net@be3f1911 struct net { UNKNOWN }
s#net@c82d40a9 struct net { t#refcount_t passive ; t#spinlock_t rules_mod_lock ; unsigned int dev_base_seq ; t#u32 ifindex ; t#spinlock_t nsid_lock ; t#atomic_t fnhe_genid ; s#list_head list ; s#list_head exit_list ; s#llist_node defer_free_list ; s#llist_node cleanup_list ; s#key_tag * key_domain ; s#user_namespace * user_ns ; s#ucounts * ucounts ; s#idr netns_ids ; s#ns_common ns ; s#ref_tracker_dir refcnt_tracker ; s#ref_tracker_dir notrefcnt_tracker ; s#list_head dev_base_head ; s#proc_dir_entry * proc_net ; s#proc_dir_entry * proc_net_stat ; s#ctl_table_set sysctls ; s#sock * rtnl ; s#sock * genl_sock ; s#uevent_sock * uevent_sock ; s#hlist_head * dev_name_head ; s#hlist_head * dev_index_head ; s#xarray dev_by_index ; s#raw_notifier_head netdev_chain ; t#u32 hash_mix ; s#net_device * loopback_dev ; s#list_head rules_ops ; s#netns_core core ; s#netns_mib mib ; s#netns_packet packet ; s#netns_unix unx ; s#netns_nexthop nexthop ; s#netns_ipv4 ipv4 ; s#netns_ipv6 ipv6 ; s#netns_ieee802154_lowpan ieee802154_lowpan ; s#netns_sctp sctp ; s#netns_nf nf ; s#netns_ct ct ; s#netns_nftables nft ; s#netns_ft ft ; s#sk_buff_head wext_nlevents ; s#net_generic * gen ; s#netns_bpf bpf ; s#netns_xfrm xfrm ; t#u64 net_cookie ; s#netns_ipvs * ipvs ; s#netns_mpls mpls ; s#netns_can can ; s#netns_xdp xdp ; s#sock * crypto_nlsk ; s#sock * diag_nlsk ; }
s#net_device@025f9d55 struct net_device { t#__u8 __cacheline_group_begin__net_device_read_tx [ 0 ] ; union { struct { unsigned long priv_flags : 32 ; unsigned long lltx : 1 ; } ; struct { unsigned long priv_flags : 32 ; unsigned long lltx : 1 ; } priv_flags_fast ; } ; const s#net_device_ops * netdev_ops ; const s#header_ops * header_ops ; s#netdev_queue * _tx ; t#netdev_features_t gso_partial_features ; unsigned int real_num_tx_queues ; unsigned int gso_max_size ; unsigned int gso_ipv4_max_size ; t#u16 gso_max_segs ; t#s16 num_tc ; unsigned int mtu ; unsigned short needed_headroom ; s#netdev_tc_txq tc_to_txq [ 16 ] ; s#xps_dev_maps * xps_maps [ E#XPS_MAPS_MAX ] ; s#nf_hook_entries * nf_hooks_egress ; s#bpf_mprog_entry * tcx_egress ; t#__u8 __cacheline_group_end__net_device_read_tx [ 0 ] ; t#__u8 __cacheline_group_begin__net_device_read_txrx [ 0 ] ; union { s#pcpu_lstats * lstats ; s#pcpu_sw_netstats * tstats ; s#pcpu_dstats * dstats ; } ; unsigned long state ; unsigned int flags ; unsigned short hard_header_len ; t#netdev_features_t features ; s#inet6_dev * ip6_ptr ; t#__u8 __cacheline_group_end__net_device_read_txrx [ 0 ] ; t#__u8 __cacheline_group_begin__net_device_read_rx [ 0 ] ; s#bpf_prog * xdp_prog ; s#list_head ptype_specific ; int ifindex ; unsigned int real_num_rx_queues ; s#netdev_rx_queue * _rx ; unsigned long gro_flush_timeout ; t#u32 napi_defer_hard_irqs ; unsigned int gro_max_size ; unsigned int gro_ipv4_max_size ; t#rx_handler_func_t * rx_handler ; void * rx_handler_data ; t#possible_net_t nd_net ; s#netpoll_info * npinfo ; s#bpf_mprog_entry * tcx_ingress ; t#__u8 __cacheline_group_end__net_device_read_rx [ 0 ] ; char name [ 16 ] ; s#netdev_name_node * name_node ; s#dev_ifalias * ifalias ; unsigned long mem_end ; unsigned long mem_start ; unsigned long base_addr ; s#list_head dev_list ; s#list_head napi_list ; s#list_head unreg_list ; s#list_head close_list ; s#list_head ptype_all ; struct { s#list_head upper ; s#list_head lower ; } adj_list ; t#xdp_features_t xdp_features ; const s#xdp_metadata_ops * xdp_metadata_ops ; const s#xsk_tx_metadata_ops * xsk_tx_metadata_ops ; unsigned short gflags ; unsigned short needed_tailroom ; t#netdev_features_t hw_features ; t#netdev_features_t wanted_features ; t#netdev_features_t vlan_features ; t#netdev_features_t hw_enc_features ; t#netdev_features_t mpls_features ; unsigned int min_mtu ; unsigned int max_mtu ; unsigned short type ; unsigned char min_header_len ; unsigned char name_assign_type ; int group ; s#net_device_stats stats ; s#net_device_core_stats * core_stats ; t#atomic_t carrier_up_count ; t#atomic_t carrier_down_count ; const s#iw_handler_def * wireless_handlers ; s#iw_public_data * wireless_data ; const s#ethtool_ops * ethtool_ops ; const s#l3mdev_ops * l3mdev_ops ; const s#ndisc_ops * ndisc_ops ; const s#xfrmdev_ops * xfrmdev_ops ; const s#tlsdev_ops * tlsdev_ops ; unsigned int operstate ; unsigned char link_mode ; unsigned char if_port ; unsigned char dma ; unsigned char perm_addr [ 32 ] ; unsigned char addr_assign_type ; unsigned char addr_len ; unsigned char upper_level ; unsigned char lower_level ; unsigned short neigh_priv_len ; unsigned short dev_id ; unsigned short dev_port ; int irq ; t#u32 priv_len ; t#spinlock_t addr_list_lock ; s#netdev_hw_addr_list uc ; s#netdev_hw_addr_list mc ; s#netdev_hw_addr_list dev_addrs ; s#kset * queues_kset ; unsigned int promiscuity ; unsigned int allmulti ; t#bool uc_promisc ; s#in_device * ip_ptr ; s#vlan_info * vlan_info ; s#dsa_port * dsa_ptr ; s#tipc_bearer * tipc_ptr ; s#wireless_dev * ieee80211_ptr ; s#wpan_dev * ieee802154_ptr ; s#mpls_dev * mpls_ptr ; const unsigned char * dev_addr ; unsigned int num_rx_queues ; unsigned int xdp_zc_max_segs ; s#netdev_queue * ingress_queue ; s#nf_hook_entries * nf_hooks_ingress ; unsigned char broadcast [ 32 ] ; s#cpu_rmap * rx_cpu_rmap ; s#hlist_node index_hlist ; unsigned int num_tx_queues ; s#Qdisc * qdisc ; unsigned int tx_queue_len ; t#spinlock_t tx_global_lock ; s#xdp_dev_bulk_queue * xdp_bulkq ; s#hlist_head qdisc_hash [ 1 << ( 4 ) ] ; s#timer_list watchdog_timer ; int watchdog_timeo ; t#u32 proto_down_reason ; s#list_head todo_list ; int * pcpu_refcnt ; s#ref_tracker_dir refcnt_tracker ; s#list_head link_watch_list ; t#u8 reg_state ; t#bool dismantle ; enum { RTNL_LINK_INITIALIZED , RTNL_LINK_INITIALIZING , } rtnl_link_state : 16 ; t#bool needs_free_netdev ; void ( * priv_destructor ) ( s#net_device * ) ; void * ml_priv ; e#netdev_ml_priv_type ml_priv_type ; e#netdev_stat_type pcpu_stat_type : 8 ; s#garp_port * garp_port ; s#mrp_port * mrp_port ; s#dm_hw_stat_delta * dm_private ; s#device dev ; const s#attribute_group * sysfs_groups [ 4 ] ; const s#attribute_group * sysfs_rx_queue_group ; const s#rtnl_link_ops * rtnl_link_ops ; const s#netdev_stat_ops * stat_ops ; const s#netdev_queue_mgmt_ops * queue_mgmt_ops ; unsigned int tso_max_size ; t#u16 tso_max_segs ; const s#dcbnl_rtnl_ops * dcbnl_ops ; t#u8 prio_tc_map [ 15 + 1 ] ; unsigned int fcoe_ddp_xid ; s#netprio_map * priomap ; s#phy_link_topology * link_topo ; s#phy_device * phydev ; s#sfp_bus * sfp_bus ; s#lock_class_key * qdisc_tx_busylock ; t#bool proto_down ; t#bool threaded ; unsigned long see_all_hwtstamp_requests : 1 ; unsigned long change_proto_down : 1 ; unsigned long netns_local : 1 ; unsigned long fcoe_mtu : 1 ; s#list_head net_notifier_list ; const s#macsec_ops * macsec_ops ; const s#udp_tunnel_nic_info * udp_tunnel_nic_info ; s#udp_tunnel_nic * udp_tunnel_nic ; s#ethtool_netdev_state * ethtool ; s#bpf_xdp_entity xdp_state [ E#__MAX_XDP_MODE ] ; t#u8 dev_addr_shadow [ 32 ] ; t#netdevice_tracker linkwatch_dev_tracker ; t#netdevice_tracker watchdog_dev_tracker ; t#netdevice_tracker dev_registered_tracker ; s#rtnl_hw_stats64 * offload_xstats_l3 ; s#devlink_port * devlink_port ; s#dpll_pin * dpll_pin ; s#hlist_head page_pools ; s#dim_irq_moder * irq_moder ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; t#u8 priv [ ] __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; }
s#net_device@f8d214a7 struct net_device { UNKNOWN }
s#net_device_core_stats struct net_device_core_stats { unsigned long rx_dropped ; unsigned long tx_dropped ; unsigned long rx_nohandler ; unsigned long rx_otherhost_dropped ; }
s#net_device_ops struct net_device_ops { int ( * ndo_init ) ( s#net_device * ) ; void ( * ndo_uninit ) ( s#net_device * ) ; int ( * ndo_open ) ( s#net_device * ) ; int ( * ndo_stop ) ( s#net_device * ) ; t#netdev_tx_t ( * ndo_start_xmit ) ( s#sk_buff * , s#net_device * ) ; t#netdev_features_t ( * ndo_features_check ) ( s#sk_buff * , s#net_device * , t#netdev_features_t ) ; t#u16 ( * ndo_select_queue ) ( s#net_device * , s#sk_buff * , s#net_device * ) ; void ( * ndo_change_rx_flags ) ( s#net_device * , int ) ; void ( * ndo_set_rx_mode ) ( s#net_device * ) ; int ( * ndo_set_mac_address ) ( s#net_device * , void * ) ; int ( * ndo_validate_addr ) ( s#net_device * ) ; int ( * ndo_do_ioctl ) ( s#net_device * , s#ifreq * , int ) ; int ( * ndo_eth_ioctl ) ( s#net_device * , s#ifreq * , int ) ; int ( * ndo_siocbond ) ( s#net_device * , s#ifreq * , int ) ; int ( * ndo_siocwandev ) ( s#net_device * , s#if_settings * ) ; int ( * ndo_siocdevprivate ) ( s#net_device * , s#ifreq * , void * , int ) ; int ( * ndo_set_config ) ( s#net_device * , s#ifmap * ) ; int ( * ndo_change_mtu ) ( s#net_device * , int ) ; int ( * ndo_neigh_setup ) ( s#net_device * , s#neigh_parms * ) ; void ( * ndo_tx_timeout ) ( s#net_device * , unsigned int ) ; void ( * ndo_get_stats64 ) ( s#net_device * , s#rtnl_link_stats64 * ) ; t#bool ( * ndo_has_offload_stats ) ( const s#net_device * , int ) ; int ( * ndo_get_offload_stats ) ( int , const s#net_device * , void * ) ; s#net_device_stats * ( * ndo_get_stats ) ( s#net_device * ) ; int ( * ndo_vlan_rx_add_vid ) ( s#net_device * , t#__be16 , t#u16 ) ; int ( * ndo_vlan_rx_kill_vid ) ( s#net_device * , t#__be16 , t#u16 ) ; void ( * ndo_poll_controller ) ( s#net_device * ) ; int ( * ndo_netpoll_setup ) ( s#net_device * , s#netpoll_info * ) ; void ( * ndo_netpoll_cleanup ) ( s#net_device * ) ; int ( * ndo_set_vf_mac ) ( s#net_device * , int , t#u8 * ) ; int ( * ndo_set_vf_vlan ) ( s#net_device * , int , t#u16 , t#u8 , t#__be16 ) ; int ( * ndo_set_vf_rate ) ( s#net_device * , int , int , int ) ; int ( * ndo_set_vf_spoofchk ) ( s#net_device * , int , t#bool ) ; int ( * ndo_set_vf_trust ) ( s#net_device * , int , t#bool ) ; int ( * ndo_get_vf_config ) ( s#net_device * , int , s#ifla_vf_info * ) ; int ( * ndo_set_vf_link_state ) ( s#net_device * , int , int ) ; int ( * ndo_get_vf_stats ) ( s#net_device * , int , s#ifla_vf_stats * ) ; int ( * ndo_set_vf_port ) ( s#net_device * , int , s#nlattr * [ ] ) ; int ( * ndo_get_vf_port ) ( s#net_device * , int , s#sk_buff * ) ; int ( * ndo_get_vf_guid ) ( s#net_device * , int , s#ifla_vf_guid * , s#ifla_vf_guid * ) ; int ( * ndo_set_vf_guid ) ( s#net_device * , int , t#u64 , int ) ; int ( * ndo_set_vf_rss_query_en ) ( s#net_device * , int , t#bool ) ; int ( * ndo_setup_tc ) ( s#net_device * , e#tc_setup_type , void * ) ; int ( * ndo_fcoe_enable ) ( s#net_device * ) ; int ( * ndo_fcoe_disable ) ( s#net_device * ) ; int ( * ndo_fcoe_ddp_setup ) ( s#net_device * , t#u16 , s#scatterlist * , unsigned int ) ; int ( * ndo_fcoe_ddp_done ) ( s#net_device * , t#u16 ) ; int ( * ndo_fcoe_ddp_target ) ( s#net_device * , t#u16 , s#scatterlist * , unsigned int ) ; int ( * ndo_fcoe_get_hbainfo ) ( s#net_device * , s#netdev_fcoe_hbainfo * ) ; int ( * ndo_fcoe_get_wwn ) ( s#net_device * , t#u64 * , int ) ; int ( * ndo_rx_flow_steer ) ( s#net_device * , const s#sk_buff * , t#u16 , t#u32 ) ; int ( * ndo_add_slave ) ( s#net_device * , s#net_device * , s#netlink_ext_ack * ) ; int ( * ndo_del_slave ) ( s#net_device * , s#net_device * ) ; s#net_device * ( * ndo_get_xmit_slave ) ( s#net_device * , s#sk_buff * , t#bool ) ; s#net_device * ( * ndo_sk_get_lower_dev ) ( s#net_device * , s#sock * ) ; t#netdev_features_t ( * ndo_fix_features ) ( s#net_device * , t#netdev_features_t ) ; int ( * ndo_set_features ) ( s#net_device * , t#netdev_features_t ) ; int ( * ndo_neigh_construct ) ( s#net_device * , s#neighbour * ) ; void ( * ndo_neigh_destroy ) ( s#net_device * , s#neighbour * ) ; int ( * ndo_fdb_add ) ( s#ndmsg * , s#nlattr * [ ] , s#net_device * , const unsigned char * , t#u16 , t#u16 , s#netlink_ext_ack * ) ; int ( * ndo_fdb_del ) ( s#ndmsg * , s#nlattr * [ ] , s#net_device * , const unsigned char * , t#u16 , s#netlink_ext_ack * ) ; int ( * ndo_fdb_del_bulk ) ( s#nlmsghdr * , s#net_device * , s#netlink_ext_ack * ) ; int ( * ndo_fdb_dump ) ( s#sk_buff * , s#netlink_callback * , s#net_device * , s#net_device * , int * ) ; int ( * ndo_fdb_get ) ( s#sk_buff * , s#nlattr * [ ] , s#net_device * , const unsigned char * , t#u16 , t#u32 , t#u32 , s#netlink_ext_ack * ) ; int ( * ndo_mdb_add ) ( s#net_device * , s#nlattr * [ ] , t#u16 , s#netlink_ext_ack * ) ; int ( * ndo_mdb_del ) ( s#net_device * , s#nlattr * [ ] , s#netlink_ext_ack * ) ; int ( * ndo_mdb_del_bulk ) ( s#net_device * , s#nlattr * [ ] , s#netlink_ext_ack * ) ; int ( * ndo_mdb_dump ) ( s#net_device * , s#sk_buff * , s#netlink_callback * ) ; int ( * ndo_mdb_get ) ( s#net_device * , s#nlattr * [ ] , t#u32 , t#u32 , s#netlink_ext_ack * ) ; int ( * ndo_bridge_setlink ) ( s#net_device * , s#nlmsghdr * , t#u16 , s#netlink_ext_ack * ) ; int ( * ndo_bridge_getlink ) ( s#sk_buff * , t#u32 , t#u32 , s#net_device * , t#u32 , int ) ; int ( * ndo_bridge_dellink ) ( s#net_device * , s#nlmsghdr * , t#u16 ) ; int ( * ndo_change_carrier ) ( s#net_device * , t#bool ) ; int ( * ndo_get_phys_port_id ) ( s#net_device * , s#netdev_phys_item_id * ) ; int ( * ndo_get_port_parent_id ) ( s#net_device * , s#netdev_phys_item_id * ) ; int ( * ndo_get_phys_port_name ) ( s#net_device * , char * , t#size_t ) ; void * ( * ndo_dfwd_add_station ) ( s#net_device * , s#net_device * ) ; void ( * ndo_dfwd_del_station ) ( s#net_device * , void * ) ; int ( * ndo_set_tx_maxrate ) ( s#net_device * , int , t#u32 ) ; int ( * ndo_get_iflink ) ( const s#net_device * ) ; int ( * ndo_fill_metadata_dst ) ( s#net_device * , s#sk_buff * ) ; void ( * ndo_set_rx_headroom ) ( s#net_device * , int ) ; int ( * ndo_bpf ) ( s#net_device * , s#netdev_bpf * ) ; int ( * ndo_xdp_xmit ) ( s#net_device * , int , s#xdp_frame * * , t#u32 ) ; s#net_device * ( * ndo_xdp_get_xmit_slave ) ( s#net_device * , s#xdp_buff * ) ; int ( * ndo_xsk_wakeup ) ( s#net_device * , t#u32 , t#u32 ) ; int ( * ndo_tunnel_ctl ) ( s#net_device * , s#ip_tunnel_parm_kern * , int ) ; s#net_device * ( * ndo_get_peer_dev ) ( s#net_device * ) ; int ( * ndo_fill_forward_path ) ( s#net_device_path_ctx * , s#net_device_path * ) ; t#ktime_t ( * ndo_get_tstamp ) ( s#net_device * , const s#skb_shared_hwtstamps * , t#bool ) ; int ( * ndo_hwtstamp_get ) ( s#net_device * , s#kernel_hwtstamp_config * ) ; int ( * ndo_hwtstamp_set ) ( s#net_device * , s#kernel_hwtstamp_config * , s#netlink_ext_ack * ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; }
s#net_device_path struct net_device_path { e#net_device_path_type type ; const s#net_device * dev ; union { struct { t#u16 id ; t#__be16 proto ; t#u8 h_dest [ 6 ] ; } encap ; struct { enum { DEV_PATH_BR_VLAN_KEEP , DEV_PATH_BR_VLAN_TAG , DEV_PATH_BR_VLAN_UNTAG , DEV_PATH_BR_VLAN_UNTAG_HW , } vlan_mode ; t#u16 vlan_id ; t#__be16 vlan_proto ; } bridge ; struct { int port ; t#u16 proto ; } dsa ; struct { t#u8 wdma_idx ; t#u8 queue ; t#u16 wcid ; t#u8 bss ; t#u8 amsdu ; } mtk_wdma ; } ; }
s#net_device_path_ctx struct net_device_path_ctx { const s#net_device * dev ; t#u8 daddr [ 6 ] ; int num_vlans ; struct { t#u16 id ; t#__be16 proto ; } vlan [ 2 ] ; }
s#net_device_stats struct net_device_stats { union { unsigned long rx_packets ; t#atomic_long_t __rx_packets ; } ; union { unsigned long tx_packets ; t#atomic_long_t __tx_packets ; } ; union { unsigned long rx_bytes ; t#atomic_long_t __rx_bytes ; } ; union { unsigned long tx_bytes ; t#atomic_long_t __tx_bytes ; } ; union { unsigned long rx_errors ; t#atomic_long_t __rx_errors ; } ; union { unsigned long tx_errors ; t#atomic_long_t __tx_errors ; } ; union { unsigned long rx_dropped ; t#atomic_long_t __rx_dropped ; } ; union { unsigned long tx_dropped ; t#atomic_long_t __tx_dropped ; } ; union { unsigned long multicast ; t#atomic_long_t __multicast ; } ; union { unsigned long collisions ; t#atomic_long_t __collisions ; } ; union { unsigned long rx_length_errors ; t#atomic_long_t __rx_length_errors ; } ; union { unsigned long rx_over_errors ; t#atomic_long_t __rx_over_errors ; } ; union { unsigned long rx_crc_errors ; t#atomic_long_t __rx_crc_errors ; } ; union { unsigned long rx_frame_errors ; t#atomic_long_t __rx_frame_errors ; } ; union { unsigned long rx_fifo_errors ; t#atomic_long_t __rx_fifo_errors ; } ; union { unsigned long rx_missed_errors ; t#atomic_long_t __rx_missed_errors ; } ; union { unsigned long tx_aborted_errors ; t#atomic_long_t __tx_aborted_errors ; } ; union { unsigned long tx_carrier_errors ; t#atomic_long_t __tx_carrier_errors ; } ; union { unsigned long tx_fifo_errors ; t#atomic_long_t __tx_fifo_errors ; } ; union { unsigned long tx_heartbeat_errors ; t#atomic_long_t __tx_heartbeat_errors ; } ; union { unsigned long tx_window_errors ; t#atomic_long_t __tx_window_errors ; } ; union { unsigned long rx_compressed ; t#atomic_long_t __rx_compressed ; } ; union { unsigned long tx_compressed ; t#atomic_long_t __tx_compressed ; } ; }
s#net_generic@1d11e6c7 struct net_generic { UNKNOWN }
s#net_generic@395da95a struct net_generic { union { struct { unsigned int len ; s#callback_head rcu ; } s ; struct { struct { } __empty_ptr ; void * ptr [ ] ; } ; } ; }
s#net_rate_estimator struct net_rate_estimator { UNKNOWN }
s#netdev_bpf struct netdev_bpf { e#bpf_netdev_command command ; union { struct { t#u32 flags ; s#bpf_prog * prog ; s#netlink_ext_ack * extack ; } ; struct { s#bpf_offloaded_map * offmap ; } ; struct { s#xsk_buff_pool * pool ; t#u16 queue_id ; } xsk ; } ; }
s#netdev_fcoe_hbainfo struct netdev_fcoe_hbainfo { char manufacturer [ 64 ] ; char serial_number [ 64 ] ; char hardware_version [ 64 ] ; char driver_version [ 64 ] ; char optionrom_version [ 64 ] ; char firmware_version [ 64 ] ; char model [ 256 ] ; char model_description [ 256 ] ; }
s#netdev_hw_addr_list struct netdev_hw_addr_list { s#list_head list ; int count ; s#rb_root tree ; }
s#netdev_lag_upper_info struct netdev_lag_upper_info { e#netdev_lag_tx_type tx_type ; e#netdev_lag_hash hash_type ; }
s#netdev_name_node@2ff0458c struct netdev_name_node { UNKNOWN }
s#netdev_name_node@7621124b struct netdev_name_node { s#hlist_node hlist ; s#list_head list ; s#net_device * dev ; const char * name ; s#callback_head rcu ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#netdev_notifier_changeupper_info struct netdev_notifier_changeupper_info { s#netdev_notifier_info info ; s#net_device * upper_dev ; t#bool master ; t#bool linking ; void * upper_info ; }
s#netdev_notifier_info struct netdev_notifier_info { s#net_device * dev ; s#netlink_ext_ack * extack ; }
s#netdev_phys_item_id struct netdev_phys_item_id { unsigned char id [ 32 ] ; unsigned char id_len ; }
s#netdev_queue struct netdev_queue { s#net_device * dev ; t#netdevice_tracker dev_tracker ; s#Qdisc * qdisc ; s#Qdisc * qdisc_sleeping ; s#kobject kobj ; unsigned long tx_maxrate ; t#atomic_long_t trans_timeout ; s#net_device * sb_dev ; s#xsk_buff_pool * pool ; s#dql dql ; t#spinlock_t _xmit_lock __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; int xmit_lock_owner ; unsigned long trans_start ; unsigned long state ; s#napi_struct * napi ; int numa_node ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#netdev_queue_mgmt_ops struct netdev_queue_mgmt_ops { UNKNOWN }
s#netdev_rx_queue@13c6ee90 struct netdev_rx_queue { UNKNOWN }
s#netdev_rx_queue@6bd779af struct netdev_rx_queue { s#xdp_rxq_info xdp_rxq ; s#rps_map * rps_map ; s#rps_dev_flow_table * rps_flow_table ; s#kobject kobj ; s#net_device * dev ; t#netdevice_tracker dev_tracker ; s#xsk_buff_pool * pool ; s#napi_struct * napi ; s#pp_memory_provider_params mp_params ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; }
s#netdev_stat_ops struct netdev_stat_ops { UNKNOWN }
s#netdev_tc_txq struct netdev_tc_txq { t#u16 count ; t#u16 offset ; }
s#netfs_cache_ops struct netfs_cache_ops { void ( * end_operation ) ( s#netfs_cache_resources * ) ; int ( * read ) ( s#netfs_cache_resources * , t#loff_t , s#iov_iter * , e#netfs_read_from_hole , t#netfs_io_terminated_t , void * ) ; int ( * write ) ( s#netfs_cache_resources * , t#loff_t , s#iov_iter * , t#netfs_io_terminated_t , void * ) ; void ( * issue_write ) ( s#netfs_io_subrequest * ) ; void ( * expand_readahead ) ( s#netfs_cache_resources * , unsigned long long * , unsigned long long * , unsigned long long ) ; e#netfs_io_source ( * prepare_read ) ( s#netfs_io_subrequest * , unsigned long long ) ; void ( * prepare_write_subreq ) ( s#netfs_io_subrequest * ) ; int ( * prepare_write ) ( s#netfs_cache_resources * , t#loff_t * , t#size_t * , t#size_t , t#loff_t , t#bool ) ; e#netfs_io_source ( * prepare_ondemand_read ) ( s#netfs_cache_resources * , t#loff_t , t#size_t * , t#loff_t , unsigned long * , t#ino_t ) ; int ( * query_occupancy ) ( s#netfs_cache_resources * , t#loff_t , t#size_t , t#size_t , t#loff_t * , t#size_t * ) ; }
s#netfs_cache_resources struct netfs_cache_resources { const s#netfs_cache_ops * ops ; void * cache_priv ; void * cache_priv2 ; unsigned int debug_id ; unsigned int inval_counter ; }
s#netfs_group struct netfs_group { t#refcount_t ref ; void ( * free ) ( s#netfs_group * ) ; }
s#netfs_io_request struct netfs_io_request { union { s#work_struct work ; s#callback_head rcu ; } ; s#inode * inode ; s#address_space * mapping ; s#kiocb * iocb ; s#netfs_cache_resources cache_resources ; s#readahead_control * ractl ; s#list_head proc_link ; s#list_head subrequests ; s#netfs_io_stream io_streams [ 2 ] ; s#netfs_group * group ; s#folio_queue * buffer ; s#folio_queue * buffer_tail ; s#iov_iter iter ; s#iov_iter io_iter ; void * netfs_priv ; void * netfs_priv2 ; s#bio_vec * direct_bv ; unsigned int direct_bv_count ; unsigned int debug_id ; unsigned int rsize ; unsigned int wsize ; t#atomic_t subreq_counter ; unsigned int nr_group_rel ; t#spinlock_t lock ; t#atomic_t nr_outstanding ; unsigned long long submitted ; unsigned long long len ; t#size_t transferred ; long error ; e#netfs_io_origin origin ; t#bool direct_bv_unpin ; t#u8 buffer_head_slot ; t#u8 buffer_tail_slot ; unsigned long long i_size ; unsigned long long start ; t#atomic64_t issued_to ; unsigned long long collected_to ; unsigned long long cleaned_to ; unsigned long no_unlock_folio ; t#size_t prev_donated ; t#refcount_t ref ; unsigned long flags ; const s#netfs_request_ops * netfs_ops ; void ( * cleanup ) ( s#netfs_io_request * ) ; }
s#netfs_io_stream struct netfs_io_stream { s#netfs_io_subrequest * construct ; t#size_t sreq_max_len ; unsigned int sreq_max_segs ; unsigned int submit_off ; unsigned int submit_len ; unsigned int submit_extendable_to ; void ( * prepare_write ) ( s#netfs_io_subrequest * ) ; void ( * issue_write ) ( s#netfs_io_subrequest * ) ; s#list_head subrequests ; s#netfs_io_subrequest * front ; unsigned long long collected_to ; t#size_t transferred ; e#netfs_io_source source ; unsigned short error ; unsigned char stream_nr ; t#bool avail ; t#bool active ; t#bool need_retry ; t#bool failed ; }
s#netfs_io_subrequest struct netfs_io_subrequest { s#netfs_io_request * rreq ; s#work_struct work ; s#list_head rreq_link ; s#iov_iter io_iter ; unsigned long long start ; t#size_t len ; t#size_t transferred ; t#size_t consumed ; t#size_t prev_donated ; t#size_t next_donated ; t#refcount_t ref ; short error ; unsigned short debug_index ; unsigned int nr_segs ; e#netfs_io_source source ; unsigned char stream_nr ; unsigned char curr_folioq_slot ; unsigned char curr_folio_order ; s#folio_queue * curr_folioq ; unsigned long flags ; }
s#netfs_request_ops struct netfs_request_ops { t#mempool_t * request_pool ; t#mempool_t * subrequest_pool ; int ( * init_request ) ( s#netfs_io_request * , s#file * ) ; void ( * free_request ) ( s#netfs_io_request * ) ; void ( * free_subrequest ) ( s#netfs_io_subrequest * ) ; void ( * expand_readahead ) ( s#netfs_io_request * ) ; int ( * prepare_read ) ( s#netfs_io_subrequest * ) ; void ( * issue_read ) ( s#netfs_io_subrequest * ) ; t#bool ( * is_still_valid ) ( s#netfs_io_request * ) ; int ( * check_write_begin ) ( s#file * , t#loff_t , unsigned , s#folio * * , void * * ) ; void ( * done ) ( s#netfs_io_request * ) ; void ( * update_i_size ) ( s#inode * , t#loff_t ) ; void ( * post_modify ) ( s#inode * ) ; void ( * begin_writeback ) ( s#netfs_io_request * ) ; void ( * prepare_write ) ( s#netfs_io_subrequest * ) ; void ( * issue_write ) ( s#netfs_io_subrequest * ) ; void ( * retry_request ) ( s#netfs_io_request * , s#netfs_io_stream * ) ; void ( * invalidate_cache ) ( s#netfs_io_request * ) ; }
s#netlink_callback struct netlink_callback { s#sk_buff * skb ; const s#nlmsghdr * nlh ; int ( * dump ) ( s#sk_buff * , s#netlink_callback * ) ; int ( * done ) ( s#netlink_callback * ) ; void * data ; s#module * module ; s#netlink_ext_ack * extack ; t#u16 family ; t#u16 answer_flags ; t#u32 min_dump_alloc ; unsigned int prev_seq , seq ; int flags ; t#bool strict_check ; union { t#u8 ctx [ 48 ] ; long args [ 6 ] ; } ; }
s#netlink_ext_ack struct netlink_ext_ack { const char * _msg ; const s#nlattr * bad_attr ; const s#nla_policy * policy ; const s#nlattr * miss_nest ; t#u16 miss_type ; t#u8 cookie [ 20 ] ; t#u8 cookie_len ; char _msg_buf [ 80 ] ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#netlink_range_validation struct netlink_range_validation { t#u64 min , max ; }
s#netlink_range_validation_signed struct netlink_range_validation_signed { t#s64 min , max ; }
s#netns_bpf struct netns_bpf { s#bpf_prog_array * run_array [ E#MAX_NETNS_BPF_ATTACH_TYPE ] ; s#bpf_prog * progs [ E#MAX_NETNS_BPF_ATTACH_TYPE ] ; s#list_head links [ E#MAX_NETNS_BPF_ATTACH_TYPE ] ; }
s#netns_can struct netns_can { s#proc_dir_entry * proc_dir ; s#proc_dir_entry * pde_stats ; s#proc_dir_entry * pde_reset_stats ; s#proc_dir_entry * pde_rcvlist_all ; s#proc_dir_entry * pde_rcvlist_fil ; s#proc_dir_entry * pde_rcvlist_inv ; s#proc_dir_entry * pde_rcvlist_sff ; s#proc_dir_entry * pde_rcvlist_eff ; s#proc_dir_entry * pde_rcvlist_err ; s#proc_dir_entry * bcmproc_dir ; s#can_dev_rcv_lists * rx_alldev_list ; t#spinlock_t rcvlists_lock ; s#timer_list stattimer ; s#can_pkg_stats * pkg_stats ; s#can_rcv_lists_stats * rcv_lists_stats ; s#hlist_head cgw_list ; }
s#netns_core struct netns_core { s#ctl_table_header * sysctl_hdr ; int sysctl_somaxconn ; int sysctl_optmem_max ; t#u8 sysctl_txrehash ; s#prot_inuse * prot_inuse ; s#cpumask * rps_default_mask ; }
s#netns_ct struct netns_ct { t#bool ecache_dwork_pending ; t#u8 sysctl_log_invalid ; t#u8 sysctl_events ; t#u8 sysctl_acct ; t#u8 sysctl_tstamp ; t#u8 sysctl_checksum ; s#ip_conntrack_stat * stat ; s#nf_ct_event_notifier * nf_conntrack_event_cb ; s#nf_ip_net nf_ct_proto ; t#atomic_t labels_used ; }
s#netns_ft struct netns_ft { s#nf_flow_table_stat * stat ; }
s#netns_ieee802154_lowpan struct netns_ieee802154_lowpan { s#netns_sysctl_lowpan sysctl ; s#fqdir * fqdir ; }
s#netns_ipv4 struct netns_ipv4 { t#__u8 __cacheline_group_begin__netns_ipv4_read_tx [ 0 ] ; t#u8 sysctl_tcp_early_retrans ; t#u8 sysctl_tcp_tso_win_divisor ; t#u8 sysctl_tcp_tso_rtt_log ; t#u8 sysctl_tcp_autocorking ; int sysctl_tcp_min_snd_mss ; unsigned int sysctl_tcp_notsent_lowat ; int sysctl_tcp_limit_output_bytes ; int sysctl_tcp_min_rtt_wlen ; int sysctl_tcp_wmem [ 3 ] ; t#u8 sysctl_ip_fwd_use_pmtu ; t#__u8 __cacheline_group_end__netns_ipv4_read_tx [ 0 ] ; t#__u8 __cacheline_group_begin__netns_ipv4_read_txrx [ 0 ] ; t#u8 sysctl_tcp_moderate_rcvbuf ; t#__u8 __cacheline_group_end__netns_ipv4_read_txrx [ 0 ] ; t#__u8 __cacheline_group_begin__netns_ipv4_read_rx [ 0 ] ; t#u8 sysctl_ip_early_demux ; t#u8 sysctl_tcp_early_demux ; int sysctl_tcp_reordering ; int sysctl_tcp_rmem [ 3 ] ; t#__u8 __cacheline_group_end__netns_ipv4_read_rx [ 0 ] ; s#inet_timewait_death_row tcp_death_row ; s#udp_table * udp_table ; s#ctl_table_header * forw_hdr ; s#ctl_table_header * frags_hdr ; s#ctl_table_header * ipv4_hdr ; s#ctl_table_header * route_hdr ; s#ctl_table_header * xfrm4_hdr ; s#ipv4_devconf * devconf_all ; s#ipv4_devconf * devconf_dflt ; s#ip_ra_chain * ra_chain ; s#mutex ra_mutex ; s#fib_rules_ops * rules_ops ; s#fib_table * fib_main ; s#fib_table * fib_default ; unsigned int fib_rules_require_fldissect ; t#bool fib_has_custom_rules ; t#bool fib_has_custom_local_routes ; t#bool fib_offload_disabled ; t#u8 sysctl_tcp_shrink_window ; t#atomic_t fib_num_tclassid_users ; s#hlist_head * fib_table_hash ; s#sock * fibnl ; s#sock * mc_autojoin_sk ; s#inet_peer_base * peers ; s#fqdir * fqdir ; t#u8 sysctl_icmp_echo_ignore_all ; t#u8 sysctl_icmp_echo_enable_probe ; t#u8 sysctl_icmp_echo_ignore_broadcasts ; t#u8 sysctl_icmp_ignore_bogus_error_responses ; t#u8 sysctl_icmp_errors_use_inbound_ifaddr ; int sysctl_icmp_ratelimit ; int sysctl_icmp_ratemask ; int sysctl_icmp_msgs_per_sec ; int sysctl_icmp_msgs_burst ; t#atomic_t icmp_global_credit ; t#u32 icmp_global_stamp ; t#u32 ip_rt_min_pmtu ; int ip_rt_mtu_expires ; int ip_rt_min_advmss ; s#local_ports ip_local_ports ; t#u8 sysctl_tcp_ecn ; t#u8 sysctl_tcp_ecn_fallback ; t#u8 sysctl_ip_default_ttl ; t#u8 sysctl_ip_no_pmtu_disc ; t#u8 sysctl_ip_fwd_update_priority ; t#u8 sysctl_ip_nonlocal_bind ; t#u8 sysctl_ip_autobind_reuse ; t#u8 sysctl_ip_dynaddr ; t#u8 sysctl_raw_l3mdev_accept ; t#u8 sysctl_udp_early_demux ; t#u8 sysctl_nexthop_compat_mode ; t#u8 sysctl_fwmark_reflect ; t#u8 sysctl_tcp_fwmark_accept ; t#u8 sysctl_tcp_l3mdev_accept ; t#u8 sysctl_tcp_mtu_probing ; int sysctl_tcp_mtu_probe_floor ; int sysctl_tcp_base_mss ; int sysctl_tcp_probe_threshold ; t#u32 sysctl_tcp_probe_interval ; int sysctl_tcp_keepalive_time ; int sysctl_tcp_keepalive_intvl ; t#u8 sysctl_tcp_keepalive_probes ; t#u8 sysctl_tcp_syn_retries ; t#u8 sysctl_tcp_synack_retries ; t#u8 sysctl_tcp_syncookies ; t#u8 sysctl_tcp_migrate_req ; t#u8 sysctl_tcp_comp_sack_nr ; t#u8 sysctl_tcp_backlog_ack_defer ; t#u8 sysctl_tcp_pingpong_thresh ; t#u8 sysctl_tcp_retries1 ; t#u8 sysctl_tcp_retries2 ; t#u8 sysctl_tcp_orphan_retries ; t#u8 sysctl_tcp_tw_reuse ; int sysctl_tcp_fin_timeout ; t#u8 sysctl_tcp_sack ; t#u8 sysctl_tcp_window_scaling ; t#u8 sysctl_tcp_timestamps ; int sysctl_tcp_rto_min_us ; t#u8 sysctl_tcp_recovery ; t#u8 sysctl_tcp_thin_linear_timeouts ; t#u8 sysctl_tcp_slow_start_after_idle ; t#u8 sysctl_tcp_retrans_collapse ; t#u8 sysctl_tcp_stdurg ; t#u8 sysctl_tcp_rfc1337 ; t#u8 sysctl_tcp_abort_on_overflow ; t#u8 sysctl_tcp_fack ; int sysctl_tcp_max_reordering ; int sysctl_tcp_adv_win_scale ; t#u8 sysctl_tcp_dsack ; t#u8 sysctl_tcp_app_win ; t#u8 sysctl_tcp_frto ; t#u8 sysctl_tcp_nometrics_save ; t#u8 sysctl_tcp_no_ssthresh_metrics_save ; t#u8 sysctl_tcp_workaround_signed_windows ; int sysctl_tcp_challenge_ack_limit ; t#u8 sysctl_tcp_min_tso_segs ; t#u8 sysctl_tcp_reflect_tos ; int sysctl_tcp_invalid_ratelimit ; int sysctl_tcp_pacing_ss_ratio ; int sysctl_tcp_pacing_ca_ratio ; unsigned int sysctl_tcp_child_ehash_entries ; unsigned long sysctl_tcp_comp_sack_delay_ns ; unsigned long sysctl_tcp_comp_sack_slack_ns ; int sysctl_max_syn_backlog ; int sysctl_tcp_fastopen ; const s#tcp_congestion_ops * tcp_congestion_control ; s#tcp_fastopen_context * tcp_fastopen_ctx ; unsigned int sysctl_tcp_fastopen_blackhole_timeout ; t#atomic_t tfo_active_disable_times ; unsigned long tfo_active_disable_stamp ; t#u32 tcp_challenge_timestamp ; t#u32 tcp_challenge_count ; t#u8 sysctl_tcp_plb_enabled ; t#u8 sysctl_tcp_plb_idle_rehash_rounds ; t#u8 sysctl_tcp_plb_rehash_rounds ; t#u8 sysctl_tcp_plb_suspend_rto_sec ; int sysctl_tcp_plb_cong_thresh ; int sysctl_udp_wmem_min ; int sysctl_udp_rmem_min ; t#u8 sysctl_fib_notify_on_flag_change ; t#u8 sysctl_tcp_syn_linear_timeouts ; t#u8 sysctl_udp_l3mdev_accept ; t#u8 sysctl_igmp_llm_reports ; int sysctl_igmp_max_memberships ; int sysctl_igmp_max_msf ; int sysctl_igmp_qrv ; s#ping_group_range ping_group_range ; t#atomic_t dev_addr_genid ; unsigned int sysctl_udp_child_hash_entries ; unsigned long * sysctl_local_reserved_ports ; int sysctl_ip_prot_sock ; s#list_head mr_tables ; s#fib_rules_ops * mr_rules_ops ; s#sysctl_fib_multipath_hash_seed sysctl_fib_multipath_hash_seed ; t#u32 sysctl_fib_multipath_hash_fields ; t#u8 sysctl_fib_multipath_use_neigh ; t#u8 sysctl_fib_multipath_hash_policy ; s#fib_notifier_ops * notifier_ops ; unsigned int fib_seq ; s#fib_notifier_ops * ipmr_notifier_ops ; unsigned int ipmr_seq ; t#atomic_t rt_genid ; t#siphash_key_t ip_id_key ; }
s#netns_ipv6 struct netns_ipv6 { s#dst_ops ip6_dst_ops ; s#netns_sysctl_ipv6 sysctl ; s#ipv6_devconf * devconf_all ; s#ipv6_devconf * devconf_dflt ; s#inet_peer_base * peers ; s#fqdir * fqdir ; s#fib6_info * fib6_null_entry ; s#rt6_info * ip6_null_entry ; s#rt6_statistics * rt6_stats ; s#timer_list ip6_fib_timer ; s#hlist_head * fib_table_hash ; s#fib6_table * fib6_main_tbl ; s#list_head fib6_walkers ; t#rwlock_t fib6_walker_lock ; t#spinlock_t fib6_gc_lock ; t#atomic_t ip6_rt_gc_expire ; unsigned long ip6_rt_last_gc ; unsigned char flowlabel_has_excl ; t#bool fib6_has_custom_rules ; unsigned int fib6_rules_require_fldissect ; s#rt6_info * ip6_prohibit_entry ; s#rt6_info * ip6_blk_hole_entry ; s#fib6_table * fib6_local_tbl ; s#fib_rules_ops * fib6_rules_ops ; s#sock * ndisc_sk ; s#sock * tcp_sk ; s#sock * igmp_sk ; s#sock * mc_autojoin_sk ; s#hlist_head * inet6_addr_lst ; t#spinlock_t addrconf_hash_lock ; s#delayed_work addr_chk_work ; s#list_head mr6_tables ; s#fib_rules_ops * mr6_rules_ops ; t#atomic_t dev_addr_genid ; t#atomic_t fib6_sernum ; s#seg6_pernet_data * seg6_data ; s#fib_notifier_ops * notifier_ops ; s#fib_notifier_ops * ip6mr_notifier_ops ; unsigned int ipmr_seq ; struct { s#hlist_head head ; t#spinlock_t lock ; t#u32 seq ; } ip6addrlbl_table ; s#ioam6_pernet_data * ioam6_data ; }
s#netns_ipvs@44694bf2 struct netns_ipvs { UNKNOWN }
s#netns_ipvs@c6cd616e struct netns_ipvs { int gen ; int enable ; s#hlist_head rs_table [ ( 1 << 4 ) ] ; s#list_head app_list ; s#ip_vs_proto_data * proto_data_table [ 32 ] ; s#list_head tcp_apps [ ( 1 << 4 ) ] ; s#list_head udp_apps [ ( 1 << 4 ) ] ; s#list_head sctp_apps [ ( 1 << 4 ) ] ; t#atomic_t conn_count ; s#ip_vs_stats_rcu * tot_stats ; int num_services ; int num_services6 ; s#list_head dest_trash ; t#spinlock_t dest_trash_lock ; s#timer_list dest_trash_timer ; t#atomic_t ftpsvc_counter ; t#atomic_t nullsvc_counter ; t#atomic_t conn_out_counter ; s#delayed_work expire_nodest_conn_work ; s#delayed_work defense_work ; int drop_rate ; int drop_counter ; int old_secure_tcp ; t#atomic_t dropentry ; t#spinlock_t dropentry_lock ; t#spinlock_t droppacket_lock ; t#spinlock_t securetcp_lock ; s#ctl_table_header * sysctl_hdr ; s#ctl_table * sysctl_tbl ; int sysctl_amemthresh ; int sysctl_am_droprate ; int sysctl_drop_entry ; int sysctl_drop_packet ; int sysctl_secure_tcp ; int sysctl_conntrack ; int sysctl_snat_reroute ; int sysctl_sync_ver ; int sysctl_sync_ports ; int sysctl_sync_persist_mode ; unsigned long sysctl_sync_qlen_max ; int sysctl_sync_sock_size ; int sysctl_cache_bypass ; int sysctl_expire_nodest_conn ; int sysctl_sloppy_tcp ; int sysctl_sloppy_sctp ; int sysctl_expire_quiescent_template ; int sysctl_sync_threshold [ 2 ] ; unsigned int sysctl_sync_refresh_period ; int sysctl_sync_retries ; int sysctl_nat_icmp_send ; int sysctl_pmtu_disc ; int sysctl_backup_only ; int sysctl_conn_reuse_mode ; int sysctl_schedule_icmp ; int sysctl_ignore_tunneled ; int sysctl_run_estimation ; t#cpumask_var_t sysctl_est_cpulist ; int est_cpulist_valid ; int sysctl_est_nice ; int est_stopped ; int sysctl_lblc_expiration ; s#ctl_table_header * lblc_ctl_header ; s#ctl_table * lblc_ctl_table ; int sysctl_lblcr_expiration ; s#ctl_table_header * lblcr_ctl_header ; s#ctl_table * lblcr_ctl_table ; s#delayed_work est_reload_work ; s#mutex est_mutex ; s#hlist_head est_temp_list ; s#ip_vs_est_kt_data * * est_kt_arr ; unsigned long est_max_threads ; int est_calc_phase ; int est_chain_max ; int est_kt_count ; int est_add_ktid ; t#atomic_t est_genid ; t#atomic_t est_genid_done ; t#spinlock_t sync_lock ; s#ipvs_master_sync_state * ms ; t#spinlock_t sync_buff_lock ; s#ip_vs_sync_thread_data * master_tinfo ; s#ip_vs_sync_thread_data * backup_tinfo ; int threads_mask ; volatile int sync_state ; s#mutex sync_mutex ; s#ipvs_sync_daemon_cfg mcfg ; s#ipvs_sync_daemon_cfg bcfg ; s#net * net ; unsigned int mixed_address_family_dests ; unsigned int hooks_afmask ; }
s#netns_mib struct netns_mib { __typeof__ ( s#ipstats_mib ) * ip_statistics ; __typeof__ ( s#ipstats_mib ) * ipv6_statistics ; __typeof__ ( s#tcp_mib ) * tcp_statistics ; __typeof__ ( s#linux_mib ) * net_statistics ; __typeof__ ( s#udp_mib ) * udp_statistics ; __typeof__ ( s#udp_mib ) * udp_stats_in6 ; __typeof__ ( s#linux_xfrm_mib ) * xfrm_statistics ; __typeof__ ( s#linux_tls_mib ) * tls_statistics ; __typeof__ ( s#mptcp_mib ) * mptcp_statistics ; __typeof__ ( s#udp_mib ) * udplite_statistics ; __typeof__ ( s#udp_mib ) * udplite_stats_in6 ; __typeof__ ( s#icmp_mib ) * icmp_statistics ; __typeof__ ( s#icmpmsg_mib ) * icmpmsg_statistics ; __typeof__ ( s#icmpv6_mib ) * icmpv6_statistics ; __typeof__ ( s#icmpv6msg_mib ) * icmpv6msg_statistics ; s#proc_dir_entry * proc_net_devsnmp6 ; }
s#netns_mpls struct netns_mpls { int ip_ttl_propagate ; int default_ttl ; t#size_t platform_labels ; s#mpls_route * * platform_label ; s#ctl_table_header * ctl ; }
s#netns_nexthop struct netns_nexthop { s#rb_root rb_root ; s#hlist_head * devhash ; unsigned int seq ; t#u32 last_id_allocated ; s#blocking_notifier_head notifier_chain ; }
s#netns_nf struct netns_nf { s#proc_dir_entry * proc_netfilter ; const s#nf_logger * nf_loggers [ E#NFPROTO_NUMPROTO ] ; s#ctl_table_header * nf_log_dir_header ; s#ctl_table_header * nf_lwtnl_dir_header ; s#nf_hook_entries * hooks_ipv4 [ E#NF_INET_NUMHOOKS ] ; s#nf_hook_entries * hooks_ipv6 [ E#NF_INET_NUMHOOKS ] ; s#nf_hook_entries * hooks_arp [ 3 ] ; s#nf_hook_entries * hooks_bridge [ E#NF_INET_NUMHOOKS ] ; unsigned int defrag_ipv4_users ; unsigned int defrag_ipv6_users ; }
s#netns_nftables struct netns_nftables { t#u8 gencursor ; }
s#netns_packet struct netns_packet { s#mutex sklist_lock ; s#hlist_head sklist ; }
s#netns_sctp struct netns_sctp { __typeof__ ( s#sctp_mib ) * sctp_statistics ; s#proc_dir_entry * proc_net_sctp ; s#ctl_table_header * sysctl_header ; s#sock * ctl_sock ; s#sock * udp4_sock ; s#sock * udp6_sock ; int udp_port ; int encap_port ; s#list_head local_addr_list ; s#list_head addr_waitq ; s#timer_list addr_wq_timer ; s#list_head auto_asconf_splist ; t#spinlock_t addr_wq_lock ; t#spinlock_t local_addr_lock ; unsigned int rto_initial ; unsigned int rto_min ; unsigned int rto_max ; int rto_alpha ; int rto_beta ; int max_burst ; int cookie_preserve_enable ; char * sctp_hmac_alg ; unsigned int valid_cookie_life ; unsigned int sack_timeout ; unsigned int hb_interval ; unsigned int probe_interval ; int max_retrans_association ; int max_retrans_path ; int max_retrans_init ; int pf_retrans ; int ps_retrans ; int pf_enable ; int pf_expose ; int sndbuf_policy ; int rcvbuf_policy ; int default_auto_asconf ; int addip_enable ; int addip_noauth ; int prsctp_enable ; int reconf_enable ; int auth_enable ; int intl_enable ; int ecn_enable ; int scope_policy ; int rwnd_upd_shift ; unsigned long max_autoclose ; int l3mdev_accept ; }
s#netns_sysctl_ipv6 struct netns_sysctl_ipv6 { s#ctl_table_header * hdr ; s#ctl_table_header * route_hdr ; s#ctl_table_header * icmp_hdr ; s#ctl_table_header * frags_hdr ; s#ctl_table_header * xfrm6_hdr ; int flush_delay ; int ip6_rt_max_size ; int ip6_rt_gc_min_interval ; int ip6_rt_gc_timeout ; int ip6_rt_gc_interval ; int ip6_rt_gc_elasticity ; int ip6_rt_mtu_expires ; int ip6_rt_min_advmss ; t#u32 multipath_hash_fields ; t#u8 multipath_hash_policy ; t#u8 bindv6only ; t#u8 flowlabel_consistency ; t#u8 auto_flowlabels ; int icmpv6_time ; t#u8 icmpv6_echo_ignore_all ; t#u8 icmpv6_echo_ignore_multicast ; t#u8 icmpv6_echo_ignore_anycast ; unsigned long icmpv6_ratemask [ ( ( ( 255 + 1 ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long * icmpv6_ratemask_ptr ; t#u8 anycast_src_echo_reply ; t#u8 ip_nonlocal_bind ; t#u8 fwmark_reflect ; t#u8 flowlabel_state_ranges ; int idgen_retries ; int idgen_delay ; int flowlabel_reflect ; int max_dst_opts_cnt ; int max_hbh_opts_cnt ; int max_dst_opts_len ; int max_hbh_opts_len ; int seg6_flowlabel ; t#u32 ioam6_id ; t#u64 ioam6_id_wide ; t#u8 skip_notify_on_dev_down ; t#u8 fib_notify_on_flag_change ; t#u8 icmpv6_error_anycast_as_unicast ; }
s#netns_sysctl_lowpan struct netns_sysctl_lowpan { s#ctl_table_header * frags_hdr ; }
s#netns_unix struct netns_unix { s#unix_table table ; int sysctl_max_dgram_qlen ; s#ctl_table_header * ctl ; }
s#netns_xdp struct netns_xdp { s#mutex lock ; s#hlist_head list ; }
s#netns_xfrm struct netns_xfrm { s#list_head state_all ; s#hlist_head * state_bydst ; s#hlist_head * state_bysrc ; s#hlist_head * state_byspi ; s#hlist_head * state_byseq ; s#hlist_head * state_cache_input ; unsigned int state_hmask ; unsigned int state_num ; s#work_struct state_hash_work ; s#list_head policy_all ; s#hlist_head * policy_byidx ; unsigned int policy_idx_hmask ; unsigned int idx_generator ; s#xfrm_policy_hash policy_bydst [ E#XFRM_POLICY_MAX ] ; unsigned int policy_count [ E#XFRM_POLICY_MAX * 2 ] ; s#work_struct policy_hash_work ; s#xfrm_policy_hthresh policy_hthresh ; s#list_head inexact_bins ; s#sock * nlsk ; s#sock * nlsk_stash ; t#u32 sysctl_aevent_etime ; t#u32 sysctl_aevent_rseqth ; int sysctl_larval_drop ; t#u32 sysctl_acq_expires ; t#u8 policy_default [ E#XFRM_POLICY_MAX ] ; s#ctl_table_header * sysctl_hdr ; s#dst_ops xfrm4_dst_ops ; s#dst_ops xfrm6_dst_ops ; t#spinlock_t xfrm_state_lock ; t#seqcount_spinlock_t xfrm_state_hash_generation ; t#seqcount_spinlock_t xfrm_policy_hash_generation ; t#spinlock_t xfrm_policy_lock ; s#mutex xfrm_cfg_mutex ; s#delayed_work nat_keepalive_work ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#netpoll struct netpoll { s#net_device * dev ; t#netdevice_tracker dev_tracker ; char dev_name [ 16 ] ; const char * name ; u#inet_addr local_ip , remote_ip ; t#bool ipv6 ; t#u16 local_port , remote_port ; t#u8 remote_mac [ 6 ] ; }
s#netpoll_info@1c74e1ed struct netpoll_info { UNKNOWN }
s#netpoll_info@98bfee78 struct netpoll_info { t#refcount_t refcnt ; s#semaphore dev_lock ; s#sk_buff_head txq ; s#delayed_work tx_work ; s#netpoll * netpoll ; s#callback_head rcu ; }
s#netprio_map struct netprio_map { s#callback_head rcu ; t#u32 priomap_len ; t#u32 priomap [ ] ; }
s#new_utsname struct new_utsname { char sysname [ 64 + 1 ] ; char nodename [ 64 + 1 ] ; char release [ 64 + 1 ] ; char version [ 64 + 1 ] ; char machine [ 64 + 1 ] ; char domainname [ 64 + 1 ] ; }
s#nexthop@1be8cdfa struct nexthop { s#rb_node rb_node ; s#list_head fi_list ; s#list_head f6i_list ; s#list_head fdb_list ; s#list_head grp_list ; s#net * net ; t#u32 id ; t#u8 protocol ; t#u8 nh_flags ; t#bool is_group ; t#refcount_t refcnt ; s#callback_head rcu ; union { s#nh_info * nh_info ; s#nh_group * nh_grp ; } ; }
s#nexthop@fa8f6e55 struct nexthop { UNKNOWN }
s#nf_conn@97995174 struct nf_conn { UNKNOWN }
s#nf_conn@b7b10fdf struct nf_conn { s#nf_conntrack ct_general ; t#spinlock_t lock ; t#u32 timeout ; s#nf_conntrack_zone zone ; s#nf_conntrack_tuple_hash tuplehash [ E#IP_CT_DIR_MAX ] ; unsigned long status ; t#possible_net_t ct_net ; s#hlist_node nat_bysource ; struct { } __nfct_init_offset ; s#nf_conn * master ; t#u_int32_t mark ; t#u_int32_t secmark ; s#nf_ct_ext * ext ; u#nf_conntrack_proto proto ; }
s#nf_conntrack struct nf_conntrack { t#refcount_t use ; }
s#nf_conntrack_expect struct nf_conntrack_expect { s#hlist_node lnode ; s#hlist_node hnode ; s#nf_conntrack_tuple tuple ; s#nf_conntrack_tuple_mask mask ; t#refcount_t use ; unsigned int flags ; unsigned int class ; void ( * expectfn ) ( s#nf_conn * , s#nf_conntrack_expect * ) ; s#nf_conntrack_helper * helper ; s#nf_conn * master ; s#timer_list timeout ; u#nf_inet_addr saved_addr ; u#nf_conntrack_man_proto saved_proto ; e#ip_conntrack_dir dir ; s#callback_head rcu ; }
s#nf_conntrack_expect_policy struct nf_conntrack_expect_policy { unsigned int max_expected ; unsigned int timeout ; char name [ 16 ] ; }
s#nf_conntrack_helper@45a3bca6 struct nf_conntrack_helper { s#hlist_node hnode ; char name [ 16 ] ; t#refcount_t refcnt ; s#module * me ; const s#nf_conntrack_expect_policy * expect_policy ; s#nf_conntrack_tuple tuple ; int ( * help ) ( s#sk_buff * , unsigned int , s#nf_conn * , e#ip_conntrack_info ) ; void ( * destroy ) ( s#nf_conn * ) ; int ( * from_nlattr ) ( s#nlattr * , s#nf_conn * ) ; int ( * to_nlattr ) ( s#sk_buff * , const s#nf_conn * ) ; unsigned int expect_class_max ; unsigned int flags ; unsigned int queue_num ; t#u16 data_len ; char nat_mod_name [ 16 ] ; }
s#nf_conntrack_helper@a2caf207 struct nf_conntrack_helper { UNKNOWN }
s#nf_conntrack_man struct nf_conntrack_man { u#nf_inet_addr u3 ; u#nf_conntrack_man_proto u ; t#u_int16_t l3num ; }
s#nf_conntrack_tuple@18a33e2e struct nf_conntrack_tuple { s#nf_conntrack_man src ; struct { u#nf_inet_addr u3 ; union { t#__be16 all ; struct { t#__be16 port ; } tcp ; struct { t#__be16 port ; } udp ; struct { t#u_int8_t type , code ; } icmp ; struct { t#__be16 port ; } dccp ; struct { t#__be16 port ; } sctp ; struct { t#__be16 key ; } gre ; } u ; t#u_int8_t protonum ; struct { } __nfct_hash_offsetend ; t#u_int8_t dir ; } dst ; }
s#nf_conntrack_tuple@20c83093 struct nf_conntrack_tuple { UNKNOWN }
s#nf_conntrack_tuple_hash struct nf_conntrack_tuple_hash { s#hlist_nulls_node hnnode ; s#nf_conntrack_tuple tuple ; }
s#nf_conntrack_tuple_mask struct nf_conntrack_tuple_mask { struct { u#nf_inet_addr u3 ; u#nf_conntrack_man_proto u ; } src ; }
s#nf_conntrack_zone struct nf_conntrack_zone { t#u16 id ; t#u8 flags ; t#u8 dir ; }
s#nf_ct_dccp struct nf_ct_dccp { t#u_int8_t role [ E#IP_CT_DIR_MAX ] ; t#u_int8_t state ; t#u_int8_t last_pkt ; t#u_int8_t last_dir ; t#u_int64_t handshake_seq ; }
s#nf_ct_event struct nf_ct_event { s#nf_conn * ct ; t#u32 portid ; int report ; }
s#nf_ct_event_notifier@1f7263e4 struct nf_ct_event_notifier { int ( * ct_event ) ( unsigned int , const s#nf_ct_event * ) ; int ( * exp_event ) ( unsigned int , const s#nf_exp_event * ) ; }
s#nf_ct_event_notifier@6bfe66ad struct nf_ct_event_notifier { UNKNOWN }
s#nf_ct_ext struct nf_ct_ext { t#u8 offset [ E#NF_CT_EXT_NUM ] ; t#u8 len ; unsigned int gen_id ; char data [ ] __attribute__ ( ( __aligned__ ( 8 ) ) ) ; }
s#nf_ct_gre struct nf_ct_gre { unsigned int stream_timeout ; unsigned int timeout ; }
s#nf_ct_udp struct nf_ct_udp { unsigned long stream_ts ; }
s#nf_dccp_net struct nf_dccp_net { t#u8 dccp_loose ; unsigned int dccp_timeout [ ( E#__CT_DCCP_MAX - 1 ) + 1 ] ; }
s#nf_exp_event struct nf_exp_event { s#nf_conntrack_expect * exp ; t#u32 portid ; int report ; }
s#nf_flow_key struct nf_flow_key { s#flow_dissector_key_meta meta ; s#flow_dissector_key_control control ; s#flow_dissector_key_control enc_control ; s#flow_dissector_key_basic basic ; s#flow_dissector_key_vlan vlan ; s#flow_dissector_key_vlan cvlan ; union { s#flow_dissector_key_ipv4_addrs ipv4 ; s#flow_dissector_key_ipv6_addrs ipv6 ; } ; s#flow_dissector_key_keyid enc_key_id ; union { s#flow_dissector_key_ipv4_addrs enc_ipv4 ; s#flow_dissector_key_ipv6_addrs enc_ipv6 ; } ; s#flow_dissector_key_tcp tcp ; s#flow_dissector_key_ports tp ; }
s#nf_flow_match struct nf_flow_match { s#flow_dissector dissector ; s#nf_flow_key key ; s#nf_flow_key mask ; }
s#nf_flow_rule struct nf_flow_rule { s#nf_flow_match match ; s#flow_rule * rule ; }
s#nf_flow_table_stat struct nf_flow_table_stat { unsigned int count_wq_add ; unsigned int count_wq_del ; unsigned int count_wq_stats ; }
s#nf_flowtable@6a810f74 struct nf_flowtable { unsigned int flags ; int priority ; s#rhashtable rhashtable ; s#list_head list ; const s#nf_flowtable_type * type ; s#delayed_work gc_work ; s#flow_block flow_block ; s#rw_semaphore flow_block_lock ; t#possible_net_t net ; }
s#nf_flowtable@ad90f932 struct nf_flowtable { UNKNOWN }
s#nf_flowtable_type struct nf_flowtable_type { s#list_head list ; int family ; int ( * init ) ( s#nf_flowtable * ) ; t#bool ( * gc ) ( const s#flow_offload * ) ; int ( * setup ) ( s#nf_flowtable * , s#net_device * , e#flow_block_command ) ; int ( * action ) ( s#net * , s#flow_offload * , e#flow_offload_tuple_dir , s#nf_flow_rule * ) ; void ( * free ) ( s#nf_flowtable * ) ; void ( * get ) ( s#nf_flowtable * ) ; void ( * put ) ( s#nf_flowtable * ) ; t#nf_hookfn * hook ; s#module * owner ; }
s#nf_generic_net struct nf_generic_net { unsigned int timeout ; }
s#nf_gre_net struct nf_gre_net { s#list_head keymap_list ; unsigned int timeouts [ E#GRE_CT_MAX ] ; }
s#nf_hook_entries@68c7f280 struct nf_hook_entries { UNKNOWN }
s#nf_hook_entries@eb89433b struct nf_hook_entries { t#u16 num_hook_entries ; s#nf_hook_entry hooks [ ] ; }
s#nf_hook_entry struct nf_hook_entry { t#nf_hookfn * hook ; void * priv ; }
s#nf_hook_state struct nf_hook_state { t#u8 hook ; t#u8 pf ; s#net_device * in ; s#net_device * out ; s#sock * sk ; s#net * net ; int ( * okfn ) ( s#net * , s#sock * , s#sk_buff * ) ; }
s#nf_icmp_net struct nf_icmp_net { unsigned int timeout ; }
s#nf_ip_net struct nf_ip_net { s#nf_generic_net generic ; s#nf_tcp_net tcp ; s#nf_udp_net udp ; s#nf_icmp_net icmp ; s#nf_icmp_net icmpv6 ; s#nf_dccp_net dccp ; s#nf_sctp_net sctp ; s#nf_gre_net gre ; }
s#nf_logger@bdabd2f7 struct nf_logger { UNKNOWN }
s#nf_logger@d81fb05a struct nf_logger { char * name ; e#nf_log_type type ; t#nf_logfn * logfn ; s#module * me ; }
s#nf_loginfo struct nf_loginfo { t#u_int8_t type ; union { struct { t#u_int32_t copy_len ; t#u_int16_t group ; t#u_int16_t qthreshold ; t#u_int16_t flags ; } ulog ; struct { t#u_int8_t level ; t#u_int8_t logflags ; } log ; } u ; }
s#nf_sctp_net struct nf_sctp_net { unsigned int timeouts [ E#SCTP_CONNTRACK_MAX ] ; }
s#nf_tcp_net struct nf_tcp_net { unsigned int timeouts [ E#TCP_CONNTRACK_TIMEOUT_MAX ] ; t#u8 tcp_loose ; t#u8 tcp_be_liberal ; t#u8 tcp_max_retrans ; t#u8 tcp_ignore_invalid_rst ; unsigned int offload_timeout ; }
s#nf_udp_net struct nf_udp_net { unsigned int timeouts [ E#UDP_CT_MAX ] ; unsigned int offload_timeout ; }
s#nfs41_impl_id struct nfs41_impl_id { char domain [ 1024 + 1 ] ; char name [ 1024 + 1 ] ; s#nfstime4 date ; }
s#nfs41_server_owner struct nfs41_server_owner { t#uint64_t minor_id ; t#uint32_t major_id_sz ; char major_id [ 1024 ] ; }
s#nfs41_server_scope struct nfs41_server_scope { t#uint32_t server_scope_sz ; char server_scope [ 1024 ] ; }
s#nfs42_layoutstat_args struct nfs42_layoutstat_args { s#nfs4_sequence_args seq_args ; s#nfs_fh * fh ; s#inode * inode ; t#nfs4_stateid stateid ; int num_dev ; s#nfs42_layoutstat_devinfo * devinfo ; }
s#nfs42_layoutstat_devinfo struct nfs42_layoutstat_devinfo { s#nfs4_deviceid dev_id ; t#__u64 offset ; t#__u64 length ; t#__u64 read_count ; t#__u64 read_bytes ; t#__u64 write_count ; t#__u64 write_bytes ; t#__u32 layout_type ; s#nfs4_xdr_opaque_data ld_private ; }
s#nfs4_change_info struct nfs4_change_info { t#u32 atomic ; t#u64 before ; t#u64 after ; }
s#nfs4_channel_attrs struct nfs4_channel_attrs { t#u32 max_rqst_sz ; t#u32 max_resp_sz ; t#u32 max_resp_sz_cached ; t#u32 max_ops ; t#u32 max_reqs ; }
s#nfs4_deviceid struct nfs4_deviceid { char data [ 16 ] ; }
s#nfs4_deviceid_node struct nfs4_deviceid_node { s#hlist_node node ; s#hlist_node tmpnode ; const s#pnfs_layoutdriver_type * ld ; const s#nfs_client * nfs_client ; unsigned long flags ; unsigned long timestamp_unavailable ; s#nfs4_deviceid deviceid ; s#callback_head rcu ; t#atomic_t ref ; }
s#nfs4_fs_location struct nfs4_fs_location { unsigned int nservers ; s#nfs4_string servers [ 10 ] ; s#nfs4_pathname rootpath ; }
s#nfs4_fs_locations struct nfs4_fs_locations { s#nfs_fattr * fattr ; const s#nfs_server * server ; s#nfs4_pathname fs_path ; int nlocations ; s#nfs4_fs_location locations [ 10 ] ; }
s#nfs4_label struct nfs4_label { t#uint32_t lfs ; t#uint32_t pi ; t#u32 len ; char * label ; }
s#nfs4_layoutcommit_args struct nfs4_layoutcommit_args { s#nfs4_sequence_args seq_args ; t#nfs4_stateid stateid ; t#__u64 lastbytewritten ; s#inode * inode ; const t#u32 * bitmask ; t#size_t layoutupdate_len ; s#page * layoutupdate_page ; s#page * * layoutupdate_pages ; t#__be32 * start_p ; }
s#nfs4_layoutcommit_data struct nfs4_layoutcommit_data { s#rpc_task task ; s#nfs_fattr fattr ; s#list_head lseg_list ; const s#cred * cred ; s#inode * inode ; s#nfs4_layoutcommit_args args ; s#nfs4_layoutcommit_res res ; }
s#nfs4_layoutcommit_res struct nfs4_layoutcommit_res { s#nfs4_sequence_res seq_res ; s#nfs_fattr * fattr ; const s#nfs_server * server ; int status ; }
s#nfs4_layoutdriver_data struct nfs4_layoutdriver_data { s#page * * pages ; t#__u32 pglen ; t#__u32 len ; }
s#nfs4_layoutget_res struct nfs4_layoutget_res { s#nfs4_sequence_res seq_res ; int status ; t#__u32 return_on_close ; s#pnfs_layout_range range ; t#__u32 type ; t#nfs4_stateid stateid ; s#nfs4_layoutdriver_data * layoutp ; }
s#nfs4_layoutreturn_args struct nfs4_layoutreturn_args { s#nfs4_sequence_args seq_args ; s#pnfs_layout_hdr * layout ; s#inode * inode ; s#pnfs_layout_range range ; t#nfs4_stateid stateid ; t#__u32 layout_type ; s#nfs4_xdr_opaque_data * ld_private ; }
s#nfs4_lock_info struct nfs4_lock_info { s#nfs4_lock_state * owner ; }
s#nfs4_lock_state@2f7636cb struct nfs4_lock_state { s#list_head ls_locks ; s#nfs4_state * ls_state ; unsigned long ls_flags ; s#nfs_seqid_counter ls_seqid ; t#nfs4_stateid ls_stateid ; t#refcount_t ls_count ; t#fl_owner_t ls_owner ; }
s#nfs4_lock_state@47003d93 struct nfs4_lock_state { UNKNOWN }
s#nfs4_mig_recovery_ops struct nfs4_mig_recovery_ops { int ( * get_locations ) ( s#nfs_server * , s#nfs_fh * , s#nfs4_fs_locations * , s#page * , const s#cred * ) ; int ( * fsid_present ) ( s#inode * , const s#cred * ) ; }
s#nfs4_minor_version_ops struct nfs4_minor_version_ops { t#u32 minor_version ; unsigned init_caps ; int ( * init_client ) ( s#nfs_client * ) ; void ( * shutdown_client ) ( s#nfs_client * ) ; t#bool ( * match_stateid ) ( const t#nfs4_stateid * , const t#nfs4_stateid * ) ; int ( * find_root_sec ) ( s#nfs_server * , s#nfs_fh * , s#nfs_fsinfo * ) ; void ( * free_lock_state ) ( s#nfs_server * , s#nfs4_lock_state * ) ; int ( * test_and_free_expired ) ( s#nfs_server * , const t#nfs4_stateid * , const s#cred * ) ; s#nfs_seqid * ( * alloc_seqid ) ( s#nfs_seqid_counter * , t#gfp_t ) ; void ( * session_trunk ) ( s#rpc_clnt * , s#rpc_xprt * , void * ) ; const s#rpc_call_ops * call_sync_ops ; const s#nfs4_state_recovery_ops * reboot_recovery_ops ; const s#nfs4_state_recovery_ops * nograce_recovery_ops ; const s#nfs4_state_maintenance_ops * state_renewal_ops ; const s#nfs4_mig_recovery_ops * mig_recovery_ops ; }
s#nfs4_pathname struct nfs4_pathname { unsigned int ncomponents ; s#nfs4_string components [ 512 ] ; }
s#nfs4_sequence_args struct nfs4_sequence_args { s#nfs4_slot * sa_slot ; t#u8 sa_cache_this : 1 , sa_privileged : 1 ; }
s#nfs4_sequence_res struct nfs4_sequence_res { s#nfs4_slot * sr_slot ; unsigned long sr_timestamp ; int sr_status ; t#u32 sr_status_flags ; t#u32 sr_highest_slotid ; t#u32 sr_target_highest_slotid ; }
s#nfs4_session@589de3a0 struct nfs4_session { UNKNOWN }
s#nfs4_session@f62f5117 struct nfs4_session { s#nfs4_sessionid sess_id ; t#u32 flags ; unsigned long session_state ; t#u32 hash_alg ; t#u32 ssv_len ; s#nfs4_channel_attrs fc_attrs ; s#nfs4_slot_table fc_slot_table ; s#nfs4_channel_attrs bc_attrs ; s#nfs4_slot_table bc_slot_table ; s#nfs_client * clp ; }
s#nfs4_sessionid struct nfs4_sessionid { unsigned char data [ 16 ] ; }
s#nfs4_slot@8094e42f struct nfs4_slot { s#nfs4_slot_table * table ; s#nfs4_slot * next ; unsigned long generation ; t#u32 slot_nr ; t#u32 seq_nr ; t#u32 seq_nr_last_acked ; t#u32 seq_nr_highest_sent ; unsigned int privileged : 1 , seq_done : 1 ; }
s#nfs4_slot@ca1d1edf struct nfs4_slot { UNKNOWN }
s#nfs4_slot_table@0aaa124d struct nfs4_slot_table { s#nfs4_session * session ; s#nfs4_slot * slots ; unsigned long used_slots [ ( ( ( ( 1024U ) ) + ( 64 ) - 1 ) / ( 64 ) ) ] ; t#spinlock_t slot_tbl_lock ; s#rpc_wait_queue slot_tbl_waitq ; t#wait_queue_head_t slot_waitq ; t#u32 max_slots ; t#u32 max_slotid ; t#u32 highest_used_slotid ; t#u32 target_highest_slotid ; t#u32 server_highest_slotid ; t#s32 d_target_highest_slotid ; t#s32 d2_target_highest_slotid ; unsigned long generation ; s#completion complete ; unsigned long slot_tbl_state ; }
s#nfs4_slot_table@7944e459 struct nfs4_slot_table { UNKNOWN }
s#nfs4_state struct nfs4_state { s#list_head open_states ; s#list_head inode_states ; s#list_head lock_states ; s#nfs4_state_owner * owner ; s#inode * inode ; unsigned long flags ; t#spinlock_t state_lock ; t#seqlock_t seqlock ; t#nfs4_stateid stateid ; t#nfs4_stateid open_stateid ; unsigned int n_rdonly ; unsigned int n_wronly ; unsigned int n_rdwr ; t#fmode_t state ; t#refcount_t count ; t#wait_queue_head_t waitq ; s#callback_head callback_head ; }
s#nfs4_state_maintenance_ops struct nfs4_state_maintenance_ops { int ( * sched_state_renewal ) ( s#nfs_client * , const s#cred * , unsigned ) ; const s#cred * ( * get_state_renewal_cred ) ( s#nfs_client * ) ; int ( * renew_lease ) ( s#nfs_client * , const s#cred * ) ; }
s#nfs4_state_owner struct nfs4_state_owner { s#nfs_server * so_server ; s#list_head so_lru ; unsigned long so_expires ; s#rb_node so_server_node ; const s#cred * so_cred ; t#spinlock_t so_lock ; t#atomic_t so_count ; unsigned long so_flags ; s#list_head so_states ; s#nfs_seqid_counter so_seqid ; s#mutex so_delegreturn_mutex ; }
s#nfs4_state_recovery_ops struct nfs4_state_recovery_ops { int owner_flag_bit ; int state_flag_bit ; int ( * recover_open ) ( s#nfs4_state_owner * , s#nfs4_state * ) ; int ( * recover_lock ) ( s#nfs4_state * , s#file_lock * ) ; int ( * establish_clid ) ( s#nfs_client * , const s#cred * ) ; int ( * reclaim_complete ) ( s#nfs_client * , const s#cred * ) ; int ( * detect_trunking ) ( s#nfs_client * , s#nfs_client * * , const s#cred * ) ; }
s#nfs4_stateid_struct struct nfs4_stateid_struct { union { char data [ ( 4 + 12 ) ] ; struct { t#__be32 seqid ; char other [ 12 ] ; } __attribute__ ( ( packed ) ) ; } ; enum { NFS4_INVALID_STATEID_TYPE = 0 , NFS4_SPECIAL_STATEID_TYPE , NFS4_OPEN_STATEID_TYPE , NFS4_LOCK_STATEID_TYPE , NFS4_DELEGATION_STATEID_TYPE , NFS4_LAYOUT_STATEID_TYPE , NFS4_PNFS_DS_STATEID_TYPE , NFS4_REVOKED_STATEID_TYPE , } type ; }
s#nfs4_string struct nfs4_string { unsigned int len ; char * data ; }
s#nfs4_threshold struct nfs4_threshold { t#__u32 bm ; t#__u32 l_type ; t#__u64 rd_sz ; t#__u64 wr_sz ; t#__u64 rd_io_sz ; t#__u64 wr_io_sz ; }
s#nfs4_xdr_opaque_data struct nfs4_xdr_opaque_data { const s#nfs4_xdr_opaque_ops * ops ; void * data ; }
s#nfs4_xdr_opaque_ops struct nfs4_xdr_opaque_ops { void ( * encode ) ( s#xdr_stream * , const void * , const s#nfs4_xdr_opaque_data * ) ; void ( * free ) ( s#nfs4_xdr_opaque_data * ) ; }
s#nfs_access_entry struct nfs_access_entry { s#rb_node rb_node ; s#list_head lru ; t#kuid_t fsuid ; t#kgid_t fsgid ; s#group_info * group_info ; t#u64 timestamp ; t#__u32 mask ; s#callback_head callback_head ; }
s#nfs_auth_info struct nfs_auth_info { unsigned int flavor_len ; t#rpc_authflavor_t flavors [ 12 ] ; }
s#nfs_client struct nfs_client { t#refcount_t cl_count ; t#atomic_t cl_mds_count ; int cl_cons_state ; unsigned long cl_res_state ; unsigned long cl_flags ; s#__kernel_sockaddr_storage cl_addr ; t#size_t cl_addrlen ; char * cl_hostname ; char * cl_acceptor ; s#list_head cl_share_link ; s#list_head cl_superblocks ; s#rpc_clnt * cl_rpcclient ; const s#nfs_rpc_ops * rpc_ops ; int cl_proto ; s#nfs_subversion * cl_nfs_mod ; t#u32 cl_minorversion ; unsigned int cl_nconnect ; unsigned int cl_max_connect ; const char * cl_principal ; s#xprtsec_parms cl_xprtsec ; s#list_head cl_ds_clients ; t#u64 cl_clientid ; t#nfs4_verifier cl_confirm ; unsigned long cl_state ; t#spinlock_t cl_lock ; unsigned long cl_lease_time ; unsigned long cl_last_renewal ; s#delayed_work cl_renewd ; s#rpc_wait_queue cl_rpcwaitq ; s#idmap * cl_idmap ; const char * cl_owner_id ; t#u32 cl_cb_ident ; const s#nfs4_minor_version_ops * cl_mvops ; unsigned long cl_mig_gen ; s#nfs4_slot_table * cl_slot_tbl ; t#u32 cl_seqid ; t#u32 cl_exchange_flags ; s#nfs4_session * cl_session ; t#bool cl_preserve_clid ; s#nfs41_server_owner * cl_serverowner ; s#nfs41_server_scope * cl_serverscope ; s#nfs41_impl_id * cl_implid ; unsigned long cl_sp4_flags ; t#wait_queue_head_t cl_lock_waitq ; char cl_ipaddr [ 48 ] ; s#net * cl_net ; s#list_head pending_cb_stateids ; s#callback_head rcu ; }
s#nfs_client_initdata@1bd9c856 struct nfs_client_initdata { unsigned long init_flags ; const char * hostname ; const s#__kernel_sockaddr_storage * addr ; const char * nodename ; const char * ip_addr ; t#size_t addrlen ; s#nfs_subversion * nfs_mod ; int proto ; t#u32 minorversion ; unsigned int nconnect ; unsigned int max_connect ; s#net * net ; const s#rpc_timeout * timeparms ; const s#cred * cred ; s#xprtsec_parms xprtsec ; unsigned long connect_timeout ; unsigned long reconnect_timeout ; }
s#nfs_client_initdata@7a5c196e struct nfs_client_initdata { UNKNOWN }
s#nfs_commit_completion_ops struct nfs_commit_completion_ops { void ( * completion ) ( s#nfs_commit_data * ) ; void ( * resched_write ) ( s#nfs_commit_info * , s#nfs_page * ) ; }
s#nfs_commit_data struct nfs_commit_data { s#rpc_task task ; s#inode * inode ; const s#cred * cred ; s#nfs_fattr fattr ; s#nfs_writeverf verf ; s#list_head pages ; s#list_head list ; s#nfs_direct_req * dreq ; s#nfs_commitargs args ; s#nfs_commitres res ; s#nfs_open_context * context ; s#pnfs_layout_segment * lseg ; s#nfs_client * ds_clp ; int ds_commit_index ; t#loff_t lwb ; const s#rpc_call_ops * mds_ops ; const s#nfs_commit_completion_ops * completion_ops ; int ( * commit_done_cb ) ( s#rpc_task * , s#nfs_commit_data * ) ; unsigned long flags ; }
s#nfs_commit_info struct nfs_commit_info { s#inode * inode ; s#nfs_mds_commit_info * mds ; s#pnfs_ds_commit_info * ds ; s#nfs_direct_req * dreq ; const s#nfs_commit_completion_ops * completion_ops ; }
s#nfs_commitargs struct nfs_commitargs { s#nfs4_sequence_args seq_args ; s#nfs_fh * fh ; t#__u64 offset ; t#__u32 count ; const t#u32 * bitmask ; }
s#nfs_commitres struct nfs_commitres { s#nfs4_sequence_res seq_res ; t#__u32 op_status ; s#nfs_fattr * fattr ; s#nfs_writeverf * verf ; const s#nfs_server * server ; }
s#nfs_direct_req@21aab289 struct nfs_direct_req { UNKNOWN }
s#nfs_direct_req@5d851fc4 struct nfs_direct_req { s#kref kref ; s#nfs_open_context * ctx ; s#nfs_lock_context * l_ctx ; s#kiocb * iocb ; s#inode * inode ; t#atomic_t io_count ; t#spinlock_t lock ; t#loff_t io_start ; t#ssize_t count , max_count , error ; s#completion completion ; s#nfs_mds_commit_info mds_cinfo ; s#pnfs_ds_commit_info ds_cinfo ; s#work_struct work ; int flags ; }
s#nfs_entry struct nfs_entry { t#__u64 ino ; t#__u64 cookie ; const char * name ; unsigned int len ; int eof ; s#nfs_fh * fh ; s#nfs_fattr * fattr ; unsigned char d_type ; s#nfs_server * server ; }
s#nfs_fattr struct nfs_fattr { unsigned int valid ; t#umode_t mode ; t#__u32 nlink ; t#kuid_t uid ; t#kgid_t gid ; t#dev_t rdev ; t#__u64 size ; union { struct { t#__u32 blocksize ; t#__u32 blocks ; } nfs2 ; struct { t#__u64 used ; } nfs3 ; } du ; s#nfs_fsid fsid ; t#__u64 fileid ; t#__u64 mounted_on_fileid ; s#timespec64 atime ; s#timespec64 mtime ; s#timespec64 ctime ; t#__u64 change_attr ; t#__u64 pre_change_attr ; t#__u64 pre_size ; s#timespec64 pre_mtime ; s#timespec64 pre_ctime ; unsigned long time_start ; unsigned long gencount ; s#nfs4_string * owner_name ; s#nfs4_string * group_name ; s#nfs4_threshold * mdsthreshold ; s#nfs4_label * label ; }
s#nfs_fh struct nfs_fh { unsigned short size ; unsigned char data [ 128 ] ; }
s#nfs_fsid struct nfs_fsid { t#uint64_t major ; t#uint64_t minor ; }
s#nfs_fsinfo struct nfs_fsinfo { s#nfs_fattr * fattr ; t#__u32 rtmax ; t#__u32 rtpref ; t#__u32 rtmult ; t#__u32 wtmax ; t#__u32 wtpref ; t#__u32 wtmult ; t#__u32 dtpref ; t#__u64 maxfilesize ; s#timespec64 time_delta ; t#__u32 lease_time ; t#__u32 nlayouttypes ; t#__u32 layouttype [ 8 ] ; t#__u32 blksize ; t#__u32 clone_blksize ; e#nfs4_change_attr_type change_attr_type ; t#__u32 xattr_support ; }
s#nfs_fsstat struct nfs_fsstat { s#nfs_fattr * fattr ; t#__u64 tbytes ; t#__u64 fbytes ; t#__u64 abytes ; t#__u64 tfiles ; t#__u64 ffiles ; t#__u64 afiles ; }
s#nfs_io_completion struct nfs_io_completion { UNKNOWN }
s#nfs_iostats@34ae7666 struct nfs_iostats { UNKNOWN }
s#nfs_iostats@753803a0 struct nfs_iostats { unsigned long long bytes [ E#__NFSIOS_BYTESMAX ] ; unsigned long events [ E#__NFSIOS_COUNTSMAX ] ; }
s#nfs_lock_context struct nfs_lock_context { t#refcount_t count ; s#list_head list ; s#nfs_open_context * open_context ; t#fl_owner_t lockowner ; t#atomic_t io_count ; s#callback_head callback_head ; }
s#nfs_lock_info struct nfs_lock_info { t#u32 state ; s#nlm_lockowner * owner ; s#list_head list ; }
s#nfs_mds_commit_info struct nfs_mds_commit_info { t#atomic_t rpcs_out ; t#atomic_long_t ncommit ; s#list_head list ; }
s#nfs_open_context struct nfs_open_context { s#nfs_lock_context lock_context ; t#fl_owner_t flock_owner ; s#dentry * dentry ; const s#cred * cred ; s#rpc_cred * ll_cred ; s#nfs4_state * state ; t#fmode_t mode ; unsigned long flags ; int error ; s#list_head list ; s#nfs4_threshold * mdsthreshold ; s#callback_head callback_head ; }
s#nfs_page@1b79c0fc struct nfs_page { s#list_head wb_list ; union { s#page * wb_page ; s#folio * wb_folio ; } ; s#nfs_lock_context * wb_lock_context ; unsigned long wb_index ; unsigned int wb_offset , wb_pgbase , wb_bytes ; s#kref wb_kref ; unsigned long wb_flags ; s#nfs_write_verifier wb_verf ; s#nfs_page * wb_this_page ; s#nfs_page * wb_head ; unsigned short wb_nio ; }
s#nfs_page@fe014214 struct nfs_page { UNKNOWN }
s#nfs_page_array struct nfs_page_array { s#page * * pagevec ; unsigned int npages ; s#page * page_array [ ( 8U ) ] ; }
s#nfs_pageio_descriptor struct nfs_pageio_descriptor { s#inode * pg_inode ; const s#nfs_pageio_ops * pg_ops ; const s#nfs_rw_ops * pg_rw_ops ; int pg_ioflags ; int pg_error ; const s#rpc_call_ops * pg_rpc_callops ; const s#nfs_pgio_completion_ops * pg_completion_ops ; s#pnfs_layout_segment * pg_lseg ; s#nfs_io_completion * pg_io_completion ; s#nfs_direct_req * pg_dreq ; void * pg_netfs ; unsigned int pg_bsize ; t#u32 pg_mirror_count ; s#nfs_pgio_mirror * pg_mirrors ; s#nfs_pgio_mirror pg_mirrors_static [ 1 ] ; s#nfs_pgio_mirror * pg_mirrors_dynamic ; t#u32 pg_mirror_idx ; unsigned short pg_maxretrans ; unsigned char pg_moreio : 1 ; }
s#nfs_pageio_ops struct nfs_pageio_ops { void ( * pg_init ) ( s#nfs_pageio_descriptor * , s#nfs_page * ) ; t#size_t ( * pg_test ) ( s#nfs_pageio_descriptor * , s#nfs_page * , s#nfs_page * ) ; int ( * pg_doio ) ( s#nfs_pageio_descriptor * ) ; unsigned int ( * pg_get_mirror_count ) ( s#nfs_pageio_descriptor * , s#nfs_page * ) ; void ( * pg_cleanup ) ( s#nfs_pageio_descriptor * ) ; s#nfs_pgio_mirror * ( * pg_get_mirror ) ( s#nfs_pageio_descriptor * , t#u32 ) ; t#u32 ( * pg_set_mirror ) ( s#nfs_pageio_descriptor * , t#u32 ) ; }
s#nfs_pathconf struct nfs_pathconf { s#nfs_fattr * fattr ; t#__u32 max_link ; t#__u32 max_namelen ; }
s#nfs_pgio_args struct nfs_pgio_args { s#nfs4_sequence_args seq_args ; s#nfs_fh * fh ; s#nfs_open_context * context ; s#nfs_lock_context * lock_context ; t#nfs4_stateid stateid ; t#__u64 offset ; t#__u32 count ; unsigned int pgbase ; s#page * * pages ; union { unsigned int replen ; struct { const t#u32 * bitmask ; t#u32 bitmask_store [ 3 ] ; e#nfs3_stable_how stable ; } ; } ; }
s#nfs_pgio_completion_ops struct nfs_pgio_completion_ops { void ( * error_cleanup ) ( s#list_head * , int ) ; void ( * init_hdr ) ( s#nfs_pgio_header * ) ; void ( * completion ) ( s#nfs_pgio_header * ) ; void ( * reschedule_io ) ( s#nfs_pgio_header * ) ; }
s#nfs_pgio_header struct nfs_pgio_header { s#inode * inode ; const s#cred * cred ; s#list_head pages ; s#nfs_page * req ; s#nfs_writeverf verf ; t#fmode_t rw_mode ; s#pnfs_layout_segment * lseg ; t#loff_t io_start ; const s#rpc_call_ops * mds_ops ; void ( * release ) ( s#nfs_pgio_header * ) ; const s#nfs_pgio_completion_ops * completion_ops ; const s#nfs_rw_ops * rw_ops ; s#nfs_io_completion * io_completion ; s#nfs_direct_req * dreq ; void * netfs ; int pnfs_error ; int error ; unsigned int good_bytes ; unsigned long flags ; s#rpc_task task ; s#nfs_fattr fattr ; s#nfs_pgio_args args ; s#nfs_pgio_res res ; unsigned long timestamp ; int ( * pgio_done_cb ) ( s#rpc_task * , s#nfs_pgio_header * ) ; t#__u64 mds_offset ; s#nfs_page_array page_array ; s#nfs_client * ds_clp ; t#u32 ds_commit_idx ; t#u32 pgio_mirror_idx ; }
s#nfs_pgio_mirror struct nfs_pgio_mirror { s#list_head pg_list ; unsigned long pg_bytes_written ; t#size_t pg_count ; t#size_t pg_bsize ; unsigned int pg_base ; unsigned char pg_recoalesce : 1 ; }
s#nfs_pgio_res struct nfs_pgio_res { s#nfs4_sequence_res seq_res ; s#nfs_fattr * fattr ; t#__u64 count ; t#__u32 op_status ; union { struct { unsigned int replen ; int eof ; void * scratch ; } ; struct { s#nfs_writeverf * verf ; const s#nfs_server * server ; } ; } ; }
s#nfs_readdir_arg struct nfs_readdir_arg { s#dentry * dentry ; const s#cred * cred ; t#__be32 * verf ; t#u64 cookie ; s#page * * pages ; unsigned int page_len ; t#bool plus ; }
s#nfs_readdir_res struct nfs_readdir_res { t#__be32 * verf ; }
s#nfs_removeargs struct nfs_removeargs { s#nfs4_sequence_args seq_args ; const s#nfs_fh * fh ; s#qstr name ; }
s#nfs_removeres struct nfs_removeres { s#nfs4_sequence_res seq_res ; s#nfs_server * server ; s#nfs_fattr * dir_attr ; s#nfs4_change_info cinfo ; }
s#nfs_renameargs struct nfs_renameargs { s#nfs4_sequence_args seq_args ; const s#nfs_fh * old_dir ; const s#nfs_fh * new_dir ; const s#qstr * old_name ; const s#qstr * new_name ; }
s#nfs_renamedata struct nfs_renamedata { s#nfs_renameargs args ; s#nfs_renameres res ; s#rpc_task task ; const s#cred * cred ; s#inode * old_dir ; s#dentry * old_dentry ; s#nfs_fattr old_fattr ; s#inode * new_dir ; s#dentry * new_dentry ; s#nfs_fattr new_fattr ; void ( * complete ) ( s#rpc_task * , s#nfs_renamedata * ) ; long timeout ; t#bool cancelled ; }
s#nfs_renameres struct nfs_renameres { s#nfs4_sequence_res seq_res ; s#nfs_server * server ; s#nfs4_change_info old_cinfo ; s#nfs_fattr * old_fattr ; s#nfs4_change_info new_cinfo ; s#nfs_fattr * new_fattr ; }
s#nfs_rpc_ops struct nfs_rpc_ops { t#u32 version ; const s#dentry_operations * dentry_ops ; const s#inode_operations * dir_inode_ops ; const s#inode_operations * file_inode_ops ; const s#file_operations * file_ops ; const s#nlmclnt_operations * nlmclnt_ops ; int ( * getroot ) ( s#nfs_server * , s#nfs_fh * , s#nfs_fsinfo * ) ; int ( * submount ) ( s#fs_context * , s#nfs_server * ) ; int ( * try_get_tree ) ( s#fs_context * ) ; int ( * getattr ) ( s#nfs_server * , s#nfs_fh * , s#nfs_fattr * , s#inode * ) ; int ( * setattr ) ( s#dentry * , s#nfs_fattr * , s#iattr * ) ; int ( * lookup ) ( s#inode * , s#dentry * , s#nfs_fh * , s#nfs_fattr * ) ; int ( * lookupp ) ( s#inode * , s#nfs_fh * , s#nfs_fattr * ) ; int ( * access ) ( s#inode * , s#nfs_access_entry * , const s#cred * ) ; int ( * readlink ) ( s#inode * , s#page * , unsigned int , unsigned int ) ; int ( * create ) ( s#inode * , s#dentry * , s#iattr * , int ) ; int ( * remove ) ( s#inode * , s#dentry * ) ; void ( * unlink_setup ) ( s#rpc_message * , s#dentry * , s#inode * ) ; void ( * unlink_rpc_prepare ) ( s#rpc_task * , s#nfs_unlinkdata * ) ; int ( * unlink_done ) ( s#rpc_task * , s#inode * ) ; void ( * rename_setup ) ( s#rpc_message * , s#dentry * , s#dentry * ) ; void ( * rename_rpc_prepare ) ( s#rpc_task * , s#nfs_renamedata * ) ; int ( * rename_done ) ( s#rpc_task * , s#inode * , s#inode * ) ; int ( * link ) ( s#inode * , s#inode * , const s#qstr * ) ; int ( * symlink ) ( s#inode * , s#dentry * , s#folio * , unsigned int , s#iattr * ) ; int ( * mkdir ) ( s#inode * , s#dentry * , s#iattr * ) ; int ( * rmdir ) ( s#inode * , const s#qstr * ) ; int ( * readdir ) ( s#nfs_readdir_arg * , s#nfs_readdir_res * ) ; int ( * mknod ) ( s#inode * , s#dentry * , s#iattr * , t#dev_t ) ; int ( * statfs ) ( s#nfs_server * , s#nfs_fh * , s#nfs_fsstat * ) ; int ( * fsinfo ) ( s#nfs_server * , s#nfs_fh * , s#nfs_fsinfo * ) ; int ( * pathconf ) ( s#nfs_server * , s#nfs_fh * , s#nfs_pathconf * ) ; int ( * set_capabilities ) ( s#nfs_server * , s#nfs_fh * ) ; int ( * decode_dirent ) ( s#xdr_stream * , s#nfs_entry * , t#bool ) ; int ( * pgio_rpc_prepare ) ( s#rpc_task * , s#nfs_pgio_header * ) ; void ( * read_setup ) ( s#nfs_pgio_header * , s#rpc_message * ) ; int ( * read_done ) ( s#rpc_task * , s#nfs_pgio_header * ) ; void ( * write_setup ) ( s#nfs_pgio_header * , s#rpc_message * , s#rpc_clnt * * ) ; int ( * write_done ) ( s#rpc_task * , s#nfs_pgio_header * ) ; void ( * commit_setup ) ( s#nfs_commit_data * , s#rpc_message * , s#rpc_clnt * * ) ; void ( * commit_rpc_prepare ) ( s#rpc_task * , s#nfs_commit_data * ) ; int ( * commit_done ) ( s#rpc_task * , s#nfs_commit_data * ) ; int ( * lock ) ( s#file * , int , s#file_lock * ) ; int ( * lock_check_bounds ) ( const s#file_lock * ) ; void ( * clear_acl_cache ) ( s#inode * ) ; void ( * close_context ) ( s#nfs_open_context * , int ) ; s#inode * ( * open_context ) ( s#inode * , s#nfs_open_context * , int , s#iattr * , int * ) ; int ( * have_delegation ) ( s#inode * , t#fmode_t , int ) ; int ( * return_delegation ) ( s#inode * ) ; s#nfs_client * ( * alloc_client ) ( const s#nfs_client_initdata * ) ; s#nfs_client * ( * init_client ) ( s#nfs_client * , const s#nfs_client_initdata * ) ; void ( * free_client ) ( s#nfs_client * ) ; s#nfs_server * ( * create_server ) ( s#fs_context * ) ; s#nfs_server * ( * clone_server ) ( s#nfs_server * , s#nfs_fh * , s#nfs_fattr * , t#rpc_authflavor_t ) ; int ( * discover_trunking ) ( s#nfs_server * , s#nfs_fh * ) ; void ( * enable_swap ) ( s#inode * ) ; void ( * disable_swap ) ( s#inode * ) ; }
s#nfs_rw_ops@5f4bfb9a struct nfs_rw_ops { s#nfs_pgio_header * ( * rw_alloc_header ) ( void ) ; void ( * rw_free_header ) ( s#nfs_pgio_header * ) ; int ( * rw_done ) ( s#rpc_task * , s#nfs_pgio_header * , s#inode * ) ; void ( * rw_result ) ( s#rpc_task * , s#nfs_pgio_header * ) ; void ( * rw_initiate ) ( s#nfs_pgio_header * , s#rpc_message * , const s#nfs_rpc_ops * , s#rpc_task_setup * , int ) ; }
s#nfs_rw_ops@bb8a17f7 struct nfs_rw_ops { UNKNOWN }
s#nfs_seqid struct nfs_seqid { s#nfs_seqid_counter * sequence ; s#list_head list ; s#rpc_task * task ; }
s#nfs_seqid_counter struct nfs_seqid_counter { t#ktime_t create_time ; t#u64 owner_id ; int flags ; t#u32 counter ; t#spinlock_t lock ; s#list_head list ; s#rpc_wait_queue wait ; }
s#nfs_server struct nfs_server { s#nfs_client * nfs_client ; s#list_head client_link ; s#list_head master_link ; s#rpc_clnt * client ; s#rpc_clnt * client_acl ; s#nlm_host * nlm_host ; s#nfs_iostats * io_stats ; t#wait_queue_head_t write_congestion_wait ; t#atomic_long_t writeback ; unsigned int write_congested ; unsigned int flags ; unsigned int fattr_valid ; unsigned int caps ; unsigned int rsize ; unsigned int rpages ; unsigned int wsize ; unsigned int wpages ; unsigned int wtmult ; unsigned int dtsize ; unsigned short port ; unsigned int bsize ; unsigned int gxasize ; unsigned int sxasize ; unsigned int lxasize ; unsigned int acregmin ; unsigned int acregmax ; unsigned int acdirmin ; unsigned int acdirmax ; unsigned int namelen ; unsigned int options ; unsigned int clone_blksize ; e#nfs4_change_attr_type change_attr_type ; s#nfs_fsid fsid ; int s_sysfs_id ; t#__u64 maxfilesize ; s#timespec64 time_delta ; unsigned long mount_time ; s#super_block * super ; t#dev_t s_dev ; s#nfs_auth_info auth_info ; s#fscache_volume * fscache ; char * fscache_uniq ; t#u32 pnfs_blksize ; t#u32 attr_bitmask [ 3 ] ; t#u32 attr_bitmask_nl [ 3 ] ; t#u32 exclcreat_bitmask [ 3 ] ; t#u32 cache_consistency_bitmask [ 3 ] ; t#u32 acl_bitmask ; t#u32 fh_expire_type ; s#pnfs_layoutdriver_type * pnfs_curr_ld ; s#rpc_wait_queue roc_rpcwaitq ; void * pnfs_ld_data ; s#rb_root state_owners ; t#atomic64_t owner_ctr ; s#list_head state_owners_lru ; s#list_head layouts ; s#list_head delegations ; s#list_head ss_copies ; s#list_head ss_src_copies ; unsigned long delegation_gen ; unsigned long mig_gen ; unsigned long mig_status ; void ( * destroy ) ( s#nfs_server * ) ; t#atomic_t active ; s#__kernel_sockaddr_storage mountd_address ; t#size_t mountd_addrlen ; t#u32 mountd_version ; unsigned short mountd_port ; unsigned short mountd_protocol ; s#rpc_wait_queue uoc_rpcwaitq ; unsigned int read_hdrsize ; const s#cred * cred ; t#bool has_sec_mnt_opts ; s#kobject kobj ; s#callback_head rcu ; }
s#nfs_subversion@1e91c4b9 struct nfs_subversion { UNKNOWN }
s#nfs_subversion@fe4a0774 struct nfs_subversion { s#module * owner ; s#file_system_type * nfs_fs ; const s#rpc_version * rpc_vers ; const s#nfs_rpc_ops * rpc_ops ; const s#super_operations * sops ; const s#xattr_handler * const * xattr ; s#list_head list ; }
s#nfs_unlinkdata struct nfs_unlinkdata { s#nfs_removeargs args ; s#nfs_removeres res ; s#dentry * dentry ; t#wait_queue_head_t wq ; const s#cred * cred ; s#nfs_fattr dir_attr ; long timeout ; }
s#nfs_write_verifier struct nfs_write_verifier { char data [ 8 ] ; }
s#nfs_writeverf struct nfs_writeverf { s#nfs_write_verifier verifier ; e#nfs3_stable_how committed ; }
s#nfstime4 struct nfstime4 { t#u64 seconds ; t#u32 nseconds ; }
s#nh_group struct nh_group { s#nh_group * spare ; t#u16 num_nh ; t#bool is_multipath ; t#bool hash_threshold ; t#bool resilient ; t#bool fdb_nh ; t#bool has_v4 ; t#bool hw_stats ; s#nh_res_table * res_table ; s#nh_grp_entry nh_entries [ ] ; }
s#nh_grp_entry struct nh_grp_entry { s#nexthop * nh ; s#nh_grp_entry_stats * stats ; t#u16 weight ; union { struct { t#atomic_t upper_bound ; } hthr ; struct { s#list_head uw_nh_entry ; t#u16 count_buckets ; t#u16 wants_buckets ; } res ; } ; s#list_head nh_list ; s#nexthop * nh_parent ; t#u64 packets_hw ; }
s#nh_grp_entry_stats struct nh_grp_entry_stats { t#u64_stats_t packets ; s#u64_stats_sync syncp ; }
s#nh_info struct nh_info { s#hlist_node dev_hash ; s#nexthop * nh_parent ; t#u8 family ; t#bool reject_nh ; t#bool fdb_nh ; union { s#fib_nh_common fib_nhc ; s#fib_nh fib_nh ; s#fib6_nh fib6_nh ; } ; }
s#nh_res_bucket struct nh_res_bucket { s#nh_grp_entry * nh_entry ; t#atomic_long_t used_time ; unsigned long migrated_time ; t#bool occupied ; t#u8 nh_flags ; }
s#nh_res_table struct nh_res_table { s#net * net ; t#u32 nhg_id ; s#delayed_work upkeep_dw ; s#list_head uw_nh_entries ; unsigned long unbalanced_since ; t#u32 idle_timer ; t#u32 unbalanced_timer ; t#u16 num_nh_buckets ; s#nh_res_bucket nh_buckets [ ] ; }
s#nl80211_vendor_cmd_info struct nl80211_vendor_cmd_info { t#__u32 vendor_id ; t#__u32 subcmd ; }
s#nl80211_wowlan_tcp_data_seq struct nl80211_wowlan_tcp_data_seq { t#__u32 start , offset , len ; }
s#nl80211_wowlan_tcp_data_token struct nl80211_wowlan_tcp_data_token { t#__u32 offset , len ; t#__u8 token_stream [ ] ; }
s#nl80211_wowlan_tcp_data_token_feature struct nl80211_wowlan_tcp_data_token_feature { t#__u32 min_len , max_len , bufsize ; }
s#nla_policy@a743e2ce struct nla_policy { t#u8 type ; t#u8 validation_type ; t#u16 len ; union { t#u16 strict_start_type ; const t#u32 bitfield32_valid ; const t#u32 mask ; const char * reject_message ; const s#nla_policy * nested_policy ; const s#netlink_range_validation * range ; const s#netlink_range_validation_signed * range_signed ; struct { t#s16 min , max ; } ; int ( * validate ) ( const s#nlattr * , s#netlink_ext_ack * ) ; } ; }
s#nla_policy@f0766bba struct nla_policy { UNKNOWN }
s#nlattr struct nlattr { t#__u16 nla_len ; t#__u16 nla_type ; }
s#nlm_host@848b5b81 struct nlm_host { s#hlist_node h_hash ; s#__kernel_sockaddr_storage h_addr ; t#size_t h_addrlen ; s#__kernel_sockaddr_storage h_srcaddr ; t#size_t h_srcaddrlen ; s#rpc_clnt * h_rpcclnt ; char * h_name ; t#u32 h_version ; unsigned short h_proto ; unsigned short h_reclaiming : 1 , h_server : 1 , h_noresvport : 1 , h_inuse : 1 ; t#wait_queue_head_t h_gracewait ; s#rw_semaphore h_rwsem ; t#u32 h_state ; t#u32 h_nsmstate ; t#u32 h_pidcount ; t#refcount_t h_count ; s#mutex h_mutex ; unsigned long h_nextrebind ; unsigned long h_expires ; s#list_head h_lockowners ; t#spinlock_t h_lock ; s#list_head h_granted ; s#list_head h_reclaim ; s#nsm_handle * h_nsmhandle ; char * h_addrbuf ; s#net * net ; const s#cred * h_cred ; char nodename [ 64 + 1 ] ; const s#nlmclnt_operations * h_nlmclnt_ops ; }
s#nlm_host@9e00109f struct nlm_host { UNKNOWN }
s#nlm_lockowner@9807fff5 struct nlm_lockowner { s#list_head list ; t#refcount_t count ; s#nlm_host * host ; t#fl_owner_t owner ; t#uint32_t pid ; }
s#nlm_lockowner@c8646510 struct nlm_lockowner { UNKNOWN }
s#nlmclnt_operations@40af5e15 struct nlmclnt_operations { UNKNOWN }
s#nlmclnt_operations@5eda35fa struct nlmclnt_operations { void ( * nlmclnt_alloc_call ) ( void * ) ; t#bool ( * nlmclnt_unlock_prepare ) ( s#rpc_task * , void * ) ; void ( * nlmclnt_release_call ) ( void * ) ; }
s#nlmsghdr struct nlmsghdr { t#__u32 nlmsg_len ; t#__u16 nlmsg_type ; t#__u16 nlmsg_flags ; t#__u32 nlmsg_seq ; t#__u32 nlmsg_pid ; }
s#notifier_block struct notifier_block { t#notifier_fn_t notifier_call ; s#notifier_block * next ; int priority ; }
s#ns_common struct ns_common { s#dentry * stashed ; const s#proc_ns_operations * ops ; unsigned int inum ; t#refcount_t count ; }
s#nsm_handle struct nsm_handle { s#list_head sm_link ; t#refcount_t sm_count ; char * sm_mon_name ; char * sm_name ; s#__kernel_sockaddr_storage sm_addr ; t#size_t sm_addrlen ; unsigned int sm_monitored : 1 , sm_sticky : 1 ; s#nsm_private sm_priv ; char sm_addrbuf [ ( ( 8 * 4 + 7 ) + ( 1 + 10 ) + 1 ) ] ; }
s#nsm_private struct nsm_private { unsigned char data [ 16 ] ; }
s#nsproxy@170c24b3 struct nsproxy { UNKNOWN }
s#nsproxy@9767106e struct nsproxy { t#refcount_t count ; s#uts_namespace * uts_ns ; s#ipc_namespace * ipc_ns ; s#mnt_namespace * mnt_ns ; s#pid_namespace * pid_ns_for_children ; s#net * net_ns ; s#time_namespace * time_ns ; s#time_namespace * time_ns_for_children ; s#cgroup_namespace * cgroup_ns ; }
s#nsset struct nsset { unsigned flags ; s#nsproxy * nsproxy ; s#fs_struct * fs ; const s#cred * cred ; }
s#numa_group struct numa_group { UNKNOWN }
s#nvme_fc_local_port struct nvme_fc_local_port { t#u32 port_num ; t#u32 port_role ; t#u64 node_name ; t#u64 port_name ; void * private ; t#u32 port_id ; e#nvme_fc_obj_state port_state ; }
s#nvme_fc_port_info struct nvme_fc_port_info { t#u64 node_name ; t#u64 port_name ; t#u32 port_role ; t#u32 port_id ; t#u32 dev_loss_tmo ; }
s#nvme_fc_port_template struct nvme_fc_port_template { void ( * localport_delete ) ( s#nvme_fc_local_port * ) ; void ( * remoteport_delete ) ( s#nvme_fc_remote_port * ) ; int ( * create_queue ) ( s#nvme_fc_local_port * , unsigned int , t#u16 , void * * ) ; void ( * delete_queue ) ( s#nvme_fc_local_port * , unsigned int , void * ) ; int ( * ls_req ) ( s#nvme_fc_local_port * , s#nvme_fc_remote_port * , s#nvmefc_ls_req * ) ; int ( * fcp_io ) ( s#nvme_fc_local_port * , s#nvme_fc_remote_port * , void * , s#nvmefc_fcp_req * ) ; void ( * ls_abort ) ( s#nvme_fc_local_port * , s#nvme_fc_remote_port * , s#nvmefc_ls_req * ) ; void ( * fcp_abort ) ( s#nvme_fc_local_port * , s#nvme_fc_remote_port * , void * , s#nvmefc_fcp_req * ) ; int ( * xmt_ls_rsp ) ( s#nvme_fc_local_port * , s#nvme_fc_remote_port * , s#nvmefc_ls_rsp * ) ; void ( * map_queues ) ( s#nvme_fc_local_port * , s#blk_mq_queue_map * ) ; t#u32 max_hw_queues ; t#u16 max_sgl_segments ; t#u16 max_dif_sgl_segments ; t#u64 dma_boundary ; t#u32 local_priv_sz ; t#u32 remote_priv_sz ; t#u32 lsrqst_priv_sz ; t#u32 fcprqst_priv_sz ; }
s#nvme_fc_remote_port struct nvme_fc_remote_port { t#u32 port_num ; t#u32 port_role ; t#u64 node_name ; t#u64 port_name ; s#nvme_fc_local_port * localport ; void * private ; t#u32 dev_loss_tmo ; t#u32 port_id ; e#nvme_fc_obj_state port_state ; }
s#nvmefc_fcp_req struct nvmefc_fcp_req { void * cmdaddr ; void * rspaddr ; t#dma_addr_t cmddma ; t#dma_addr_t rspdma ; t#u16 cmdlen ; t#u16 rsplen ; t#u32 payload_length ; s#sg_table sg_table ; s#scatterlist * first_sgl ; int sg_cnt ; e#nvmefc_fcp_datadir io_dir ; void ( * done ) ( s#nvmefc_fcp_req * ) ; void * private ; t#__le16 sqid ; t#u16 rcv_rsplen ; t#u32 transferred_length ; t#u32 status ; }
s#nvmefc_ls_req struct nvmefc_ls_req { void * rqstaddr ; t#dma_addr_t rqstdma ; t#u32 rqstlen ; void * rspaddr ; t#dma_addr_t rspdma ; t#u32 rsplen ; t#u32 timeout ; void * private ; void ( * done ) ( s#nvmefc_ls_req * , int ) ; }
s#nvmefc_ls_rsp struct nvmefc_ls_rsp { void * rspbuf ; t#dma_addr_t rspdma ; t#u16 rsplen ; void ( * done ) ( s#nvmefc_ls_rsp * ) ; void * nvme_fc_private ; }
s#nvmem_cell_info struct nvmem_cell_info { const char * name ; unsigned int offset ; t#size_t raw_len ; unsigned int bytes ; unsigned int bit_offset ; unsigned int nbits ; s#device_node * np ; t#nvmem_cell_post_process_t read_post_process ; void * priv ; }
s#nvmem_device@20b8409f struct nvmem_device { s#module * owner ; s#device dev ; s#list_head node ; int stride ; int word_size ; int id ; s#kref refcnt ; t#size_t size ; t#bool read_only ; t#bool root_only ; int flags ; e#nvmem_type type ; s#bin_attribute eeprom ; s#device * base_dev ; s#list_head cells ; void ( * fixup_dt_cell_info ) ( s#nvmem_device * , s#nvmem_cell_info * ) ; const s#nvmem_keepout * keepout ; unsigned int nkeepout ; t#nvmem_reg_read_t reg_read ; t#nvmem_reg_write_t reg_write ; s#gpio_desc * wp_gpio ; s#nvmem_layout * layout ; void * priv ; t#bool sysfs_cells_populated ; }
s#nvmem_device@b783d954 struct nvmem_device { UNKNOWN }
s#nvmem_keepout struct nvmem_keepout { unsigned int start ; unsigned int end ; unsigned char value ; }
s#nvmem_layout struct nvmem_layout { s#device dev ; s#nvmem_device * nvmem ; int ( * add_cells ) ( s#nvmem_layout * ) ; }
s#obj_cgroup@3ce04acd struct obj_cgroup { UNKNOWN }
s#obj_cgroup@a1dd039f struct obj_cgroup { s#percpu_ref refcnt ; s#mem_cgroup * memcg ; t#atomic_t nr_charged_bytes ; union { s#list_head list ; s#callback_head rcu ; } ; }
s#of_device_id@8080a399 struct of_device_id { char name [ 32 ] ; char type [ 32 ] ; char compatible [ 128 ] ; const void * data ; }
s#of_device_id@fae262dc struct of_device_id { UNKNOWN }
s#of_phandle_args struct of_phandle_args { s#device_node * np ; int args_count ; t#uint32_t args [ 16 ] ; }
s#offset_ctx struct offset_ctx { s#maple_tree mt ; unsigned long next_offset ; }
s#old_timespec32@90d4ac33 struct old_timespec32 { t#old_time32_t tv_sec ; t#s32 tv_nsec ; }
s#old_timespec32@a92e0272 struct old_timespec32 { UNKNOWN }
s#opa_ah_attr struct opa_ah_attr { t#u32 dlid ; t#u8 src_path_bits ; t#bool make_grd ; }
s#open_how struct open_how { t#__u64 flags ; t#__u64 mode ; t#__u64 resolve ; }
s#optimistic_spin_queue struct optimistic_spin_queue { t#atomic_t tail ; }
s#orc_entry struct orc_entry { t#s16 sp_offset ; t#s16 bp_offset ; unsigned sp_reg : 4 ; unsigned bp_reg : 4 ; unsigned type : 3 ; unsigned signal : 1 ; }
s#otp_info struct otp_info { t#__u32 start ; t#__u32 length ; t#__u32 locked ; }
s#p_log struct p_log { const char * prefix ; s#fc_log * log ; }
s#pacct_struct struct pacct_struct { int ac_flag ; long ac_exitcode ; unsigned long ac_mem ; t#u64 ac_utime , ac_stime ; unsigned long ac_minflt , ac_majflt ; }
s#packet_command struct packet_command { unsigned char cmd [ 12 ] ; unsigned char * buffer ; unsigned int buflen ; int stat ; s#scsi_sense_hdr * sshdr ; unsigned char data_direction ; int quiet ; int timeout ; void * reserved [ 1 ] ; }
s#packet_type struct packet_type { t#__be16 type ; t#bool ignore_outgoing ; s#net_device * dev ; t#netdevice_tracker dev_tracker ; int ( * func ) ( s#sk_buff * , s#net_device * , s#packet_type * , s#net_device * ) ; void ( * list_func ) ( s#list_head * , s#packet_type * , s#net_device * ) ; t#bool ( * id_match ) ( s#packet_type * , s#sock * ) ; s#net * af_packet_net ; void * af_packet_priv ; s#list_head list ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#page@13c88c0d struct page { UNKNOWN }
s#page@d8865f34 struct page { unsigned long flags ; union { struct { union { s#list_head lru ; struct { void * __filler ; unsigned int mlock_count ; } ; s#list_head buddy_list ; s#list_head pcp_list ; } ; s#address_space * mapping ; union { unsigned long index ; unsigned long share ; } ; unsigned long private ; } ; struct { unsigned long pp_magic ; s#page_pool * pp ; unsigned long _pp_mapping_pad ; unsigned long dma_addr ; t#atomic_long_t pp_ref_count ; } ; struct { unsigned long compound_head ; } ; struct { s#dev_pagemap * pgmap ; void * zone_device_data ; } ; s#callback_head callback_head ; } ; union { unsigned int page_type ; t#atomic_t _mapcount ; } ; t#atomic_t _refcount ; unsigned long memcg_data ; }
s#page_counter struct page_counter { t#atomic_long_t usage ; s#cacheline_padding _pad1_ ; unsigned long emin ; t#atomic_long_t min_usage ; t#atomic_long_t children_min_usage ; unsigned long elow ; t#atomic_long_t low_usage ; t#atomic_long_t children_low_usage ; unsigned long watermark ; unsigned long local_watermark ; unsigned long failcnt ; s#cacheline_padding _pad2_ ; t#bool protection_support ; unsigned long min ; unsigned long low ; unsigned long high ; unsigned long max ; s#page_counter * parent ; }
s#page_frag struct page_frag { s#page * page ; t#__u32 offset ; t#__u32 size ; }
s#page_pool@2edb243b struct page_pool { UNKNOWN }
s#page_pool@9f618e01 struct page_pool { s#page_pool_params_fast p ; int cpuid ; t#u32 pages_state_hold_cnt ; t#bool has_init_callback : 1 ; t#bool dma_map : 1 ; t#bool dma_sync : 1 ; t#__u8 __cacheline_group_begin__frag [ 0 ] __attribute__ ( ( __aligned__ ( ( ( 4 * sizeof ( long ) ) + 0 ) ? : ( 1 << ( 6 ) ) ) ) ) ; long frag_users ; t#netmem_ref frag_page ; unsigned int frag_offset ; t#__u8 __cacheline_group_end__frag [ 0 ] __attribute__ ( ( __aligned__ ( sizeof ( long ) ) ) ) ; struct { } __cacheline_group_pad__frag __attribute__ ( ( __aligned__ ( ( ( 4 * sizeof ( long ) ) + 0 ) ? : ( 1 << ( 6 ) ) ) ) ) ; s#delayed_work release_dw ; void ( * disconnect ) ( void * ) ; unsigned long defer_start ; unsigned long defer_warn ; t#u32 xdp_mem_id ; s#pp_alloc_cache alloc __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; s#ptr_ring ring ; void * mp_priv ; t#atomic_t pages_state_release_cnt ; t#refcount_t user_cnt ; t#u64 destroy_cnt ; s#page_pool_params_slow slow ; struct { s#hlist_node list ; t#u64 detach_time ; t#u32 napi_id ; t#u32 id ; } user ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#page_pool_params_fast struct page_pool_params_fast { unsigned int order ; unsigned int pool_size ; int nid ; s#device * dev ; s#napi_struct * napi ; e#dma_data_direction dma_dir ; unsigned int max_len ; unsigned int offset ; }
s#page_pool_params_slow struct page_pool_params_slow { s#net_device * netdev ; unsigned int queue_idx ; unsigned int flags ; void ( * init_callback ) ( t#netmem_ref , void * ) ; void * init_arg ; }
s#paravirt_callee_save struct paravirt_callee_save { void * func ; }
s#paravirt_patch_template struct paravirt_patch_template { s#pv_cpu_ops cpu ; s#pv_irq_ops irq ; s#pv_mmu_ops mmu ; s#pv_lock_ops lock ; }
s#partition_meta_info@781d7eb3 struct partition_meta_info { UNKNOWN }
s#partition_meta_info@7f1b6f92 struct partition_meta_info { char uuid [ ( 36 + 1 ) ] ; t#u8 volname [ 64 ] ; }
s#path struct path { s#vfsmount * mnt ; s#dentry * dentry ; }
s#pci_bus struct pci_bus { s#list_head node ; s#pci_bus * parent ; s#list_head children ; s#list_head devices ; s#pci_dev * self ; s#list_head slots ; s#resource * resource [ 4 ] ; s#list_head resources ; s#resource busn_res ; s#pci_ops * ops ; void * sysdata ; s#proc_dir_entry * procdir ; unsigned char number ; unsigned char primary ; unsigned char max_bus_speed ; unsigned char cur_bus_speed ; char name [ 48 ] ; unsigned short bridge_ctl ; t#pci_bus_flags_t bus_flags ; s#device * bridge ; s#device dev ; s#bin_attribute * legacy_io ; s#bin_attribute * legacy_mem ; unsigned int is_added : 1 ; unsigned int unsafe_warn : 1 ; unsigned long uek_reserved1 ; }
s#pci_dev@058da080 struct pci_dev { UNKNOWN }
s#pci_dev@0a024d59 struct pci_dev { s#list_head bus_list ; s#pci_bus * bus ; s#pci_bus * subordinate ; void * sysdata ; s#proc_dir_entry * procent ; s#pci_slot * slot ; unsigned int devfn ; unsigned short vendor ; unsigned short device ; unsigned short subsystem_vendor ; unsigned short subsystem_device ; unsigned int class ; t#u8 revision ; t#u8 hdr_type ; t#u16 aer_cap ; s#aer_stats * aer_stats ; s#rcec_ea * rcec_ea ; s#pci_dev * rcec ; t#u32 devcap ; t#u8 pcie_cap ; t#u8 msi_cap ; t#u8 msix_cap ; t#u8 pcie_mpss : 3 ; t#u8 shared_pcc_and_link_slot : 1 ; t#u8 rom_base_reg ; t#u8 pin ; t#u16 pcie_flags_reg ; unsigned long * dma_alias_mask ; s#pci_driver * driver ; t#u64 dma_mask ; s#device_dma_parameters dma_parms ; t#pci_power_t current_state ; t#u8 pm_cap ; unsigned int pme_support : 5 ; unsigned int pme_poll : 1 ; unsigned int pinned : 1 ; unsigned int config_rrs_sv : 1 ; unsigned int imm_ready : 1 ; unsigned int d1_support : 1 ; unsigned int d2_support : 1 ; unsigned int no_d1d2 : 1 ; unsigned int no_d3cold : 1 ; unsigned int bridge_d3 : 1 ; unsigned int d3cold_allowed : 1 ; unsigned int mmio_always_on : 1 ; unsigned int wakeup_prepared : 1 ; unsigned int skip_bus_pm : 1 ; unsigned int ignore_hotplug : 1 ; unsigned int hotplug_user_indicators : 1 ; unsigned int clear_retrain_link : 1 ; unsigned int d3hot_delay ; unsigned int d3cold_delay ; t#u16 l1ss ; s#pcie_link_state * link_state ; unsigned int ltr_path : 1 ; unsigned int pasid_no_tlp : 1 ; unsigned int eetlp_prefix_path : 1 ; t#pci_channel_state_t error_state ; s#device dev ; int cfg_size ; unsigned int irq ; s#resource resource [ E#DEVICE_COUNT_RESOURCE ] ; s#resource driver_exclusive_resource ; t#bool match_driver ; unsigned int transparent : 1 ; unsigned int io_window : 1 ; unsigned int pref_window : 1 ; unsigned int pref_64_window : 1 ; unsigned int multifunction : 1 ; unsigned int is_busmaster : 1 ; unsigned int no_msi : 1 ; unsigned int no_64bit_msi : 1 ; unsigned int block_cfg_access : 1 ; unsigned int broken_parity_status : 1 ; unsigned int irq_reroute_variant : 2 ; unsigned int msi_enabled : 1 ; unsigned int msix_enabled : 1 ; unsigned int ari_enabled : 1 ; unsigned int ats_enabled : 1 ; unsigned int pasid_enabled : 1 ; unsigned int pri_enabled : 1 ; unsigned int is_managed : 1 ; unsigned int is_msi_managed : 1 ; unsigned int needs_freset : 1 ; unsigned int state_saved : 1 ; unsigned int is_physfn : 1 ; unsigned int is_virtfn : 1 ; unsigned int is_hotplug_bridge : 1 ; unsigned int shpc_managed : 1 ; unsigned int is_thunderbolt : 1 ; unsigned int untrusted : 1 ; unsigned int external_facing : 1 ; unsigned int broken_intx_masking : 1 ; unsigned int io_window_1k : 1 ; unsigned int irq_managed : 1 ; unsigned int non_compliant_bars : 1 ; unsigned int is_probed : 1 ; unsigned int link_active_reporting : 1 ; unsigned int no_vf_scan : 1 ; unsigned int no_command_memory : 1 ; unsigned int rom_bar_overlap : 1 ; unsigned int rom_attr_enabled : 1 ; t#pci_dev_flags_t dev_flags ; t#atomic_t enable_cnt ; t#spinlock_t pcie_cap_lock ; t#u32 saved_config_space [ 16 ] ; s#hlist_head saved_cap_space ; s#bin_attribute * res_attr [ E#DEVICE_COUNT_RESOURCE ] ; s#bin_attribute * res_attr_wc [ E#DEVICE_COUNT_RESOURCE ] ; unsigned int broken_cmd_compl : 1 ; void * msix_base ; t#raw_spinlock_t msi_lock ; s#pci_vpd vpd ; t#u16 dpc_cap ; unsigned int dpc_rp_extensions : 1 ; t#u8 dpc_rp_log_size ; union { s#pci_sriov * sriov ; s#pci_dev * physfn ; } ; t#u16 ats_cap ; t#u8 ats_stu ; t#u16 pri_cap ; t#u32 pri_reqs_alloc ; unsigned int pasid_required : 1 ; t#u16 pasid_cap ; t#u16 pasid_features ; s#xarray doe_mbs ; t#u16 acs_cap ; t#phys_addr_t rom ; t#size_t romlen ; const char * driver_override ; unsigned long priv_flags ; t#u8 reset_methods [ 8 ] ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; }
s#pci_device_id struct pci_device_id { t#__u32 vendor , device ; t#__u32 subvendor , subdevice ; t#__u32 class , class_mask ; t#kernel_ulong_t driver_data ; t#__u32 override_only ; }
s#pci_driver struct pci_driver { const char * name ; const s#pci_device_id * id_table ; int ( * probe ) ( s#pci_dev * , const s#pci_device_id * ) ; void ( * remove ) ( s#pci_dev * ) ; int ( * suspend ) ( s#pci_dev * , t#pm_message_t ) ; int ( * resume ) ( s#pci_dev * ) ; void ( * shutdown ) ( s#pci_dev * ) ; int ( * sriov_configure ) ( s#pci_dev * , int ) ; int ( * sriov_set_msix_vec_count ) ( s#pci_dev * , int ) ; t#u32 ( * sriov_get_vf_total_msix ) ( s#pci_dev * ) ; const s#pci_error_handlers * err_handler ; const s#attribute_group * * groups ; const s#attribute_group * * dev_groups ; s#device_driver driver ; s#pci_dynids dynids ; t#bool driver_managed_dma ; }
s#pci_dynids struct pci_dynids { t#spinlock_t lock ; s#list_head list ; }
s#pci_error_handlers struct pci_error_handlers { t#pci_ers_result_t ( * error_detected ) ( s#pci_dev * , t#pci_channel_state_t ) ; t#pci_ers_result_t ( * mmio_enabled ) ( s#pci_dev * ) ; t#pci_ers_result_t ( * slot_reset ) ( s#pci_dev * ) ; void ( * reset_prepare ) ( s#pci_dev * ) ; void ( * reset_done ) ( s#pci_dev * ) ; void ( * resume ) ( s#pci_dev * ) ; void ( * cor_error_detected ) ( s#pci_dev * ) ; }
s#pci_msi_desc struct pci_msi_desc { union { t#u32 msi_mask ; t#u32 msix_ctrl ; } ; struct { t#u8 is_msix : 1 ; t#u8 multiple : 3 ; t#u8 multi_cap : 3 ; t#u8 can_mask : 1 ; t#u8 is_64 : 1 ; t#u8 is_virtual : 1 ; unsigned default_irq ; } msi_attrib ; union { t#u8 mask_pos ; void * mask_base ; } ; }
s#pci_ops struct pci_ops { int ( * add_bus ) ( s#pci_bus * ) ; void ( * remove_bus ) ( s#pci_bus * ) ; void * ( * map_bus ) ( s#pci_bus * , unsigned int , int ) ; int ( * read ) ( s#pci_bus * , unsigned int , int , int , t#u32 * ) ; int ( * write ) ( s#pci_bus * , unsigned int , int , int , t#u32 ) ; }
s#pci_slot struct pci_slot { s#pci_bus * bus ; s#list_head list ; s#hotplug_slot * hotplug ; unsigned char number ; s#kobject kobj ; }
s#pci_sriov@8a12dbad struct pci_sriov { int pos ; int nres ; t#u32 cap ; t#u16 ctrl ; t#u16 total_VFs ; t#u16 initial_VFs ; t#u16 num_VFs ; t#u16 offset ; t#u16 stride ; t#u16 vf_device ; t#u32 pgsz ; t#u8 link ; t#u8 max_VF_buses ; t#u16 driver_max_VFs ; s#pci_dev * dev ; s#pci_dev * self ; t#u32 class ; t#u8 hdr_type ; t#u16 subsystem_vendor ; t#u16 subsystem_device ; t#resource_size_t barsz [ 6 ] ; t#bool drivers_autoprobe ; }
s#pci_sriov@8eb10e41 struct pci_sriov { UNKNOWN }
s#pci_vpd struct pci_vpd { s#mutex lock ; unsigned int len ; t#u8 cap ; }
s#pcie_link_state struct pcie_link_state { UNKNOWN }
s#pcpu_dstats struct pcpu_dstats { t#u64_stats_t rx_packets ; t#u64_stats_t rx_bytes ; t#u64_stats_t rx_drops ; t#u64_stats_t tx_packets ; t#u64_stats_t tx_bytes ; t#u64_stats_t tx_drops ; s#u64_stats_sync syncp ; }
s#pcpu_hot struct pcpu_hot { union { struct { s#task_struct * current_task ; int preempt_count ; int cpu_number ; t#u64 call_depth ; unsigned long top_of_stack ; void * hardirq_stack_ptr ; t#u16 softirq_pending ; t#bool hardirq_stack_inuse ; } ; t#u8 pad [ 64 ] ; } ; }
s#pcpu_lstats struct pcpu_lstats { t#u64_stats_t packets ; t#u64_stats_t bytes ; s#u64_stats_sync syncp ; }
s#pcpu_rx_sc_stats struct pcpu_rx_sc_stats { s#macsec_rx_sc_stats stats ; s#u64_stats_sync syncp ; }
s#pcpu_sw_netstats struct pcpu_sw_netstats { t#u64_stats_t rx_packets ; t#u64_stats_t rx_bytes ; t#u64_stats_t tx_packets ; t#u64_stats_t tx_bytes ; s#u64_stats_sync syncp ; }
s#pcpu_tx_sc_stats struct pcpu_tx_sc_stats { s#macsec_tx_sc_stats stats ; s#u64_stats_sync syncp ; }
s#per_cpu_nodestat struct per_cpu_nodestat { t#s8 stat_threshold ; t#s8 vm_node_stat_diff [ E#NR_VM_NODE_STAT_ITEMS ] ; }
s#per_cpu_pages struct per_cpu_pages { t#spinlock_t lock ; int count ; int high ; int high_min ; int high_max ; int batch ; t#u8 flags ; t#u8 alloc_factor ; t#u8 expire ; short free_count ; s#list_head lists [ ( ( E#MIGRATE_PCPTYPES * ( 3 + 1 ) ) + 2 ) ] ; }
s#per_cpu_zonestat struct per_cpu_zonestat { t#s8 vm_stat_diff [ E#NR_VM_ZONE_STAT_ITEMS ] ; t#s8 stat_threshold ; unsigned long vm_numa_event [ E#NR_VM_NUMA_EVENT_ITEMS ] ; }
s#percpu_cluster struct percpu_cluster { unsigned int next [ ( ( 21 - 12 ) + 1 ) ] ; }
s#percpu_counter struct percpu_counter { t#raw_spinlock_t lock ; t#s64 count ; s#list_head list ; t#s32 * counters ; }
s#percpu_ref struct percpu_ref { unsigned long percpu_count_ptr ; s#percpu_ref_data * data ; }
s#percpu_ref_data struct percpu_ref_data { t#atomic_long_t count ; t#percpu_ref_func_t * release ; t#percpu_ref_func_t * confirm_switch ; t#bool force_atomic : 1 ; t#bool allow_reinit : 1 ; s#callback_head rcu ; s#percpu_ref * ref ; }
s#percpu_rw_semaphore struct percpu_rw_semaphore { s#rcu_sync rss ; unsigned int * read_count ; s#rcuwait writer ; t#wait_queue_head_t waiters ; t#atomic_t block ; }
s#perf_addr_filter_range struct perf_addr_filter_range { unsigned long start ; unsigned long size ; }
s#perf_addr_filters_head struct perf_addr_filters_head { s#list_head list ; t#raw_spinlock_t lock ; unsigned int nr_file_filters ; }
s#perf_branch_entry struct perf_branch_entry { t#__u64 from ; t#__u64 to ; t#__u64 mispred : 1 , predicted : 1 , in_tx : 1 , abort : 1 , cycles : 16 , type : 4 , spec : 2 , new_type : 4 , priv : 3 , reserved : 31 ; }
s#perf_branch_stack struct perf_branch_stack { t#__u64 nr ; t#__u64 hw_idx ; s#perf_branch_entry entries [ ] ; }
s#perf_buffer@e1f27d85 struct perf_buffer { t#refcount_t refcount ; s#callback_head callback_head ; int nr_pages ; int overwrite ; int paused ; t#atomic_t poll ; t#local_t head ; unsigned int nest ; t#local_t events ; t#local_t wakeup ; t#local_t lost ; long watermark ; long aux_watermark ; t#spinlock_t event_lock ; s#list_head event_list ; t#atomic_t mmap_count ; unsigned long mmap_locked ; s#user_struct * mmap_user ; s#mutex aux_mutex ; long aux_head ; unsigned int aux_nest ; long aux_wakeup ; unsigned long aux_pgoff ; int aux_nr_pages ; int aux_overwrite ; t#atomic_t aux_mmap_count ; unsigned long aux_mmap_locked ; void ( * free_aux ) ( void * ) ; t#refcount_t aux_refcount ; int aux_in_sampling ; void * * aux_pages ; void * aux_priv ; s#perf_event_mmap_page * user_page ; void * data_pages [ ] ; }
s#perf_buffer@f69550cf struct perf_buffer { UNKNOWN }
s#perf_callchain_entry struct perf_callchain_entry { t#__u64 nr ; t#__u64 ip [ ] ; }
s#perf_cgroup struct perf_cgroup { s#cgroup_subsys_state css ; s#perf_cgroup_info * info ; }
s#perf_cgroup_info struct perf_cgroup_info { t#u64 time ; t#u64 timestamp ; t#u64 timeoffset ; int active ; }
s#perf_cpu_pmu_context struct perf_cpu_pmu_context { s#perf_event_pmu_context epc ; s#perf_event_pmu_context * task_epc ; s#list_head sched_cb_entry ; int sched_cb_usage ; int active_oncpu ; int exclusive ; t#raw_spinlock_t hrtimer_lock ; s#hrtimer hrtimer ; t#ktime_t hrtimer_interval ; unsigned int hrtimer_active ; }
s#perf_domain struct perf_domain { s#em_perf_domain * em_pd ; s#perf_domain * next ; s#callback_head rcu ; }
s#perf_event@61b8f7ed struct perf_event { s#list_head event_entry ; s#list_head sibling_list ; s#list_head active_list ; s#rb_node group_node ; t#u64 group_index ; s#list_head migrate_entry ; s#hlist_node hlist_entry ; s#list_head active_entry ; int nr_siblings ; int event_caps ; int group_caps ; unsigned int group_generation ; s#perf_event * group_leader ; s#pmu * pmu ; void * pmu_private ; e#perf_event_state state ; unsigned int attach_state ; t#local64_t count ; t#atomic64_t child_count ; t#u64 total_time_enabled ; t#u64 total_time_running ; t#u64 tstamp ; s#perf_event_attr attr ; t#u16 header_size ; t#u16 id_header_size ; t#u16 read_size ; s#hw_perf_event hw ; s#perf_event_context * ctx ; s#perf_event_pmu_context * pmu_ctx ; t#atomic_long_t refcount ; t#atomic64_t child_total_time_enabled ; t#atomic64_t child_total_time_running ; s#mutex child_mutex ; s#list_head child_list ; s#perf_event * parent ; int oncpu ; int cpu ; s#list_head owner_entry ; s#task_struct * owner ; s#mutex mmap_mutex ; t#atomic_t mmap_count ; s#perf_buffer * rb ; s#list_head rb_entry ; unsigned long rcu_batches ; int rcu_pending ; t#wait_queue_head_t waitq ; s#fasync_struct * fasync ; unsigned int pending_wakeup ; unsigned int pending_kill ; unsigned int pending_disable ; unsigned long pending_addr ; s#irq_work pending_irq ; s#irq_work pending_disable_irq ; s#callback_head pending_task ; unsigned int pending_work ; s#rcuwait pending_work_wait ; t#atomic_t event_limit ; s#perf_addr_filters_head addr_filters ; s#perf_addr_filter_range * addr_filter_ranges ; unsigned long addr_filters_gen ; s#perf_event * aux_event ; void ( * destroy ) ( s#perf_event * ) ; s#callback_head callback_head ; s#pid_namespace * ns ; t#u64 id ; t#atomic64_t lost_samples ; t#u64 ( * clock ) ( void ) ; t#perf_overflow_handler_t overflow_handler ; void * overflow_handler_context ; s#bpf_prog * prog ; t#u64 bpf_cookie ; s#trace_event_call * tp_event ; s#event_filter * filter ; s#ftrace_ops ftrace_ops ; s#perf_cgroup * cgrp ; void * security ; s#list_head sb_list ; t#__u32 orig_type ; unsigned long uek_reserved1 ; }
s#perf_event@82b204da struct perf_event { UNKNOWN }
s#perf_event_attr struct perf_event_attr { t#__u32 type ; t#__u32 size ; t#__u64 config ; union { t#__u64 sample_period ; t#__u64 sample_freq ; } ; t#__u64 sample_type ; t#__u64 read_format ; t#__u64 disabled : 1 , inherit : 1 , pinned : 1 , exclusive : 1 , exclude_user : 1 , exclude_kernel : 1 , exclude_hv : 1 , exclude_idle : 1 , mmap : 1 , comm : 1 , freq : 1 , inherit_stat : 1 , enable_on_exec : 1 , task : 1 , watermark : 1 , precise_ip : 2 , mmap_data : 1 , sample_id_all : 1 , exclude_host : 1 , exclude_guest : 1 , exclude_callchain_kernel : 1 , exclude_callchain_user : 1 , mmap2 : 1 , comm_exec : 1 , use_clockid : 1 , context_switch : 1 , write_backward : 1 , namespaces : 1 , ksymbol : 1 , bpf_event : 1 , aux_output : 1 , cgroup : 1 , text_poke : 1 , build_id : 1 , inherit_thread : 1 , remove_on_exec : 1 , sigtrap : 1 , __reserved_1 : 26 ; union { t#__u32 wakeup_events ; t#__u32 wakeup_watermark ; } ; t#__u32 bp_type ; union { t#__u64 bp_addr ; t#__u64 kprobe_func ; t#__u64 uprobe_path ; t#__u64 config1 ; } ; union { t#__u64 bp_len ; t#__u64 kprobe_addr ; t#__u64 probe_offset ; t#__u64 config2 ; } ; t#__u64 branch_sample_type ; t#__u64 sample_regs_user ; t#__u32 sample_stack_user ; t#__s32 clockid ; t#__u64 sample_regs_intr ; t#__u32 aux_watermark ; t#__u16 sample_max_stack ; t#__u16 __reserved_2 ; t#__u32 aux_sample_size ; t#__u32 __reserved_3 ; t#__u64 sig_data ; t#__u64 config3 ; }
s#perf_event_context@11805577 struct perf_event_context { UNKNOWN }
s#perf_event_context@b070ac91 struct perf_event_context { t#raw_spinlock_t lock ; s#mutex mutex ; s#list_head pmu_ctx_list ; s#perf_event_groups pinned_groups ; s#perf_event_groups flexible_groups ; s#list_head event_list ; int nr_events ; int nr_user ; int is_active ; int nr_task_data ; int nr_stat ; int nr_freq ; int rotate_disable ; t#refcount_t refcount ; s#task_struct * task ; t#u64 time ; t#u64 timestamp ; t#u64 timeoffset ; s#perf_event_context * parent_ctx ; t#u64 parent_gen ; t#u64 generation ; int pin_count ; int nr_cgroups ; s#callback_head callback_head ; t#local_t nr_no_switch_fast ; unsigned long uek_reserved1 ; }
s#perf_event_groups struct perf_event_groups { s#rb_root tree ; t#u64 index ; }
s#perf_event_mmap_page struct perf_event_mmap_page { t#__u32 version ; t#__u32 compat_version ; t#__u32 lock ; t#__u32 index ; t#__s64 offset ; t#__u64 time_enabled ; t#__u64 time_running ; union { t#__u64 capabilities ; struct { t#__u64 cap_bit0 : 1 , cap_bit0_is_deprecated : 1 , cap_user_rdpmc : 1 , cap_user_time : 1 , cap_user_time_zero : 1 , cap_user_time_short : 1 , cap_____res : 58 ; } ; } ; t#__u16 pmc_width ; t#__u16 time_shift ; t#__u32 time_mult ; t#__u64 time_offset ; t#__u64 time_zero ; t#__u32 size ; t#__u32 __reserved_1 ; t#__u64 time_cycles ; t#__u64 time_mask ; t#__u8 __reserved [ 116 * 8 ] ; t#__u64 data_head ; t#__u64 data_tail ; t#__u64 data_offset ; t#__u64 data_size ; t#__u64 aux_head ; t#__u64 aux_tail ; t#__u64 aux_offset ; t#__u64 aux_size ; }
s#perf_event_pmu_context struct perf_event_pmu_context { s#pmu * pmu ; s#perf_event_context * ctx ; s#list_head pmu_ctx_entry ; s#list_head pinned_active ; s#list_head flexible_active ; unsigned int embedded : 1 ; unsigned int nr_events ; unsigned int nr_cgroups ; unsigned int nr_freq ; t#atomic_t refcount ; s#callback_head callback_head ; void * task_ctx_data ; int rotate_necessary ; }
s#perf_output_handle struct perf_output_handle { s#perf_event * event ; s#perf_buffer * rb ; unsigned long wakeup ; unsigned long size ; t#u64 aux_flags ; union { void * addr ; unsigned long head ; } ; int page ; }
s#perf_raw_frag struct perf_raw_frag { union { s#perf_raw_frag * next ; unsigned long pad ; } ; t#perf_copy_f copy ; void * data ; t#u32 size ; }
s#perf_raw_record struct perf_raw_record { s#perf_raw_frag frag ; t#u32 size ; }
s#perf_regs struct perf_regs { t#__u64 abi ; s#pt_regs * regs ; }
s#perf_sample_data struct perf_sample_data { t#u64 sample_flags ; t#u64 period ; t#u64 dyn_size ; t#u64 type ; struct { t#u32 pid ; t#u32 tid ; } tid_entry ; t#u64 time ; t#u64 id ; struct { t#u32 cpu ; t#u32 reserved ; } cpu_entry ; t#u64 ip ; s#perf_callchain_entry * callchain ; s#perf_raw_record * raw ; s#perf_branch_stack * br_stack ; t#u64 * br_stack_cntr ; u#perf_sample_weight weight ; u#perf_mem_data_src data_src ; t#u64 txn ; s#perf_regs regs_user ; s#perf_regs regs_intr ; t#u64 stack_user_size ; t#u64 stream_id ; t#u64 cgroup ; t#u64 addr ; t#u64 phys_addr ; t#u64 data_page_size ; t#u64 code_page_size ; t#u64 aux_size ; }
s#pf_desc struct pf_desc { t#u32 pseudoflavor ; t#u32 qop ; t#u32 service ; char * name ; char * auth_domain_name ; s#auth_domain * domain ; t#bool datatouch ; }
s#pglist_data struct pglist_data { s#zone node_zones [ 5 ] ; s#zonelist node_zonelists [ E#MAX_ZONELISTS ] ; int nr_zones ; t#spinlock_t node_size_lock ; unsigned long node_start_pfn ; unsigned long node_present_pages ; unsigned long node_spanned_pages ; int node_id ; t#wait_queue_head_t kswapd_wait ; t#wait_queue_head_t pfmemalloc_wait ; t#wait_queue_head_t reclaim_wait [ E#NR_VMSCAN_THROTTLE ] ; t#atomic_t nr_writeback_throttled ; unsigned long nr_reclaim_start ; s#mutex kswapd_lock ; s#task_struct * kswapd ; int kswapd_order ; e#zone_type kswapd_highest_zoneidx ; int kswapd_failures ; int kcompactd_max_order ; e#zone_type kcompactd_highest_zoneidx ; t#wait_queue_head_t kcompactd_wait ; s#task_struct * kcompactd ; t#bool proactive_compact_trigger ; unsigned long totalreserve_pages ; unsigned long min_unmapped_pages ; unsigned long min_slab_pages ; s#cacheline_padding _pad1_ ; unsigned long first_deferred_pfn ; s#deferred_split deferred_split_queue ; unsigned int nbp_rl_start ; unsigned long nbp_rl_nr_cand ; unsigned int nbp_threshold ; unsigned int nbp_th_start ; unsigned long nbp_th_nr_cand ; s#lruvec __lruvec ; unsigned long flags ; s#lru_gen_mm_walk mm_walk ; s#lru_gen_memcg memcg_lru ; s#cacheline_padding _pad2_ ; s#per_cpu_nodestat * per_cpu_nodestats ; t#atomic_long_t vm_stat [ E#NR_VM_NODE_STAT_ITEMS ] ; s#memory_tier * memtier ; s#memory_failure_stats mf_stats ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#pgprot struct pgprot { t#pgprotval_t pgprot ; }
s#phy_c45_device_ids struct phy_c45_device_ids { t#u32 devices_in_package ; t#u32 mmds_present ; t#u32 device_ids [ 32 ] ; }
s#phy_device@88a4c771 struct phy_device { UNKNOWN }
s#phy_device@bcfd7e25 struct phy_device { s#mdio_device mdio ; const s#phy_driver * drv ; s#device_link * devlink ; t#u32 phyindex ; t#u32 phy_id ; s#phy_c45_device_ids c45_ids ; unsigned is_c45 : 1 ; unsigned is_internal : 1 ; unsigned is_pseudo_fixed_link : 1 ; unsigned is_gigabit_capable : 1 ; unsigned has_fixups : 1 ; unsigned suspended : 1 ; unsigned suspended_by_mdio_bus : 1 ; unsigned sysfs_links : 1 ; unsigned loopback_enabled : 1 ; unsigned downshifted_rate : 1 ; unsigned is_on_sfp_module : 1 ; unsigned mac_managed_pm : 1 ; unsigned wol_enabled : 1 ; unsigned autoneg : 1 ; unsigned link : 1 ; unsigned autoneg_complete : 1 ; unsigned interrupts : 1 ; unsigned irq_suspended : 1 ; unsigned irq_rerun : 1 ; unsigned default_timestamp : 1 ; int rate_matching ; e#phy_state state ; t#u32 dev_flags ; t#phy_interface_t interface ; unsigned long possible_interfaces [ ( ( ( E#PHY_INTERFACE_MODE_MAX ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; int speed ; int duplex ; int port ; int pause ; int asym_pause ; t#u8 master_slave_get ; t#u8 master_slave_set ; t#u8 master_slave_state ; unsigned long supported [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long advertising [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long lp_advertising [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long adv_old [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long supported_eee [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long advertising_eee [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; t#bool eee_enabled ; unsigned long host_interfaces [ ( ( ( E#PHY_INTERFACE_MODE_MAX ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; t#u32 eee_broken_modes ; t#bool enable_tx_lpi ; s#eee_config eee_cfg ; s#phy_led_trigger * phy_led_triggers ; unsigned int phy_num_led_triggers ; s#phy_led_trigger * last_triggered ; s#phy_led_trigger * led_link_trigger ; s#list_head leds ; int irq ; void * priv ; s#phy_package_shared * shared ; s#sk_buff * skb ; void * ehdr ; s#nlattr * nest ; s#delayed_work state_queue ; s#mutex lock ; t#bool sfp_bus_attached ; s#sfp_bus * sfp_bus ; s#phylink * phylink ; s#net_device * attached_dev ; s#mii_timestamper * mii_ts ; s#pse_control * psec ; t#u8 mdix ; t#u8 mdix_ctrl ; int pma_extable ; unsigned int link_down_events ; void ( * phy_link_change ) ( s#phy_device * , t#bool ) ; void ( * adjust_link ) ( s#net_device * ) ; const s#macsec_ops * macsec_ops ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; }
s#phy_driver struct phy_driver { s#mdio_driver_common mdiodrv ; t#u32 phy_id ; char * name ; t#u32 phy_id_mask ; const unsigned long * const features ; t#u32 flags ; const void * driver_data ; int ( * soft_reset ) ( s#phy_device * ) ; int ( * config_init ) ( s#phy_device * ) ; int ( * probe ) ( s#phy_device * ) ; int ( * get_features ) ( s#phy_device * ) ; int ( * get_rate_matching ) ( s#phy_device * , t#phy_interface_t ) ; int ( * suspend ) ( s#phy_device * ) ; int ( * resume ) ( s#phy_device * ) ; int ( * config_aneg ) ( s#phy_device * ) ; int ( * aneg_done ) ( s#phy_device * ) ; int ( * read_status ) ( s#phy_device * ) ; int ( * config_intr ) ( s#phy_device * ) ; t#irqreturn_t ( * handle_interrupt ) ( s#phy_device * ) ; void ( * remove ) ( s#phy_device * ) ; int ( * match_phy_device ) ( s#phy_device * ) ; int ( * set_wol ) ( s#phy_device * , s#ethtool_wolinfo * ) ; void ( * get_wol ) ( s#phy_device * , s#ethtool_wolinfo * ) ; void ( * link_change_notify ) ( s#phy_device * ) ; int ( * read_mmd ) ( s#phy_device * , int , t#u16 ) ; int ( * write_mmd ) ( s#phy_device * , int , t#u16 , t#u16 ) ; int ( * read_page ) ( s#phy_device * ) ; int ( * write_page ) ( s#phy_device * , int ) ; int ( * module_info ) ( s#phy_device * , s#ethtool_modinfo * ) ; int ( * module_eeprom ) ( s#phy_device * , s#ethtool_eeprom * , t#u8 * ) ; int ( * cable_test_start ) ( s#phy_device * ) ; int ( * cable_test_tdr_start ) ( s#phy_device * , const s#phy_tdr_config * ) ; int ( * cable_test_get_status ) ( s#phy_device * , t#bool * ) ; void ( * get_phy_stats ) ( s#phy_device * , s#ethtool_eth_phy_stats * , s#ethtool_phy_stats * ) ; void ( * get_link_stats ) ( s#phy_device * , s#ethtool_link_ext_stats * ) ; int ( * get_sset_count ) ( s#phy_device * ) ; void ( * get_strings ) ( s#phy_device * , t#u8 * ) ; void ( * get_stats ) ( s#phy_device * , s#ethtool_stats * , t#u64 * ) ; int ( * get_tunable ) ( s#phy_device * , s#ethtool_tunable * , void * ) ; int ( * set_tunable ) ( s#phy_device * , s#ethtool_tunable * , const void * ) ; int ( * set_loopback ) ( s#phy_device * , t#bool ) ; int ( * get_sqi ) ( s#phy_device * ) ; int ( * get_sqi_max ) ( s#phy_device * ) ; int ( * get_plca_cfg ) ( s#phy_device * , s#phy_plca_cfg * ) ; int ( * set_plca_cfg ) ( s#phy_device * , const s#phy_plca_cfg * ) ; int ( * get_plca_status ) ( s#phy_device * , s#phy_plca_status * ) ; int ( * led_brightness_set ) ( s#phy_device * , t#u8 , e#led_brightness ) ; int ( * led_blink_set ) ( s#phy_device * , t#u8 , unsigned long * , unsigned long * ) ; int ( * led_hw_is_supported ) ( s#phy_device * , t#u8 , unsigned long ) ; int ( * led_hw_control_set ) ( s#phy_device * , t#u8 , unsigned long ) ; int ( * led_hw_control_get ) ( s#phy_device * , t#u8 , unsigned long * ) ; int ( * led_polarity_set ) ( s#phy_device * , int , unsigned long ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; }
s#phy_led_trigger@24dcd9ef struct phy_led_trigger { s#led_trigger trigger ; char name [ ( 61 + sizeof ( ( ( ( struct mdio_device * ) 0 ) -> addr ) ) + 11 ) ] ; unsigned int speed ; }
s#phy_led_trigger@5e55ce3b struct phy_led_trigger { UNKNOWN }
s#phy_link_topology@0171cd0f struct phy_link_topology { s#xarray phys ; t#u32 next_phy_index ; }
s#phy_link_topology@dd16f297 struct phy_link_topology { UNKNOWN }
s#phy_package_shared struct phy_package_shared { t#u8 base_addr ; s#device_node * np ; t#refcount_t refcnt ; unsigned long flags ; t#size_t priv_size ; void * priv ; }
s#phy_plca_cfg struct phy_plca_cfg { int version ; int enabled ; int node_id ; int node_cnt ; int to_tmr ; int burst_cnt ; int burst_tmr ; }
s#phy_plca_status struct phy_plca_status { t#bool pst ; }
s#phy_tdr_config struct phy_tdr_config { t#u32 first ; t#u32 last ; t#u32 step ; t#s8 pair ; }
s#phylink struct phylink { UNKNOWN }
s#phylink_config struct phylink_config { s#device * dev ; e#phylink_op_type type ; t#bool poll_fixed_state ; t#bool mac_managed_pm ; t#bool mac_requires_rxc ; t#bool default_an_inband ; void ( * get_fixed_state ) ( s#phylink_config * , s#phylink_link_state * ) ; unsigned long supported_interfaces [ ( ( ( E#PHY_INTERFACE_MODE_MAX ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long mac_capabilities ; }
s#phylink_link_state struct phylink_link_state { unsigned long advertising [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long lp_advertising [ ( ( ( E#__ETHTOOL_LINK_MODE_MASK_NBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; t#phy_interface_t interface ; int speed ; int duplex ; int pause ; int rate_matching ; unsigned int link : 1 ; unsigned int an_complete : 1 ; }
s#phylink_mac_ops struct phylink_mac_ops { unsigned long ( * mac_get_caps ) ( s#phylink_config * , t#phy_interface_t ) ; s#phylink_pcs * ( * mac_select_pcs ) ( s#phylink_config * , t#phy_interface_t ) ; int ( * mac_prepare ) ( s#phylink_config * , unsigned int , t#phy_interface_t ) ; void ( * mac_config ) ( s#phylink_config * , unsigned int , const s#phylink_link_state * ) ; int ( * mac_finish ) ( s#phylink_config * , unsigned int , t#phy_interface_t ) ; void ( * mac_link_down ) ( s#phylink_config * , unsigned int , t#phy_interface_t ) ; void ( * mac_link_up ) ( s#phylink_config * , s#phy_device * , unsigned int , t#phy_interface_t , int , int , t#bool , t#bool ) ; }
s#phylink_pcs struct phylink_pcs { const s#phylink_pcs_ops * ops ; s#phylink * phylink ; t#bool neg_mode ; t#bool poll ; t#bool rxc_always_on ; }
s#phylink_pcs_ops struct phylink_pcs_ops { int ( * pcs_validate ) ( s#phylink_pcs * , unsigned long * , const s#phylink_link_state * ) ; int ( * pcs_enable ) ( s#phylink_pcs * ) ; void ( * pcs_disable ) ( s#phylink_pcs * ) ; void ( * pcs_pre_config ) ( s#phylink_pcs * , t#phy_interface_t ) ; int ( * pcs_post_config ) ( s#phylink_pcs * , t#phy_interface_t ) ; void ( * pcs_get_state ) ( s#phylink_pcs * , s#phylink_link_state * ) ; int ( * pcs_config ) ( s#phylink_pcs * , unsigned int , t#phy_interface_t , const unsigned long * , t#bool ) ; void ( * pcs_an_restart ) ( s#phylink_pcs * ) ; void ( * pcs_link_up ) ( s#phylink_pcs * , unsigned int , t#phy_interface_t , int , int ) ; int ( * pcs_pre_init ) ( s#phylink_pcs * ) ; }
s#pi_entry struct pi_entry { const char * fmt ; const char * func ; const char * file ; unsigned int line ; const char * level ; const char * subsys_fmt_prefix ; }
s#pid@8fb1b168 struct pid { t#refcount_t count ; unsigned int level ; t#spinlock_t lock ; s#dentry * stashed ; t#u64 ino ; s#hlist_head tasks [ E#PIDTYPE_MAX ] ; s#hlist_head inodes ; t#wait_queue_head_t wait_pidfd ; s#callback_head rcu ; s#upid numbers [ ] ; }
s#pid@e1a4a4d8 struct pid { UNKNOWN }
s#pid_namespace@949a5140 struct pid_namespace { s#idr idr ; s#callback_head rcu ; unsigned int pid_allocated ; s#task_struct * child_reaper ; s#kmem_cache * pid_cachep ; unsigned int level ; s#pid_namespace * parent ; s#fs_pin * bacct ; s#user_namespace * user_ns ; s#ucounts * ucounts ; int reboot ; s#ns_common ns ; int memfd_noexec_scope ; }
s#pid_namespace@987b78a4 struct pid_namespace { UNKNOWN }
s#pin_cookie struct pin_cookie { }
s#pinctrl@155ad7e7 struct pinctrl { s#list_head node ; s#device * dev ; s#list_head states ; s#pinctrl_state * state ; s#list_head dt_maps ; s#kref users ; }
s#pinctrl@a5fbfbdf struct pinctrl { UNKNOWN }
s#pinctrl_state@1b06de18 struct pinctrl_state { UNKNOWN }
s#pinctrl_state@eb5c35df struct pinctrl_state { s#list_head node ; const char * name ; s#list_head settings ; }
s#ping_group_range struct ping_group_range { t#seqlock_t lock ; t#kgid_t range [ 2 ] ; }
s#pipe_buf_operations struct pipe_buf_operations { int ( * confirm ) ( s#pipe_inode_info * , s#pipe_buffer * ) ; void ( * release ) ( s#pipe_inode_info * , s#pipe_buffer * ) ; t#bool ( * try_steal ) ( s#pipe_inode_info * , s#pipe_buffer * ) ; t#bool ( * get ) ( s#pipe_inode_info * , s#pipe_buffer * ) ; }
s#pipe_buffer struct pipe_buffer { s#page * page ; unsigned int offset , len ; const s#pipe_buf_operations * ops ; unsigned int flags ; unsigned long private ; }
s#pipe_inode_info@b8d1ccf7 struct pipe_inode_info { UNKNOWN }
s#pipe_inode_info@bfb6453b struct pipe_inode_info { s#mutex mutex ; t#wait_queue_head_t rd_wait , wr_wait ; unsigned int head ; unsigned int tail ; unsigned int max_usage ; unsigned int ring_size ; unsigned int nr_accounted ; unsigned int readers ; unsigned int writers ; unsigned int files ; unsigned int r_counter ; unsigned int w_counter ; t#bool poll_usage ; t#bool note_loss ; s#page * tmp_page ; s#fasync_struct * fasync_readers ; s#fasync_struct * fasync_writers ; s#pipe_buffer * bufs ; s#user_struct * user ; s#watch_queue * watch_queue ; }
s#plist_head struct plist_head { s#list_head node_list ; }
s#plist_node struct plist_node { int prio ; s#list_head prio_list ; s#list_head node_list ; }
s#pm_message struct pm_message { int event ; }
s#pm_qos_constraints struct pm_qos_constraints { s#plist_head list ; t#s32 target_value ; t#s32 default_value ; t#s32 no_constraint_value ; e#pm_qos_type type ; s#blocking_notifier_head * notifiers ; }
s#pm_qos_flags struct pm_qos_flags { s#list_head list ; t#s32 effective_flags ; }
s#pm_qos_flags_request struct pm_qos_flags_request { s#list_head node ; t#s32 flags ; }
s#pm_subsys_data struct pm_subsys_data { t#spinlock_t lock ; unsigned int refcount ; unsigned int clock_op_might_sleep ; s#mutex clock_mutex ; s#list_head clock_list ; }
s#pmu struct pmu { s#list_head entry ; s#module * module ; s#device * dev ; s#device * parent ; const s#attribute_group * * attr_groups ; const s#attribute_group * * attr_update ; const char * name ; int type ; int capabilities ; unsigned int scope ; int * pmu_disable_count ; s#perf_cpu_pmu_context * cpu_pmu_context ; t#atomic_t exclusive_cnt ; int task_ctx_nr ; int hrtimer_interval_ms ; unsigned int nr_addr_filters ; void ( * pmu_enable ) ( s#pmu * ) ; void ( * pmu_disable ) ( s#pmu * ) ; int ( * event_init ) ( s#perf_event * ) ; void ( * event_mapped ) ( s#perf_event * , s#mm_struct * ) ; void ( * event_unmapped ) ( s#perf_event * , s#mm_struct * ) ; int ( * add ) ( s#perf_event * , int ) ; void ( * del ) ( s#perf_event * , int ) ; void ( * start ) ( s#perf_event * , int ) ; void ( * stop ) ( s#perf_event * , int ) ; void ( * read ) ( s#perf_event * ) ; void ( * start_txn ) ( s#pmu * , unsigned int ) ; int ( * commit_txn ) ( s#pmu * ) ; void ( * cancel_txn ) ( s#pmu * ) ; int ( * event_idx ) ( s#perf_event * ) ; void ( * sched_task ) ( s#perf_event_pmu_context * , t#bool ) ; s#kmem_cache * task_ctx_cache ; void ( * swap_task_ctx ) ( s#perf_event_pmu_context * , s#perf_event_pmu_context * ) ; void * ( * setup_aux ) ( s#perf_event * , void * * , int , t#bool ) ; void ( * free_aux ) ( void * ) ; long ( * snapshot_aux ) ( s#perf_event * , s#perf_output_handle * , unsigned long ) ; int ( * addr_filters_validate ) ( s#list_head * ) ; void ( * addr_filters_sync ) ( s#perf_event * ) ; int ( * aux_output_match ) ( s#perf_event * ) ; t#bool ( * filter ) ( s#pmu * , int ) ; int ( * check_period ) ( s#perf_event * , t#u64 ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#pneigh_entry struct pneigh_entry { s#pneigh_entry * next ; t#possible_net_t net ; s#net_device * dev ; t#netdevice_tracker dev_tracker ; t#u32 flags ; t#u8 protocol ; t#u32 key [ ] ; }
s#pnfs_commit_ops@6013358f struct pnfs_commit_ops { void ( * setup_ds_info ) ( s#pnfs_ds_commit_info * , s#pnfs_layout_segment * ) ; void ( * release_ds_info ) ( s#pnfs_ds_commit_info * , s#inode * ) ; int ( * commit_pagelist ) ( s#inode * , s#list_head * , int , s#nfs_commit_info * ) ; void ( * mark_request_commit ) ( s#nfs_page * , s#pnfs_layout_segment * , s#nfs_commit_info * , t#u32 ) ; void ( * clear_request_commit ) ( s#nfs_page * , s#nfs_commit_info * ) ; int ( * scan_commit_lists ) ( s#nfs_commit_info * , int ) ; void ( * recover_commit_reqs ) ( s#list_head * , s#nfs_commit_info * ) ; }
s#pnfs_commit_ops@d42a723a struct pnfs_commit_ops { UNKNOWN }
s#pnfs_device struct pnfs_device { s#nfs4_deviceid dev_id ; unsigned int layout_type ; unsigned int mincount ; unsigned int maxcount ; s#page * * pages ; unsigned int pgbase ; unsigned int pglen ; unsigned char nocache : 1 ; }
s#pnfs_ds_commit_info struct pnfs_ds_commit_info { s#list_head commits ; unsigned int nwritten ; unsigned int ncommitting ; const s#pnfs_commit_ops * ops ; }
s#pnfs_layout_hdr struct pnfs_layout_hdr { t#refcount_t plh_refcount ; t#atomic_t plh_outstanding ; s#list_head plh_layouts ; s#list_head plh_bulk_destroy ; s#list_head plh_segs ; s#list_head plh_return_segs ; unsigned long plh_block_lgets ; unsigned long plh_retry_timestamp ; unsigned long plh_flags ; t#nfs4_stateid plh_stateid ; t#u32 plh_barrier ; t#u32 plh_return_seq ; e#pnfs_iomode plh_return_iomode ; t#loff_t plh_lwb ; const s#cred * plh_lc_cred ; s#inode * plh_inode ; s#callback_head plh_rcu ; }
s#pnfs_layout_range struct pnfs_layout_range { t#u32 iomode ; t#u64 offset ; t#u64 length ; }
s#pnfs_layout_segment@9518e838 struct pnfs_layout_segment { UNKNOWN }
s#pnfs_layout_segment@bdadbfd1 struct pnfs_layout_segment { s#list_head pls_list ; s#list_head pls_lc_list ; s#list_head pls_commits ; s#pnfs_layout_range pls_range ; t#refcount_t pls_refcount ; t#u32 pls_seq ; unsigned long pls_flags ; s#pnfs_layout_hdr * pls_layout ; }
s#pnfs_layoutdriver_type@4b18a7c7 struct pnfs_layoutdriver_type { UNKNOWN }
s#pnfs_layoutdriver_type@4f4e6f4e struct pnfs_layoutdriver_type { s#list_head pnfs_tblid ; const t#u32 id ; const char * name ; s#module * owner ; unsigned flags ; unsigned max_layoutget_response ; int ( * set_layoutdriver ) ( s#nfs_server * , const s#nfs_fh * ) ; int ( * clear_layoutdriver ) ( s#nfs_server * ) ; s#pnfs_layout_hdr * ( * alloc_layout_hdr ) ( s#inode * , t#gfp_t ) ; void ( * free_layout_hdr ) ( s#pnfs_layout_hdr * ) ; s#pnfs_layout_segment * ( * alloc_lseg ) ( s#pnfs_layout_hdr * , s#nfs4_layoutget_res * , t#gfp_t ) ; void ( * free_lseg ) ( s#pnfs_layout_segment * ) ; void ( * add_lseg ) ( s#pnfs_layout_hdr * , s#pnfs_layout_segment * , s#list_head * ) ; void ( * return_range ) ( s#pnfs_layout_hdr * , s#pnfs_layout_range * ) ; const s#nfs_pageio_ops * pg_read_ops ; const s#nfs_pageio_ops * pg_write_ops ; s#pnfs_ds_commit_info * ( * get_ds_info ) ( s#inode * ) ; int ( * sync ) ( s#inode * , t#bool ) ; e#pnfs_try_status ( * read_pagelist ) ( s#nfs_pgio_header * ) ; e#pnfs_try_status ( * write_pagelist ) ( s#nfs_pgio_header * , int ) ; void ( * free_deviceid_node ) ( s#nfs4_deviceid_node * ) ; s#nfs4_deviceid_node * ( * alloc_deviceid_node ) ( s#nfs_server * , s#pnfs_device * , t#gfp_t ) ; int ( * prepare_layoutreturn ) ( s#nfs4_layoutreturn_args * ) ; void ( * cleanup_layoutcommit ) ( s#nfs4_layoutcommit_data * ) ; int ( * prepare_layoutcommit ) ( s#nfs4_layoutcommit_args * ) ; int ( * prepare_layoutstats ) ( s#nfs42_layoutstat_args * ) ; void ( * cancel_io ) ( s#pnfs_layout_segment * ) ; }
s#poll_table_struct@8d8f3878 struct poll_table_struct { t#poll_queue_proc _qproc ; t#__poll_t _key ; }
s#poll_table_struct@ff0e459e struct poll_table_struct { UNKNOWN }
s#pollfd@9600d34e struct pollfd { UNKNOWN }
s#pollfd@b58156ac struct pollfd { int fd ; short events ; short revents ; }
s#posix_acl@4d5b1a1c struct posix_acl { t#refcount_t a_refcount ; s#callback_head a_rcu ; unsigned int a_count ; s#posix_acl_entry a_entries [ ] ; }
s#posix_acl@a4ffd084 struct posix_acl { UNKNOWN }
s#posix_acl_entry struct posix_acl_entry { short e_tag ; unsigned short e_perm ; union { t#kuid_t e_uid ; t#kgid_t e_gid ; } ; }
s#posix_cputimer_base struct posix_cputimer_base { t#u64 nextevt ; s#timerqueue_head tqhead ; }
s#posix_cputimers struct posix_cputimers { s#posix_cputimer_base bases [ 3 ] ; unsigned int timers_active ; unsigned int expiry_active ; }
s#posix_cputimers_work struct posix_cputimers_work { s#callback_head work ; s#mutex mutex ; unsigned int scheduled ; }
s#pp_alloc_cache struct pp_alloc_cache { t#u32 count ; t#netmem_ref cache [ 128 ] ; }
s#pp_memory_provider_params struct pp_memory_provider_params { void * mp_priv ; }
s#pr_held_reservation struct pr_held_reservation { t#u64 key ; t#u32 generation ; e#pr_type type ; }
s#pr_keys struct pr_keys { t#u32 generation ; t#u32 num_keys ; t#u64 keys [ ] ; }
s#pr_ops@051404f6 struct pr_ops { int ( * pr_register ) ( s#block_device * , t#u64 , t#u64 , t#u32 ) ; int ( * pr_reserve ) ( s#block_device * , t#u64 , e#pr_type , t#u32 ) ; int ( * pr_release ) ( s#block_device * , t#u64 , e#pr_type ) ; int ( * pr_preempt ) ( s#block_device * , t#u64 , t#u64 , e#pr_type , t#bool ) ; int ( * pr_clear ) ( s#block_device * , t#u64 ) ; int ( * pr_read_keys ) ( s#block_device * , s#pr_keys * ) ; int ( * pr_read_reservation ) ( s#block_device * , s#pr_held_reservation * ) ; }
s#pr_ops@43a01d23 struct pr_ops { UNKNOWN }
s#prefix_info@6ae4bd45 struct prefix_info { t#__u8 type ; t#__u8 length ; t#__u8 prefix_len ; union __attribute__ ( ( __packed__ ) ) { __u8 flags ; struct __attribute__ ( ( __packed__ ) ) { __u8 reserved : 4 , preferpd : 1 , routeraddr : 1 , autoconf : 1 , onlink : 1 ; }
s#prefix_info@8e275acb struct prefix_info { UNKNOWN }
s#prev_cputime struct prev_cputime { t#u64 utime ; t#u64 stime ; t#raw_spinlock_t lock ; }
s#proc_dir_entry@5f4e08e8 struct proc_dir_entry { t#atomic_t in_use ; t#refcount_t refcnt ; s#list_head pde_openers ; t#spinlock_t pde_unload_lock ; s#completion * pde_unload_completion ; const s#inode_operations * proc_iops ; union { const s#proc_ops * proc_ops ; const s#file_operations * proc_dir_ops ; } ; const s#dentry_operations * proc_dops ; union { const s#seq_operations * seq_ops ; int ( * single_show ) ( s#seq_file * , void * ) ; } ; t#proc_write_t write ; void * data ; unsigned int state_size ; unsigned int low_ino ; t#nlink_t nlink ; t#kuid_t uid ; t#kgid_t gid ; t#loff_t size ; s#proc_dir_entry * parent ; s#rb_root subdir ; s#rb_node subdir_node ; char * name ; t#umode_t mode ; t#u8 flags ; t#u8 namelen ; char inline_name [ ] ; }
s#proc_dir_entry@615cd3ba struct proc_dir_entry { UNKNOWN }
s#proc_ns_operations@40742561 struct proc_ns_operations { const char * name ; const char * real_ns_name ; int type ; s#ns_common * ( * get ) ( s#task_struct * ) ; void ( * put ) ( s#ns_common * ) ; int ( * install ) ( s#nsset * , s#ns_common * ) ; s#user_namespace * ( * owner ) ( s#ns_common * ) ; s#ns_common * ( * get_parent ) ( s#ns_common * ) ; }
s#proc_ns_operations@d97ed1ec struct proc_ns_operations { UNKNOWN }
s#proc_ops struct proc_ops { unsigned int proc_flags ; int ( * proc_open ) ( s#inode * , s#file * ) ; t#ssize_t ( * proc_read ) ( s#file * , char * , t#size_t , t#loff_t * ) ; t#ssize_t ( * proc_read_iter ) ( s#kiocb * , s#iov_iter * ) ; t#ssize_t ( * proc_write ) ( s#file * , const char * , t#size_t , t#loff_t * ) ; t#loff_t ( * proc_lseek ) ( s#file * , t#loff_t , int ) ; int ( * proc_release ) ( s#inode * , s#file * ) ; t#__poll_t ( * proc_poll ) ( s#file * , s#poll_table_struct * ) ; long ( * proc_ioctl ) ( s#file * , unsigned int , unsigned long ) ; long ( * proc_compat_ioctl ) ( s#file * , unsigned int , unsigned long ) ; int ( * proc_mmap ) ( s#file * , s#vm_area_struct * ) ; unsigned long ( * proc_get_unmapped_area ) ( s#file * , unsigned long , unsigned long , unsigned long , unsigned long ) ; }
s#prog_entry struct prog_entry { UNKNOWN }
s#property struct property { char * name ; int length ; void * value ; s#property * next ; }
s#prot_inuse@6e8fe549 struct prot_inuse { int all ; int val [ 64 ] ; }
s#prot_inuse@df3cc499 struct prot_inuse { UNKNOWN }
s#proto struct proto { void ( * close ) ( s#sock * , long ) ; int ( * pre_connect ) ( s#sock * , s#sockaddr * , int ) ; int ( * connect ) ( s#sock * , s#sockaddr * , int ) ; int ( * disconnect ) ( s#sock * , int ) ; s#sock * ( * accept ) ( s#sock * , s#proto_accept_arg * ) ; int ( * ioctl ) ( s#sock * , int , int * ) ; int ( * init ) ( s#sock * ) ; void ( * destroy ) ( s#sock * ) ; void ( * shutdown ) ( s#sock * , int ) ; int ( * setsockopt ) ( s#sock * , int , int , t#sockptr_t , unsigned int ) ; int ( * getsockopt ) ( s#sock * , int , int , char * , int * ) ; void ( * keepalive ) ( s#sock * , int ) ; int ( * compat_ioctl ) ( s#sock * , unsigned int , unsigned long ) ; int ( * sendmsg ) ( s#sock * , s#msghdr * , t#size_t ) ; int ( * recvmsg ) ( s#sock * , s#msghdr * , t#size_t , int , int * ) ; void ( * splice_eof ) ( s#socket * ) ; int ( * bind ) ( s#sock * , s#sockaddr * , int ) ; int ( * bind_add ) ( s#sock * , s#sockaddr * , int ) ; int ( * backlog_rcv ) ( s#sock * , s#sk_buff * ) ; t#bool ( * bpf_bypass_getsockopt ) ( int , int ) ; void ( * release_cb ) ( s#sock * ) ; int ( * hash ) ( s#sock * ) ; void ( * unhash ) ( s#sock * ) ; void ( * rehash ) ( s#sock * ) ; int ( * get_port ) ( s#sock * , unsigned short ) ; void ( * put_port ) ( s#sock * ) ; int ( * psock_update_sk_prot ) ( s#sock * , s#sk_psock * , t#bool ) ; unsigned int inuse_idx ; int ( * forward_alloc_get ) ( const s#sock * ) ; t#bool ( * stream_memory_free ) ( const s#sock * , int ) ; t#bool ( * sock_is_readable ) ( s#sock * ) ; void ( * enter_memory_pressure ) ( s#sock * ) ; void ( * leave_memory_pressure ) ( s#sock * ) ; t#atomic_long_t * memory_allocated ; int * per_cpu_fw_alloc ; s#percpu_counter * sockets_allocated ; unsigned long * memory_pressure ; long * sysctl_mem ; int * sysctl_wmem ; int * sysctl_rmem ; t#u32 sysctl_wmem_offset ; t#u32 sysctl_rmem_offset ; int max_header ; t#bool no_autobind ; s#kmem_cache * slab ; unsigned int obj_size ; unsigned int ipv6_pinfo_offset ; t#slab_flags_t slab_flags ; unsigned int useroffset ; unsigned int usersize ; unsigned int * orphan_count ; s#request_sock_ops * rsk_prot ; s#timewait_sock_ops * twsk_prot ; union { s#inet_hashinfo * hashinfo ; s#udp_table * udp_table ; s#raw_hashinfo * raw_hash ; s#smc_hashinfo * smc_hash ; } h ; s#module * owner ; char name [ 32 ] ; s#list_head node ; int ( * diag_destroy ) ( s#sock * , int ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; }
s#proto_accept_arg@66a51b4a struct proto_accept_arg { UNKNOWN }
s#proto_accept_arg@91662e5f struct proto_accept_arg { int flags ; int err ; int is_empty ; t#bool kern ; }
s#proto_ops struct proto_ops { int family ; s#module * owner ; int ( * release ) ( s#socket * ) ; int ( * bind ) ( s#socket * , s#sockaddr * , int ) ; int ( * connect ) ( s#socket * , s#sockaddr * , int , int ) ; int ( * socketpair ) ( s#socket * , s#socket * ) ; int ( * accept ) ( s#socket * , s#socket * , s#proto_accept_arg * ) ; int ( * getname ) ( s#socket * , s#sockaddr * , int ) ; t#__poll_t ( * poll ) ( s#file * , s#socket * , s#poll_table_struct * ) ; int ( * ioctl ) ( s#socket * , unsigned int , unsigned long ) ; int ( * compat_ioctl ) ( s#socket * , unsigned int , unsigned long ) ; int ( * gettstamp ) ( s#socket * , void * , t#bool , t#bool ) ; int ( * listen ) ( s#socket * , int ) ; int ( * shutdown ) ( s#socket * , int ) ; int ( * setsockopt ) ( s#socket * , int , int , t#sockptr_t , unsigned int ) ; int ( * getsockopt ) ( s#socket * , int , int , char * , int * ) ; void ( * show_fdinfo ) ( s#seq_file * , s#socket * ) ; int ( * sendmsg ) ( s#socket * , s#msghdr * , t#size_t ) ; int ( * recvmsg ) ( s#socket * , s#msghdr * , t#size_t , int ) ; int ( * mmap ) ( s#file * , s#socket * , s#vm_area_struct * ) ; t#ssize_t ( * splice_read ) ( s#socket * , t#loff_t * , s#pipe_inode_info * , t#size_t , unsigned int ) ; void ( * splice_eof ) ( s#socket * ) ; int ( * set_peek_off ) ( s#sock * , int ) ; int ( * peek_len ) ( s#socket * ) ; int ( * read_sock ) ( s#sock * , t#read_descriptor_t * , t#sk_read_actor_t ) ; int ( * read_skb ) ( s#sock * , t#skb_read_actor_t ) ; int ( * sendmsg_locked ) ( s#sock * , s#msghdr * , t#size_t ) ; int ( * set_rcvlowat ) ( s#sock * , int ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; }
s#psample_group@19511b48 struct psample_group { UNKNOWN }
s#psample_group@e0aa16db struct psample_group { s#list_head list ; s#net * net ; t#u32 group_num ; t#u32 refcount ; t#u32 seq ; s#callback_head rcu ; }
s#pse_control struct pse_control { UNKNOWN }
s#psi_group struct psi_group { s#psi_group * parent ; t#bool enabled ; s#mutex avgs_lock ; s#psi_group_cpu * pcpu ; t#u64 avg_total [ E#NR_PSI_STATES - 1 ] ; t#u64 avg_last_update ; t#u64 avg_next_update ; s#delayed_work avgs_work ; s#list_head avg_triggers ; t#u32 avg_nr_triggers [ E#NR_PSI_STATES - 1 ] ; t#u64 total [ E#NR_PSI_AGGREGATORS ] [ E#NR_PSI_STATES - 1 ] ; unsigned long avg [ E#NR_PSI_STATES - 1 ] [ 3 ] ; s#task_struct * rtpoll_task ; s#timer_list rtpoll_timer ; t#wait_queue_head_t rtpoll_wait ; t#atomic_t rtpoll_wakeup ; t#atomic_t rtpoll_scheduled ; s#mutex rtpoll_trigger_lock ; s#list_head rtpoll_triggers ; t#u32 rtpoll_nr_triggers [ E#NR_PSI_STATES - 1 ] ; t#u32 rtpoll_states ; t#u64 rtpoll_min_period ; t#u64 rtpoll_total [ E#NR_PSI_STATES - 1 ] ; t#u64 rtpoll_next_update ; t#u64 rtpoll_until ; }
s#psi_group_cpu struct psi_group_cpu { t#seqcount_t seq __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; unsigned int tasks [ E#NR_PSI_TASK_COUNTS ] ; t#u32 state_mask ; t#u32 times [ E#NR_PSI_STATES ] ; t#u64 state_start ; t#u32 times_prev [ E#NR_PSI_AGGREGATORS ] [ E#NR_PSI_STATES ] __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; }
s#pt_regs struct pt_regs { unsigned long r15 ; unsigned long r14 ; unsigned long r13 ; unsigned long r12 ; unsigned long bp ; unsigned long bx ; unsigned long r11 ; unsigned long r10 ; unsigned long r9 ; unsigned long r8 ; unsigned long ax ; unsigned long cx ; unsigned long dx ; unsigned long si ; unsigned long di ; unsigned long orig_ax ; unsigned long ip ; union { t#u16 cs ; t#u64 csx ; s#fred_cs fred_cs ; } ; unsigned long flags ; unsigned long sp ; union { t#u16 ss ; t#u64 ssx ; s#fred_ss fred_ss ; } ; }
s#ptr_ring struct ptr_ring { int producer __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; t#spinlock_t producer_lock ; int consumer_head __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; int consumer_tail ; t#spinlock_t consumer_lock ; int size __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; int batch ; void * * queue ; }
s#pv_cpu_ops struct pv_cpu_ops { void ( * io_delay ) ( void ) ; unsigned long ( * get_debugreg ) ( int ) ; void ( * set_debugreg ) ( int , unsigned long ) ; unsigned long ( * read_cr0 ) ( void ) ; void ( * write_cr0 ) ( unsigned long ) ; void ( * write_cr4 ) ( unsigned long ) ; void ( * load_tr_desc ) ( void ) ; void ( * load_gdt ) ( const s#desc_ptr * ) ; void ( * load_idt ) ( const s#desc_ptr * ) ; void ( * set_ldt ) ( const void * , unsigned ) ; unsigned long ( * store_tr ) ( void ) ; void ( * load_tls ) ( s#thread_struct * , unsigned int ) ; void ( * load_gs_index ) ( unsigned int ) ; void ( * write_ldt_entry ) ( s#desc_struct * , int , const void * ) ; void ( * write_gdt_entry ) ( s#desc_struct * , int , const void * , int ) ; void ( * write_idt_entry ) ( t#gate_desc * , int , const t#gate_desc * ) ; void ( * alloc_ldt ) ( s#desc_struct * , unsigned ) ; void ( * free_ldt ) ( s#desc_struct * , unsigned ) ; void ( * load_sp0 ) ( unsigned long ) ; void ( * invalidate_io_bitmap ) ( void ) ; void ( * update_io_bitmap ) ( void ) ; void ( * wbinvd ) ( void ) ; void ( * cpuid ) ( unsigned int * , unsigned int * , unsigned int * , unsigned int * ) ; t#u64 ( * read_msr ) ( unsigned int ) ; void ( * write_msr ) ( unsigned int , unsigned , unsigned ) ; t#u64 ( * read_msr_safe ) ( unsigned int , int * ) ; int ( * write_msr_safe ) ( unsigned int , unsigned , unsigned ) ; t#u64 ( * read_pmc ) ( int ) ; void ( * start_context_switch ) ( s#task_struct * ) ; void ( * end_context_switch ) ( s#task_struct * ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#pv_irq_ops struct pv_irq_ops { s#paravirt_callee_save save_fl ; s#paravirt_callee_save irq_disable ; s#paravirt_callee_save irq_enable ; void ( * safe_halt ) ( void ) ; void ( * halt ) ( void ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#pv_lazy_ops struct pv_lazy_ops { void ( * enter ) ( void ) ; void ( * leave ) ( void ) ; void ( * flush ) ( void ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#pv_lock_ops struct pv_lock_ops { void ( * queued_spin_lock_slowpath ) ( s#qspinlock * , t#u32 ) ; s#paravirt_callee_save queued_spin_unlock ; void ( * wait ) ( t#u8 * , t#u8 ) ; void ( * kick ) ( int ) ; s#paravirt_callee_save vcpu_is_preempted ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#pv_mmu_ops struct pv_mmu_ops { void ( * flush_tlb_user ) ( void ) ; void ( * flush_tlb_kernel ) ( void ) ; void ( * flush_tlb_one_user ) ( unsigned long ) ; void ( * flush_tlb_multi ) ( const s#cpumask * , const s#flush_tlb_info * ) ; void ( * tlb_remove_table ) ( s#mmu_gather * , void * ) ; void ( * exit_mmap ) ( s#mm_struct * ) ; void ( * notify_page_enc_status_changed ) ( unsigned long , int , t#bool ) ; s#paravirt_callee_save read_cr2 ; void ( * write_cr2 ) ( unsigned long ) ; unsigned long ( * read_cr3 ) ( void ) ; void ( * write_cr3 ) ( unsigned long ) ; void ( * enter_mmap ) ( s#mm_struct * ) ; int ( * pgd_alloc ) ( s#mm_struct * ) ; void ( * pgd_free ) ( s#mm_struct * , t#pgd_t * ) ; void ( * alloc_pte ) ( s#mm_struct * , unsigned long ) ; void ( * alloc_pmd ) ( s#mm_struct * , unsigned long ) ; void ( * alloc_pud ) ( s#mm_struct * , unsigned long ) ; void ( * alloc_p4d ) ( s#mm_struct * , unsigned long ) ; void ( * release_pte ) ( unsigned long ) ; void ( * release_pmd ) ( unsigned long ) ; void ( * release_pud ) ( unsigned long ) ; void ( * release_p4d ) ( unsigned long ) ; void ( * set_pte ) ( t#pte_t * , t#pte_t ) ; void ( * set_pmd ) ( t#pmd_t * , t#pmd_t ) ; t#pte_t ( * ptep_modify_prot_start ) ( s#vm_area_struct * , unsigned long , t#pte_t * ) ; void ( * ptep_modify_prot_commit ) ( s#vm_area_struct * , unsigned long , t#pte_t * , t#pte_t ) ; s#paravirt_callee_save pte_val ; s#paravirt_callee_save make_pte ; s#paravirt_callee_save pgd_val ; s#paravirt_callee_save make_pgd ; void ( * set_pud ) ( t#pud_t * , t#pud_t ) ; s#paravirt_callee_save pmd_val ; s#paravirt_callee_save make_pmd ; s#paravirt_callee_save pud_val ; s#paravirt_callee_save make_pud ; void ( * set_p4d ) ( t#p4d_t * , t#p4d_t ) ; s#paravirt_callee_save p4d_val ; s#paravirt_callee_save make_p4d ; void ( * set_pgd ) ( t#pgd_t * , t#pgd_t ) ; s#pv_lazy_ops lazy_mode ; void ( * set_fixmap ) ( unsigned , t#phys_addr_t , t#pgprot_t ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#qc_dqblk struct qc_dqblk { int d_fieldmask ; t#u64 d_spc_hardlimit ; t#u64 d_spc_softlimit ; t#u64 d_ino_hardlimit ; t#u64 d_ino_softlimit ; t#u64 d_space ; t#u64 d_ino_count ; t#s64 d_ino_timer ; t#s64 d_spc_timer ; int d_ino_warns ; int d_spc_warns ; t#u64 d_rt_spc_hardlimit ; t#u64 d_rt_spc_softlimit ; t#u64 d_rt_space ; t#s64 d_rt_spc_timer ; int d_rt_spc_warns ; }
s#qc_info struct qc_info { int i_fieldmask ; unsigned int i_flags ; unsigned int i_spc_timelimit ; unsigned int i_ino_timelimit ; unsigned int i_rt_spc_timelimit ; unsigned int i_spc_warnlimit ; unsigned int i_ino_warnlimit ; unsigned int i_rt_spc_warnlimit ; }
s#qc_state struct qc_state { unsigned int s_incoredqs ; s#qc_type_state s_state [ 3 ] ; }
s#qc_type_state struct qc_type_state { unsigned int flags ; unsigned int spc_timelimit ; unsigned int ino_timelimit ; unsigned int rt_spc_timelimit ; unsigned int spc_warnlimit ; unsigned int ino_warnlimit ; unsigned int rt_spc_warnlimit ; unsigned long long ino ; t#blkcnt_t blocks ; t#blkcnt_t nextents ; }
s#qdisc_size_table struct qdisc_size_table { s#callback_head rcu ; s#list_head list ; s#tc_sizespec szopts ; int refcnt ; t#u16 data [ ] ; }
s#qdisc_skb_head struct qdisc_skb_head { s#sk_buff * head ; s#sk_buff * tail ; t#__u32 qlen ; t#spinlock_t lock ; }
s#qdisc_walker@0594779d struct qdisc_walker { UNKNOWN }
s#qdisc_walker@231386e1 struct qdisc_walker { int stop ; int skip ; int count ; int ( * fn ) ( s#Qdisc * , unsigned long , s#qdisc_walker * ) ; }
s#qrwlock struct qrwlock { union { t#atomic_t cnts ; struct { t#u8 wlocked ; t#u8 __lstate [ 3 ] ; } ; } ; t#arch_spinlock_t wait_lock ; }
s#qspinlock struct qspinlock { union { t#atomic_t val ; struct { t#u8 locked ; t#u8 pending ; } ; struct { t#u16 locked_pending ; t#u16 tail ; } ; } ; }
s#qstr struct qstr { union { struct { t#u32 hash ; t#u32 len ; } ; t#u64 hash_len ; } ; const unsigned char * name ; }
s#queue_limits struct queue_limits { t#blk_features_t features ; t#blk_flags_t flags ; unsigned long seg_boundary_mask ; unsigned long virt_boundary_mask ; unsigned int max_hw_sectors ; unsigned int max_dev_sectors ; unsigned int chunk_sectors ; unsigned int max_sectors ; unsigned int max_user_sectors ; unsigned int max_segment_size ; unsigned int physical_block_size ; unsigned int logical_block_size ; unsigned int alignment_offset ; unsigned int io_min ; unsigned int io_opt ; unsigned int max_discard_sectors ; unsigned int max_hw_discard_sectors ; unsigned int max_user_discard_sectors ; unsigned int max_secure_erase_sectors ; unsigned int max_write_zeroes_sectors ; unsigned int max_zone_append_sectors ; unsigned int discard_granularity ; unsigned int discard_alignment ; unsigned int zone_write_granularity ; unsigned int atomic_write_hw_max ; unsigned int atomic_write_max_sectors ; unsigned int atomic_write_hw_boundary ; unsigned int atomic_write_boundary_sectors ; unsigned int atomic_write_hw_unit_min ; unsigned int atomic_write_unit_min ; unsigned int atomic_write_hw_unit_max ; unsigned int atomic_write_unit_max ; unsigned short max_segments ; unsigned short max_integrity_segments ; unsigned short max_discard_segments ; unsigned int max_open_zones ; unsigned int max_active_zones ; unsigned int dma_alignment ; unsigned int dma_pad_mask ; s#blk_integrity integrity ; }
s#quota_format_ops struct quota_format_ops { int ( * check_quota_file ) ( s#super_block * , int ) ; int ( * read_file_info ) ( s#super_block * , int ) ; int ( * write_file_info ) ( s#super_block * , int ) ; int ( * free_file_info ) ( s#super_block * , int ) ; int ( * read_dqblk ) ( s#dquot * ) ; int ( * commit_dqblk ) ( s#dquot * ) ; int ( * release_dqblk ) ( s#dquot * ) ; int ( * get_next_id ) ( s#super_block * , s#kqid * ) ; }
s#quota_format_type struct quota_format_type { int qf_fmt_id ; const s#quota_format_ops * qf_ops ; s#module * qf_owner ; s#quota_format_type * qf_next ; }
s#quota_info struct quota_info { unsigned int flags ; s#rw_semaphore dqio_sem ; s#inode * files [ 3 ] ; s#mem_dqinfo info [ 3 ] ; const s#quota_format_ops * ops [ 3 ] ; }
s#quotactl_ops struct quotactl_ops { int ( * quota_on ) ( s#super_block * , int , int , const s#path * ) ; int ( * quota_off ) ( s#super_block * , int ) ; int ( * quota_enable ) ( s#super_block * , unsigned int ) ; int ( * quota_disable ) ( s#super_block * , unsigned int ) ; int ( * quota_sync ) ( s#super_block * , int ) ; int ( * set_info ) ( s#super_block * , int , s#qc_info * ) ; int ( * get_dqblk ) ( s#super_block * , s#kqid , s#qc_dqblk * ) ; int ( * get_nextdqblk ) ( s#super_block * , s#kqid * , s#qc_dqblk * ) ; int ( * set_dqblk ) ( s#super_block * , s#kqid , s#qc_dqblk * ) ; int ( * get_state ) ( s#super_block * , s#qc_state * ) ; int ( * rm_xquota ) ( s#super_block * , unsigned int ) ; }
s#range struct range { t#u64 start ; t#u64 end ; }
s#rate_sample struct rate_sample { t#u64 prior_mstamp ; t#u32 prior_delivered ; t#u32 prior_delivered_ce ; t#s32 delivered ; t#s32 delivered_ce ; long interval_us ; t#u32 snd_interval_us ; t#u32 rcv_interval_us ; long rtt_us ; int losses ; t#u32 acked_sacked ; t#u32 prior_in_flight ; t#u32 last_end_seq ; t#bool is_app_limited ; t#bool is_retrans ; t#bool is_ack_delayed ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#ratelimit_state struct ratelimit_state { t#raw_spinlock_t lock ; int interval ; int burst ; int printed ; int missed ; unsigned int flags ; unsigned long begin ; }
s#raw_hashinfo@93e388d7 struct raw_hashinfo { t#spinlock_t lock ; s#hlist_head ht [ ( 1U << 8 ) ] __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; }
s#raw_hashinfo@98139727 struct raw_hashinfo { UNKNOWN }
s#raw_notifier_head struct raw_notifier_head { s#notifier_block * head ; }
s#raw_spinlock struct raw_spinlock { t#arch_spinlock_t raw_lock ; }
s#rb_node struct rb_node { unsigned long __rb_parent_color ; s#rb_node * rb_right ; s#rb_node * rb_left ; }
s#rb_root struct rb_root { s#rb_node * rb_node ; }
s#rb_root_cached struct rb_root_cached { s#rb_root rb_root ; s#rb_node * rb_leftmost ; }
s#rcec_ea@44428194 struct rcec_ea { t#u8 nextbusn ; t#u8 lastbusn ; t#u32 bitmap ; }
s#rcec_ea@e5415a95 struct rcec_ea { UNKNOWN }
s#rchan struct rchan { t#u32 version ; t#size_t subbuf_size ; t#size_t n_subbufs ; t#size_t alloc_size ; const s#rchan_callbacks * cb ; s#kref kref ; void * private_data ; t#size_t last_toobig ; s#rchan_buf * * buf ; int is_global ; s#list_head list ; s#dentry * parent ; int has_base_filename ; char base_filename [ 255 ] ; }
s#rchan_buf struct rchan_buf { void * start ; void * data ; t#size_t offset ; t#size_t subbufs_produced ; t#size_t subbufs_consumed ; s#rchan * chan ; t#wait_queue_head_t read_wait ; s#irq_work wakeup_work ; s#dentry * dentry ; s#kref kref ; s#page * * page_array ; unsigned int page_count ; unsigned int finalized ; t#size_t * padding ; t#size_t prev_padding ; t#size_t bytes_consumed ; t#size_t early_bytes ; unsigned int cpu ; }
s#rchan_callbacks struct rchan_callbacks { int ( * subbuf_start ) ( s#rchan_buf * , void * , void * , t#size_t ) ; s#dentry * ( * create_buf_file ) ( const char * , s#dentry * , t#umode_t , s#rchan_buf * , int * ) ; int ( * remove_buf_file ) ( s#dentry * ) ; }
s#rcu_node struct rcu_node { UNKNOWN }
s#rcu_segcblist struct rcu_segcblist { s#callback_head * head ; s#callback_head * * tails [ 4 ] ; unsigned long gp_seq [ 4 ] ; t#atomic_long_t len ; long seglen [ 4 ] ; t#u8 flags ; }
s#rcu_sync struct rcu_sync { int gp_state ; int gp_count ; t#wait_queue_head_t gp_wait ; s#callback_head cb_head ; }
s#rcu_work struct rcu_work { s#work_struct work ; s#callback_head rcu ; s#workqueue_struct * wq ; }
s#rcuwait struct rcuwait { s#task_struct * task ; }
s#rdma_addr struct rdma_addr { s#__kernel_sockaddr_storage src_addr ; s#__kernel_sockaddr_storage dst_addr ; s#rdma_dev_addr dev_addr ; }
s#rdma_ah_attr struct rdma_ah_attr { s#ib_global_route grh ; t#u8 sl ; t#u8 static_rate ; t#u32 port_num ; t#u8 ah_flags ; e#rdma_ah_attr_type type ; union { s#ib_ah_attr ib ; s#roce_ah_attr roce ; s#opa_ah_attr opa ; } ; }
s#rdma_ah_init_attr struct rdma_ah_init_attr { s#rdma_ah_attr * ah_attr ; t#u32 flags ; s#net_device * xmit_slave ; }
s#rdma_cgroup struct rdma_cgroup { s#cgroup_subsys_state css ; s#list_head rpools ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#rdma_cm_event struct rdma_cm_event { e#rdma_cm_event_type event ; int status ; union { s#rdma_conn_param conn ; s#rdma_ud_param ud ; } param ; s#rdma_ucm_ece ece ; }
s#rdma_cm_id@17980c24 struct rdma_cm_id { s#ib_device * device ; void * context ; s#ib_qp * qp ; t#rdma_cm_event_handler event_handler ; s#rdma_route route ; e#rdma_ucm_port_space ps ; e#ib_qp_type qp_type ; t#u32 port_num ; s#work_struct net_work ; }
s#rdma_cm_id@f27efa45 struct rdma_cm_id { UNKNOWN }
s#rdma_conn_param struct rdma_conn_param { const void * private_data ; t#u8 private_data_len ; t#u8 responder_resources ; t#u8 initiator_depth ; t#u8 flow_control ; t#u8 retry_count ; t#u8 rnr_retry_count ; t#u8 srq ; t#u32 qp_num ; t#u32 qkey ; }
s#rdma_counter struct rdma_counter { s#rdma_restrack_entry res ; s#ib_device * device ; t#uint32_t id ; s#kref kref ; s#rdma_counter_mode mode ; s#mutex lock ; s#rdma_hw_stats * stats ; t#u32 port ; }
s#rdma_counter_mode struct rdma_counter_mode { e#rdma_nl_counter_mode mode ; e#rdma_nl_counter_mask mask ; s#auto_mode_param param ; }
s#rdma_dev_addr struct rdma_dev_addr { unsigned char src_dev_addr [ 32 ] ; unsigned char dst_dev_addr [ 32 ] ; unsigned char broadcast [ 32 ] ; unsigned short dev_type ; int bound_dev_if ; e#rdma_transport_type transport ; s#net * net ; const s#ib_gid_attr * sgid_attr ; e#rdma_network_type network ; int hoplimit ; }
s#rdma_hw_stats struct rdma_hw_stats { s#mutex lock ; unsigned long timestamp ; unsigned long lifespan ; const s#rdma_stat_desc * descs ; unsigned long * is_disabled ; int num_counters ; t#u64 value [ ] ; }
s#rdma_link_ops struct rdma_link_ops { s#list_head list ; const char * type ; int ( * newlink ) ( const char * , s#net_device * ) ; }
s#rdma_netdev_alloc_params struct rdma_netdev_alloc_params { t#size_t sizeof_priv ; unsigned int txqs ; unsigned int rxqs ; void * param ; int ( * initialize_rdma_netdev ) ( s#ib_device * , t#u32 , s#net_device * , void * ) ; }
s#rdma_port_counter struct rdma_port_counter { s#rdma_counter_mode mode ; s#rdma_hw_stats * hstats ; unsigned int num_counters ; s#mutex lock ; }
s#rdma_restrack_entry struct rdma_restrack_entry { t#bool valid ; t#u8 no_track : 1 ; s#kref kref ; s#completion comp ; s#task_struct * task ; const char * kern_name ; e#rdma_restrack_type type ; t#bool user ; t#u32 id ; }
s#rdma_restrack_root@087f8068 struct rdma_restrack_root { UNKNOWN }
s#rdma_restrack_root@a71c51db struct rdma_restrack_root { s#xarray xa ; t#u32 next_id ; }
s#rdma_route struct rdma_route { s#rdma_addr addr ; s#sa_path_rec * path_rec ; s#sa_path_rec * path_rec_inbound ; s#sa_path_rec * path_rec_outbound ; int num_pri_alt_paths ; }
s#rdma_stat_desc struct rdma_stat_desc { const char * name ; unsigned int flags ; const void * priv ; }
s#rdma_ucm_ece struct rdma_ucm_ece { t#__u32 vendor_id ; t#__u32 attr_mod ; }
s#rdma_ud_param struct rdma_ud_param { const void * private_data ; t#u8 private_data_len ; s#rdma_ah_attr ah_attr ; t#u32 qp_num ; t#u32 qkey ; }
s#rdma_user_mmap_entry struct rdma_user_mmap_entry { s#kref ref ; s#ib_ucontext * ucontext ; unsigned long start_pgoff ; t#size_t npages ; t#bool driver_removed ; }
s#rdmacg_device struct rdmacg_device { s#list_head dev_node ; s#list_head rpools ; char * name ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#readahead_control@489c99e4 struct readahead_control { s#file * file ; s#address_space * mapping ; s#file_ra_state * ra ; unsigned long _index ; unsigned int _nr_pages ; unsigned int _batch_count ; t#bool _workingset ; unsigned long _pflags ; }
s#readahead_control@81e0c38a struct readahead_control { UNKNOWN }
s#reciprocal_value struct reciprocal_value { t#u32 m ; t#u8 sh1 , sh2 ; }
s#reclaim_state@038189e0 struct reclaim_state { unsigned long reclaimed ; s#lru_gen_mm_walk * mm_walk ; }
s#reclaim_state@8708b031 struct reclaim_state { UNKNOWN }
s#ref_tracker_dir struct ref_tracker_dir { }
s#refcount_struct struct refcount_struct { t#atomic_t refs ; }
s#regulatory_request struct regulatory_request { s#callback_head callback_head ; int wiphy_idx ; e#nl80211_reg_initiator initiator ; e#nl80211_user_reg_hint_type user_reg_hint_type ; char alpha2 [ 3 ] ; e#nl80211_dfs_regions dfs_region ; t#bool intersect ; t#bool processed ; e#environment_cap country_ie_env ; s#list_head list ; }
s#renamedata struct renamedata { s#mnt_idmap * old_mnt_idmap ; s#inode * old_dir ; s#dentry * old_dentry ; s#mnt_idmap * new_mnt_idmap ; s#inode * new_dir ; s#dentry * new_dentry ; s#inode * * delegated_inode ; unsigned int flags ; }
s#request@003e27a0 struct request { s#request_queue * q ; s#blk_mq_ctx * mq_ctx ; s#blk_mq_hw_ctx * mq_hctx ; t#blk_opf_t cmd_flags ; t#req_flags_t rq_flags ; int tag ; int internal_tag ; unsigned int timeout ; unsigned int __data_len ; t#sector_t __sector ; s#bio * bio ; s#bio * biotail ; union { s#list_head queuelist ; s#request * rq_next ; } ; s#block_device * part ; t#u64 start_time_ns ; t#u64 io_start_time_ns ; unsigned short wbt_flags ; unsigned short stats_sectors ; unsigned short nr_phys_segments ; unsigned short nr_integrity_segments ; e#rw_hint write_hint ; unsigned short ioprio ; e#mq_rq_state state ; t#atomic_t ref ; unsigned long deadline ; union { s#hlist_node hash ; s#llist_node ipi_list ; } ; union { s#rb_node rb_node ; s#bio_vec special_vec ; } ; struct { s#io_cq * icq ; void * priv [ 2 ] ; } elv ; struct { unsigned int seq ; t#rq_end_io_fn * saved_end_io ; } flush ; t#u64 fifo_time ; t#rq_end_io_fn * end_io ; void * end_io_data ; }
s#request@6ee74121 struct request { UNKNOWN }
s#request_queue@4916233f struct request_queue { UNKNOWN }
s#request_queue@75629dc9 struct request_queue { void * queuedata ; s#elevator_queue * elevator ; const s#blk_mq_ops * mq_ops ; s#blk_mq_ctx * queue_ctx ; unsigned long queue_flags ; unsigned int rq_timeout ; unsigned int queue_depth ; t#refcount_t refs ; unsigned int nr_hw_queues ; s#xarray hctx_table ; s#percpu_ref q_usage_counter ; s#lock_class_key io_lock_cls_key ; s#lockdep_map io_lockdep_map ; s#lock_class_key q_lock_cls_key ; s#lockdep_map q_lockdep_map ; s#request * last_merge ; t#spinlock_t queue_lock ; int quiesce_depth ; s#gendisk * disk ; s#kobject * mq_kobj ; s#queue_limits limits ; s#device * dev ; e#rpm_status rpm_status ; t#atomic_t pm_only ; s#blk_queue_stats * stats ; s#rq_qos * rq_qos ; s#mutex rq_qos_mutex ; int id ; unsigned long nr_requests ; s#timer_list timeout ; s#work_struct timeout_work ; t#atomic_t nr_active_requests_shared_tags ; s#blk_mq_tags * sched_shared_tags ; s#list_head icq_list ; unsigned long blkcg_pols [ ( ( ( 6 ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; s#blkcg_gq * root_blkg ; s#list_head blkg_list ; s#mutex blkcg_mutex ; int node ; t#spinlock_t requeue_lock ; s#list_head requeue_list ; s#delayed_work requeue_work ; s#blk_trace * blk_trace ; s#blk_flush_queue * fq ; s#list_head flush_list ; s#mutex sysfs_lock ; s#mutex sysfs_dir_lock ; s#mutex limits_lock ; s#list_head unused_hctx_list ; t#spinlock_t unused_hctx_lock ; int mq_freeze_depth ; s#throtl_data * td ; s#callback_head callback_head ; t#wait_queue_head_t mq_freeze_wq ; s#mutex mq_freeze_lock ; s#blk_mq_tag_set * tag_set ; s#list_head tag_set_list ; s#dentry * debugfs_dir ; s#dentry * sched_debugfs_dir ; s#dentry * rqos_debugfs_dir ; s#mutex debugfs_mutex ; t#bool mq_sysfs_init_done ; }
s#request_sock@b3c35828 struct request_sock { UNKNOWN }
s#request_sock@e1990980 struct request_sock { s#sock_common __req_common ; s#request_sock * dl_next ; t#u16 mss ; t#u8 num_retrans ; t#u8 syncookie : 1 ; t#u8 num_timeout : 7 ; t#u32 ts_recent ; s#timer_list rsk_timer ; const s#request_sock_ops * rsk_ops ; s#sock * sk ; s#saved_syn * saved_syn ; t#u32 secid ; t#u32 peer_secid ; t#u32 timeout ; }
s#request_sock_ops@b37b346c struct request_sock_ops { UNKNOWN }
s#request_sock_ops@ec1ce132 struct request_sock_ops { int family ; unsigned int obj_size ; s#kmem_cache * slab ; char * slab_name ; int ( * rtx_syn_ack ) ( const s#sock * , s#request_sock * ) ; void ( * send_ack ) ( const s#sock * , s#sk_buff * , s#request_sock * ) ; void ( * send_reset ) ( const s#sock * , s#sk_buff * , e#sk_rst_reason ) ; void ( * destructor ) ( s#request_sock * ) ; void ( * syn_ack_timeout ) ( const s#request_sock * ) ; }
s#reset_control struct reset_control { UNKNOWN }
s#resource struct resource { t#resource_size_t start ; t#resource_size_t end ; const char * name ; unsigned long flags ; unsigned long desc ; s#resource * parent , * sibling , * child ; }
s#restart_block struct restart_block { unsigned long arch_data ; long ( * fn ) ( s#restart_block * ) ; union { struct { t#u32 * uaddr ; t#u32 val ; t#u32 flags ; t#u32 bitset ; t#u64 time ; t#u32 * uaddr2 ; } futex ; struct { t#clockid_t clockid ; e#timespec_type type ; union { s#__kernel_timespec * rmtp ; s#old_timespec32 * compat_rmtp ; } ; t#u64 expires ; } nanosleep ; struct { s#pollfd * ufds ; int nfds ; int has_timeout ; unsigned long tv_sec ; unsigned long tv_nsec ; } poll ; } ; }
s#return_instance struct return_instance { s#uprobe * uprobe ; unsigned long func ; unsigned long stack ; unsigned long orig_ret_vaddr ; t#bool chained ; s#return_instance * next ; }
s#rfkill struct rfkill { UNKNOWN }
s#rhash_head struct rhash_head { s#rhash_head * next ; }
s#rhash_lock_head struct rhash_lock_head { }
s#rhashtable struct rhashtable { s#bucket_table * tbl ; unsigned int key_len ; unsigned int max_elems ; s#rhashtable_params p ; t#bool rhlist ; s#work_struct run_work ; s#mutex mutex ; t#spinlock_t lock ; t#atomic_t nelems ; }
s#rhashtable_compare_arg struct rhashtable_compare_arg { s#rhashtable * ht ; const void * key ; }
s#rhashtable_params struct rhashtable_params { t#u16 nelem_hint ; t#u16 key_len ; t#u16 key_offset ; t#u16 head_offset ; unsigned int max_size ; t#u16 min_size ; t#bool automatic_shrinking ; t#rht_hashfn_t hashfn ; t#rht_obj_hashfn_t obj_hashfn ; t#rht_obj_cmpfn_t obj_cmpfn ; }
s#rhlist_head struct rhlist_head { s#rhash_head rhead ; s#rhlist_head * next ; }
s#ring_buffer_iter struct ring_buffer_iter { UNKNOWN }
s#rlimit struct rlimit { t#__kernel_ulong_t rlim_cur ; t#__kernel_ulong_t rlim_max ; }
s#robust_list struct robust_list { s#robust_list * next ; }
s#robust_list_head@0e27a833 struct robust_list_head { UNKNOWN }
s#robust_list_head@eb94c81f struct robust_list_head { s#robust_list list ; long futex_offset ; s#robust_list * list_op_pending ; }
s#roce_ah_attr struct roce_ah_attr { t#u8 dmac [ 6 ] ; }
s#root_domain struct root_domain { t#atomic_t refcount ; t#atomic_t rto_count ; s#callback_head rcu ; t#cpumask_var_t span ; t#cpumask_var_t online ; t#bool overloaded ; t#bool overutilized ; t#cpumask_var_t dlo_mask ; t#atomic_t dlo_count ; s#dl_bw dl_bw ; s#cpudl cpudl ; t#u64 visit_gen ; s#irq_work rto_push_work ; t#raw_spinlock_t rto_lock ; int rto_loop ; int rto_cpu ; t#atomic_t rto_loop_next ; t#atomic_t rto_loop_start ; t#cpumask_var_t rto_mask ; s#cpupri cpupri ; s#perf_domain * pd ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; }
s#rpc_auth struct rpc_auth { unsigned int au_cslack ; unsigned int au_rslack ; unsigned int au_verfsize ; unsigned int au_ralign ; unsigned long au_flags ; const s#rpc_authops * au_ops ; t#rpc_authflavor_t au_flavor ; t#refcount_t au_count ; s#rpc_cred_cache * au_credcache ; }
s#rpc_auth_create_args struct rpc_auth_create_args { t#rpc_authflavor_t pseudoflavor ; const char * target_name ; }
s#rpc_authops struct rpc_authops { s#module * owner ; t#rpc_authflavor_t au_flavor ; char * au_name ; s#rpc_auth * ( * create ) ( const s#rpc_auth_create_args * , s#rpc_clnt * ) ; void ( * destroy ) ( s#rpc_auth * ) ; int ( * hash_cred ) ( s#auth_cred * , unsigned int ) ; s#rpc_cred * ( * lookup_cred ) ( s#rpc_auth * , s#auth_cred * , int ) ; s#rpc_cred * ( * crcreate ) ( s#rpc_auth * , s#auth_cred * , int , t#gfp_t ) ; t#rpc_authflavor_t ( * info2flavor ) ( s#rpcsec_gss_info * ) ; int ( * flavor2info ) ( t#rpc_authflavor_t , s#rpcsec_gss_info * ) ; int ( * key_timeout ) ( s#rpc_auth * , s#rpc_cred * ) ; int ( * ping ) ( s#rpc_clnt * ) ; }
s#rpc_call_ops struct rpc_call_ops { void ( * rpc_call_prepare ) ( s#rpc_task * , void * ) ; void ( * rpc_call_done ) ( s#rpc_task * , void * ) ; void ( * rpc_count_stats ) ( s#rpc_task * , void * ) ; void ( * rpc_release ) ( void * ) ; }
s#rpc_clnt struct rpc_clnt { t#refcount_t cl_count ; unsigned int cl_clid ; s#list_head cl_clients ; s#list_head cl_tasks ; t#atomic_t cl_pid ; t#spinlock_t cl_lock ; s#rpc_xprt * cl_xprt ; const s#rpc_procinfo * cl_procinfo ; t#u32 cl_prog , cl_vers , cl_maxproc ; s#rpc_auth * cl_auth ; s#rpc_stat * cl_stats ; s#rpc_iostats * cl_metrics ; unsigned int cl_softrtry : 1 , cl_softerr : 1 , cl_discrtry : 1 , cl_noretranstimeo : 1 , cl_autobind : 1 , cl_chatty : 1 , cl_shutdown : 1 ; s#xprtsec_parms cl_xprtsec ; s#rpc_rtt * cl_rtt ; const s#rpc_timeout * cl_timeout ; t#atomic_t cl_swapper ; int cl_nodelen ; char cl_nodename [ 64 + 1 ] ; s#rpc_pipe_dir_head cl_pipedir_objects ; s#rpc_clnt * cl_parent ; s#rpc_rtt cl_rtt_default ; s#rpc_timeout cl_timeout_default ; const s#rpc_program * cl_program ; const char * cl_principal ; s#dentry * cl_debugfs ; s#rpc_sysfs_client * cl_sysfs ; union { s#rpc_xprt_iter cl_xpi ; s#work_struct cl_work ; } ; const s#cred * cl_cred ; unsigned int cl_max_connect ; s#super_block * pipefs_sb ; }
s#rpc_cred struct rpc_cred { s#hlist_node cr_hash ; s#list_head cr_lru ; s#callback_head cr_rcu ; s#rpc_auth * cr_auth ; const s#rpc_credops * cr_ops ; unsigned long cr_expire ; unsigned long cr_flags ; t#refcount_t cr_count ; const s#cred * cr_cred ; }
s#rpc_cred_cache struct rpc_cred_cache { UNKNOWN }
s#rpc_credops struct rpc_credops { const char * cr_name ; int ( * cr_init ) ( s#rpc_auth * , s#rpc_cred * ) ; void ( * crdestroy ) ( s#rpc_cred * ) ; int ( * crmatch ) ( s#auth_cred * , s#rpc_cred * , int ) ; int ( * crmarshal ) ( s#rpc_task * , s#xdr_stream * ) ; int ( * crrefresh ) ( s#rpc_task * ) ; int ( * crvalidate ) ( s#rpc_task * , s#xdr_stream * ) ; int ( * crwrap_req ) ( s#rpc_task * , s#xdr_stream * ) ; int ( * crunwrap_resp ) ( s#rpc_task * , s#xdr_stream * ) ; int ( * crkey_timeout ) ( s#rpc_cred * ) ; char * ( * crstringify_acceptor ) ( s#rpc_cred * ) ; t#bool ( * crneed_reencode ) ( s#rpc_task * ) ; }
s#rpc_iostats@e5f706f3 struct rpc_iostats { UNKNOWN }
s#rpc_iostats@ebd9e936 struct rpc_iostats { t#spinlock_t om_lock ; unsigned long om_ops , om_ntrans , om_timeouts ; unsigned long long om_bytes_sent , om_bytes_recv ; t#ktime_t om_queue , om_rtt , om_execute ; unsigned long om_error_status ; }
s#rpc_message struct rpc_message { const s#rpc_procinfo * rpc_proc ; void * rpc_argp ; void * rpc_resp ; const s#cred * rpc_cred ; }
s#rpc_pipe_dir_head struct rpc_pipe_dir_head { s#list_head pdh_entries ; s#dentry * pdh_dentry ; }
s#rpc_procinfo struct rpc_procinfo { t#u32 p_proc ; t#kxdreproc_t p_encode ; t#kxdrdproc_t p_decode ; unsigned int p_arglen ; unsigned int p_replen ; unsigned int p_timer ; t#u32 p_statidx ; const char * p_name ; }
s#rpc_program struct rpc_program { const char * name ; t#u32 number ; unsigned int nrvers ; const s#rpc_version * * version ; s#rpc_stat * stats ; const char * pipe_dir_name ; }
s#rpc_rqst@05b006a7 struct rpc_rqst { UNKNOWN }
s#rpc_rqst@ef2ab9dc struct rpc_rqst { s#rpc_xprt * rq_xprt ; s#xdr_buf rq_snd_buf ; s#xdr_buf rq_rcv_buf ; s#rpc_task * rq_task ; s#rpc_cred * rq_cred ; t#__be32 rq_xid ; int rq_cong ; t#u32 rq_seqno ; int rq_enc_pages_num ; s#page * * rq_enc_pages ; void ( * rq_release_snd_buf ) ( s#rpc_rqst * ) ; union { s#list_head rq_list ; s#rb_node rq_recv ; } ; s#list_head rq_xmit ; s#list_head rq_xmit2 ; void * rq_buffer ; t#size_t rq_callsize ; void * rq_rbuffer ; t#size_t rq_rcvsize ; t#size_t rq_xmit_bytes_sent ; t#size_t rq_reply_bytes_recvd ; s#xdr_buf rq_private_buf ; unsigned long rq_majortimeo ; unsigned long rq_minortimeo ; unsigned long rq_timeout ; t#ktime_t rq_rtt ; unsigned int rq_retries ; unsigned int rq_connect_cookie ; t#atomic_t rq_pin ; t#u32 rq_bytes_sent ; t#ktime_t rq_xtime ; int rq_ntrans ; s#lwq_node rq_bc_list ; unsigned long rq_bc_pa_state ; s#list_head rq_bc_pa_list ; }
s#rpc_rtt struct rpc_rtt { unsigned long timeo ; unsigned long srtt [ 5 ] ; unsigned long sdrtt [ 5 ] ; int ntimeouts [ 5 ] ; }
s#rpc_stat struct rpc_stat { const s#rpc_program * program ; unsigned int netcnt , netudpcnt , nettcpcnt , nettcpconn , netreconn ; unsigned int rpccnt , rpcretrans , rpcauthrefresh , rpcgarbage ; }
s#rpc_sysfs_client struct rpc_sysfs_client { s#kobject kobject ; s#net * net ; s#rpc_clnt * clnt ; s#rpc_xprt_switch * xprt_switch ; }
s#rpc_sysfs_xprt@5fa4ab48 struct rpc_sysfs_xprt { s#kobject kobject ; s#rpc_xprt * xprt ; s#rpc_xprt_switch * xprt_switch ; }
s#rpc_sysfs_xprt@8f1abc95 struct rpc_sysfs_xprt { UNKNOWN }
s#rpc_sysfs_xprt_switch@7373ed2c struct rpc_sysfs_xprt_switch { UNKNOWN }
s#rpc_sysfs_xprt_switch@ee99971b struct rpc_sysfs_xprt_switch { s#kobject kobject ; s#net * net ; s#rpc_xprt_switch * xprt_switch ; s#rpc_xprt * xprt ; }
s#rpc_task struct rpc_task { t#atomic_t tk_count ; int tk_status ; s#list_head tk_task ; void ( * tk_callback ) ( s#rpc_task * ) ; void ( * tk_action ) ( s#rpc_task * ) ; unsigned long tk_timeout ; unsigned long tk_runstate ; s#rpc_wait_queue * tk_waitqueue ; union { s#work_struct tk_work ; s#rpc_wait tk_wait ; } u ; s#rpc_message tk_msg ; void * tk_calldata ; const s#rpc_call_ops * tk_ops ; s#rpc_clnt * tk_client ; s#rpc_xprt * tk_xprt ; s#rpc_cred * tk_op_cred ; s#rpc_rqst * tk_rqstp ; s#workqueue_struct * tk_workqueue ; t#ktime_t tk_start ; t#pid_t tk_owner ; int tk_rpc_status ; unsigned short tk_flags ; unsigned short tk_timeouts ; unsigned short tk_pid ; unsigned char tk_priority : 2 , tk_garb_retry : 2 , tk_cred_retry : 2 ; }
s#rpc_task_setup struct rpc_task_setup { s#rpc_task * task ; s#rpc_clnt * rpc_client ; s#rpc_xprt * rpc_xprt ; s#rpc_cred * rpc_op_cred ; const s#rpc_message * rpc_message ; const s#rpc_call_ops * callback_ops ; void * callback_data ; s#workqueue_struct * workqueue ; unsigned short flags ; signed char priority ; }
s#rpc_timeout struct rpc_timeout { unsigned long to_initval , to_maxval , to_increment ; unsigned int to_retries ; unsigned char to_exponential ; }
s#rpc_timer struct rpc_timer { s#list_head list ; unsigned long expires ; s#delayed_work dwork ; }
s#rpc_version struct rpc_version { t#u32 number ; unsigned int nrprocs ; const s#rpc_procinfo * procs ; unsigned int * counts ; }
s#rpc_wait struct rpc_wait { s#list_head list ; s#list_head links ; s#list_head timer_list ; }
s#rpc_wait_queue struct rpc_wait_queue { t#spinlock_t lock ; s#list_head tasks [ ( 1 + ( 2 ) - ( - 1 ) ) ] ; unsigned char maxpriority ; unsigned char priority ; unsigned char nr ; unsigned int qlen ; s#rpc_timer timer_list ; const char * name ; }
s#rpc_xprt struct rpc_xprt { s#kref kref ; const s#rpc_xprt_ops * ops ; unsigned int id ; const s#rpc_timeout * timeout ; s#__kernel_sockaddr_storage addr ; t#size_t addrlen ; int prot ; unsigned long cong ; unsigned long cwnd ; t#size_t max_payload ; s#rpc_wait_queue binding ; s#rpc_wait_queue sending ; s#rpc_wait_queue pending ; s#rpc_wait_queue backlog ; s#list_head free ; unsigned int max_reqs ; unsigned int min_reqs ; unsigned int num_reqs ; unsigned long state ; unsigned char resvport : 1 , reuseport : 1 ; t#atomic_t swapper ; unsigned int bind_index ; s#list_head xprt_switch ; unsigned long bind_timeout , reestablish_timeout ; s#xprtsec_parms xprtsec ; unsigned int connect_cookie ; s#work_struct task_cleanup ; s#timer_list timer ; unsigned long last_used , idle_timeout , connect_timeout , max_reconnect_timeout ; t#atomic_long_t queuelen ; t#spinlock_t transport_lock ; t#spinlock_t reserve_lock ; t#spinlock_t queue_lock ; t#u32 xid ; s#rpc_task * snd_task ; s#list_head xmit_queue ; t#atomic_long_t xmit_queuelen ; s#svc_xprt * bc_xprt ; s#svc_serv * bc_serv ; unsigned int bc_alloc_max ; unsigned int bc_alloc_count ; t#atomic_t bc_slot_count ; t#spinlock_t bc_pa_lock ; s#list_head bc_pa_list ; s#rb_root recv_queue ; struct { unsigned long bind_count , connect_count , connect_start , connect_time , sends , recvs , bad_xids , max_slots ; unsigned long long req_u , bklog_u , sending_u , pending_u ; } stat ; s#net * xprt_net ; t#netns_tracker ns_tracker ; const char * servername ; const char * address_strings [ E#RPC_DISPLAY_MAX ] ; s#dentry * debugfs ; s#callback_head rcu ; const s#xprt_class * xprt_class ; s#rpc_sysfs_xprt * xprt_sysfs ; t#bool main ; }
s#rpc_xprt_iter struct rpc_xprt_iter { s#rpc_xprt_switch * xpi_xpswitch ; s#rpc_xprt * xpi_cursor ; const s#rpc_xprt_iter_ops * xpi_ops ; }
s#rpc_xprt_iter_ops struct rpc_xprt_iter_ops { void ( * xpi_rewind ) ( s#rpc_xprt_iter * ) ; s#rpc_xprt * ( * xpi_xprt ) ( s#rpc_xprt_iter * ) ; s#rpc_xprt * ( * xpi_next ) ( s#rpc_xprt_iter * ) ; }
s#rpc_xprt_ops struct rpc_xprt_ops { void ( * set_buffer_size ) ( s#rpc_xprt * , t#size_t , t#size_t ) ; int ( * reserve_xprt ) ( s#rpc_xprt * , s#rpc_task * ) ; void ( * release_xprt ) ( s#rpc_xprt * , s#rpc_task * ) ; void ( * alloc_slot ) ( s#rpc_xprt * , s#rpc_task * ) ; void ( * free_slot ) ( s#rpc_xprt * , s#rpc_rqst * ) ; void ( * rpcbind ) ( s#rpc_task * ) ; void ( * set_port ) ( s#rpc_xprt * , unsigned short ) ; void ( * connect ) ( s#rpc_xprt * , s#rpc_task * ) ; int ( * get_srcaddr ) ( s#rpc_xprt * , char * , t#size_t ) ; unsigned short ( * get_srcport ) ( s#rpc_xprt * ) ; int ( * buf_alloc ) ( s#rpc_task * ) ; void ( * buf_free ) ( s#rpc_task * ) ; int ( * prepare_request ) ( s#rpc_rqst * , s#xdr_buf * ) ; int ( * send_request ) ( s#rpc_rqst * ) ; void ( * abort_send_request ) ( s#rpc_rqst * ) ; void ( * wait_for_reply_request ) ( s#rpc_task * ) ; void ( * timer ) ( s#rpc_xprt * , s#rpc_task * ) ; void ( * release_request ) ( s#rpc_task * ) ; void ( * close ) ( s#rpc_xprt * ) ; void ( * destroy ) ( s#rpc_xprt * ) ; void ( * set_connect_timeout ) ( s#rpc_xprt * , unsigned long , unsigned long ) ; void ( * print_stats ) ( s#rpc_xprt * , s#seq_file * ) ; int ( * enable_swap ) ( s#rpc_xprt * ) ; void ( * disable_swap ) ( s#rpc_xprt * ) ; void ( * inject_disconnect ) ( s#rpc_xprt * ) ; int ( * bc_setup ) ( s#rpc_xprt * , unsigned int ) ; t#size_t ( * bc_maxpayload ) ( s#rpc_xprt * ) ; unsigned int ( * bc_num_slots ) ( s#rpc_xprt * ) ; void ( * bc_free_rqst ) ( s#rpc_rqst * ) ; void ( * bc_destroy ) ( s#rpc_xprt * , unsigned int ) ; }
s#rpc_xprt_switch struct rpc_xprt_switch { t#spinlock_t xps_lock ; s#kref xps_kref ; unsigned int xps_id ; unsigned int xps_nxprts ; unsigned int xps_nactive ; unsigned int xps_nunique_destaddr_xprts ; t#atomic_long_t xps_queuelen ; s#list_head xps_xprt_list ; s#net * xps_net ; const s#rpc_xprt_iter_ops * xps_iter_ops ; s#rpc_sysfs_xprt_switch * xps_sysfs ; s#callback_head xps_rcu ; }
s#rpcsec_gss_info struct rpcsec_gss_info { s#rpcsec_gss_oid oid ; t#u32 qop ; t#u32 service ; }
s#rpcsec_gss_oid struct rpcsec_gss_oid { unsigned int len ; t#u8 data [ 32 ] ; }
s#rps_dev_flow struct rps_dev_flow { t#u16 cpu ; t#u16 filter ; unsigned int last_qtail ; }
s#rps_dev_flow_table@aed201c2 struct rps_dev_flow_table { UNKNOWN }
s#rps_dev_flow_table@f5372905 struct rps_dev_flow_table { unsigned int mask ; s#callback_head rcu ; s#rps_dev_flow flows [ ] ; }
s#rps_map@002f460c struct rps_map { unsigned int len ; s#callback_head rcu ; t#u16 cpus [ ] ; }
s#rps_map@04cef073 struct rps_map { UNKNOWN }
s#rq@624278e3 struct rq { t#raw_spinlock_t __lock ; unsigned int nr_running ; unsigned int nr_numa_running ; unsigned int nr_preferred_running ; unsigned int numa_migrate_on ; unsigned long last_blocked_load_update_tick ; unsigned int has_blocked_load ; t#call_single_data_t nohz_csd ; unsigned int nohz_tick_stopped ; t#atomic_t nohz_flags ; unsigned int ttwu_pending ; t#u64 nr_switches ; s#cfs_rq cfs ; s#rt_rq rt ; s#dl_rq dl ; s#scx_rq scx ; s#sched_dl_entity fair_server ; s#list_head leaf_cfs_rq_list ; s#list_head * tmp_alone_branch ; unsigned int nr_uninterruptible ; s#task_struct * curr ; s#sched_dl_entity * dl_server ; s#task_struct * idle ; s#task_struct * stop ; unsigned long next_balance ; s#mm_struct * prev_mm ; unsigned int clock_update_flags ; t#u64 clock ; t#u64 clock_task __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; t#u64 clock_pelt ; unsigned long lost_idle_time ; t#u64 clock_pelt_idle ; t#u64 clock_idle ; t#atomic_t nr_iowait ; t#u64 last_seen_need_resched_ns ; int ticks_without_resched ; int membarrier_state ; s#root_domain * rd ; s#sched_domain * sd ; unsigned long cpu_capacity ; s#balance_callback * balance_callback ; unsigned char nohz_idle_balance ; unsigned char idle_balance ; unsigned long misfit_task_load ; int active_balance ; int push_cpu ; s#cpu_stop_work active_balance_work ; int cpu ; int online ; s#list_head cfs_tasks ; s#sched_avg avg_rt ; s#sched_avg avg_dl ; s#sched_avg avg_irq ; t#u64 idle_stamp ; t#u64 avg_idle ; t#u64 max_idle_balance_cost ; s#rcuwait hotplug_wait ; t#u64 prev_irq_time ; t#u64 psi_irq_time ; t#u64 prev_steal_time ; t#u64 prev_steal_time_rq ; unsigned long calc_load_update ; long calc_load_active ; t#call_single_data_t hrtick_csd ; s#hrtimer hrtick_timer ; t#ktime_t hrtick_time ; s#sched_info rq_sched_info ; unsigned long long rq_cpu_time ; unsigned int yld_count ; unsigned int sched_count ; unsigned int sched_goidle ; unsigned int ttwu_count ; unsigned int ttwu_local ; s#cpuidle_state * idle_state ; unsigned int nr_pinned ; unsigned int push_busy ; s#cpu_stop_work push_work ; s#rq * core ; s#task_struct * core_pick ; s#sched_dl_entity * core_dl_server ; unsigned int core_enabled ; unsigned int core_sched_seq ; s#rb_root core_tree ; unsigned int core_task_seq ; unsigned int core_pick_seq ; unsigned long core_cookie ; unsigned int core_forceidle_count ; unsigned int core_forceidle_seq ; unsigned int core_forceidle_occupation ; t#u64 core_forceidle_start ; t#cpumask_var_t scratch_mask ; t#call_single_data_t cfsb_csd ; s#list_head cfsb_csd_list ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#rq@defa9c61 struct rq { UNKNOWN }
s#rq_flags struct rq_flags { unsigned long flags ; s#pin_cookie cookie ; unsigned int clock_update_flags ; }
s#rq_qos@0cb844b7 struct rq_qos { UNKNOWN }
s#rq_qos@353020bc struct rq_qos { const s#rq_qos_ops * ops ; s#gendisk * disk ; e#rq_qos_id id ; s#rq_qos * next ; s#dentry * debugfs_dir ; }
s#rq_qos_ops struct rq_qos_ops { void ( * throttle ) ( s#rq_qos * , s#bio * ) ; void ( * track ) ( s#rq_qos * , s#request * , s#bio * ) ; void ( * merge ) ( s#rq_qos * , s#request * , s#bio * ) ; void ( * issue ) ( s#rq_qos * , s#request * ) ; void ( * requeue ) ( s#rq_qos * , s#request * ) ; void ( * done ) ( s#rq_qos * , s#request * ) ; void ( * done_bio ) ( s#rq_qos * , s#bio * ) ; void ( * cleanup ) ( s#rq_qos * , s#bio * ) ; void ( * queue_depth_changed ) ( s#rq_qos * ) ; void ( * exit ) ( s#rq_qos * ) ; const s#blk_mq_debugfs_attr * debugfs_attrs ; }
s#rseq struct rseq { t#__u32 cpu_id_start ; t#__u32 cpu_id ; t#__u64 rseq_cs ; t#__u32 flags ; t#__u32 node_id ; t#__u32 mm_cid ; char end [ ] ; }
s#rt6_exception_bucket struct rt6_exception_bucket { s#hlist_head chain ; int depth ; }
s#rt6_info@ba0d0e7c struct rt6_info { UNKNOWN }
s#rt6_info@c74dcddd struct rt6_info { s#dst_entry dst ; s#fib6_info * from ; int sernum ; s#rt6key rt6i_dst ; s#rt6key rt6i_src ; s#in6_addr rt6i_gateway ; s#inet6_dev * rt6i_idev ; t#u32 rt6i_flags ; unsigned short rt6i_nfheader_len ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#rt6_statistics@1738033f struct rt6_statistics { UNKNOWN }
s#rt6_statistics@553b91e2 struct rt6_statistics { t#__u32 fib_nodes ; t#__u32 fib_route_nodes ; t#__u32 fib_rt_entries ; t#__u32 fib_rt_cache ; t#__u32 fib_discarded_routes ; t#atomic_t fib_rt_alloc ; }
s#rt6key struct rt6key { s#in6_addr addr ; int plen ; }
s#rt_mutex_base struct rt_mutex_base { t#raw_spinlock_t wait_lock ; s#rb_root_cached waiters ; s#task_struct * owner ; }
s#rt_mutex_waiter@4ecc90be struct rt_mutex_waiter { s#rt_waiter_node tree ; s#rt_waiter_node pi_tree ; s#task_struct * task ; s#rt_mutex_base * lock ; unsigned int wake_state ; s#ww_acquire_ctx * ww_ctx ; }
s#rt_mutex_waiter@aa7a31a4 struct rt_mutex_waiter { UNKNOWN }
s#rt_prio_array struct rt_prio_array { unsigned long bitmap [ ( ( ( 100 + 1 ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; s#list_head queue [ 100 ] ; }
s#rt_rq struct rt_rq { s#rt_prio_array active ; unsigned int rt_nr_running ; unsigned int rr_nr_running ; struct { int curr ; int next ; } highest_prio ; t#bool overloaded ; s#plist_head pushable_tasks ; int rt_queued ; }
s#rt_waiter_node struct rt_waiter_node { s#rb_node entry ; int prio ; t#u64 deadline ; }
s#rtable struct rtable { s#dst_entry dst ; int rt_genid ; unsigned int rt_flags ; t#__u16 rt_type ; t#__u8 rt_is_input ; t#__u8 rt_uses_gateway ; int rt_iif ; t#u8 rt_gw_family ; union { t#__be32 rt_gw4 ; s#in6_addr rt_gw6 ; } ; t#u32 rt_mtu_locked : 1 , rt_pmtu : 31 ; }
s#rtattr@b5a4bef5 struct rtattr { UNKNOWN }
s#rtattr@b72713e9 struct rtattr { unsigned short rta_len ; unsigned short rta_type ; }
s#rtnl_hw_stats64 struct rtnl_hw_stats64 { t#__u64 rx_packets ; t#__u64 tx_packets ; t#__u64 rx_bytes ; t#__u64 tx_bytes ; t#__u64 rx_errors ; t#__u64 tx_errors ; t#__u64 rx_dropped ; t#__u64 tx_dropped ; t#__u64 multicast ; }
s#rtnl_link_ops@1c901e6b struct rtnl_link_ops { s#list_head list ; const char * kind ; t#size_t priv_size ; s#net_device * ( * alloc ) ( s#nlattr * [ ] , const char * , unsigned char , unsigned int , unsigned int ) ; void ( * setup ) ( s#net_device * ) ; t#bool netns_refund ; unsigned int maxtype ; const s#nla_policy * policy ; int ( * validate ) ( s#nlattr * [ ] , s#nlattr * [ ] , s#netlink_ext_ack * ) ; int ( * newlink ) ( s#net * , s#net_device * , s#nlattr * [ ] , s#nlattr * [ ] , s#netlink_ext_ack * ) ; int ( * changelink ) ( s#net_device * , s#nlattr * [ ] , s#nlattr * [ ] , s#netlink_ext_ack * ) ; void ( * dellink ) ( s#net_device * , s#list_head * ) ; t#size_t ( * get_size ) ( const s#net_device * ) ; int ( * fill_info ) ( s#sk_buff * , const s#net_device * ) ; t#size_t ( * get_xstats_size ) ( const s#net_device * ) ; int ( * fill_xstats ) ( s#sk_buff * , const s#net_device * ) ; unsigned int ( * get_num_tx_queues ) ( void ) ; unsigned int ( * get_num_rx_queues ) ( void ) ; unsigned int slave_maxtype ; const s#nla_policy * slave_policy ; int ( * slave_changelink ) ( s#net_device * , s#net_device * , s#nlattr * [ ] , s#nlattr * [ ] , s#netlink_ext_ack * ) ; t#size_t ( * get_slave_size ) ( const s#net_device * , const s#net_device * ) ; int ( * fill_slave_info ) ( s#sk_buff * , const s#net_device * , const s#net_device * ) ; s#net * ( * get_link_net ) ( const s#net_device * ) ; t#size_t ( * get_linkxstats_size ) ( const s#net_device * , int ) ; int ( * fill_linkxstats ) ( s#sk_buff * , const s#net_device * , int * , int ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; }
s#rtnl_link_ops@8affdff9 struct rtnl_link_ops { UNKNOWN }
s#rtnl_link_stats64 struct rtnl_link_stats64 { t#__u64 rx_packets ; t#__u64 tx_packets ; t#__u64 rx_bytes ; t#__u64 tx_bytes ; t#__u64 rx_errors ; t#__u64 tx_errors ; t#__u64 rx_dropped ; t#__u64 tx_dropped ; t#__u64 multicast ; t#__u64 collisions ; t#__u64 rx_length_errors ; t#__u64 rx_over_errors ; t#__u64 rx_crc_errors ; t#__u64 rx_frame_errors ; t#__u64 rx_fifo_errors ; t#__u64 rx_missed_errors ; t#__u64 tx_aborted_errors ; t#__u64 tx_carrier_errors ; t#__u64 tx_fifo_errors ; t#__u64 tx_heartbeat_errors ; t#__u64 tx_window_errors ; t#__u64 rx_compressed ; t#__u64 tx_compressed ; t#__u64 rx_nohandler ; t#__u64 rx_otherhost_dropped ; }
s#rw_semaphore struct rw_semaphore { t#atomic_long_t count ; t#atomic_long_t owner ; s#optimistic_spin_queue osq ; t#raw_spinlock_t wait_lock ; s#list_head wait_list ; }
s#sa_path_rec struct sa_path_rec { u#ib_gid dgid ; u#ib_gid sgid ; t#__be64 service_id ; t#__be32 flow_label ; t#u8 hop_limit ; t#u8 traffic_class ; t#u8 reversible ; t#u8 numb_path ; t#__be16 pkey ; t#__be16 qos_class ; t#u8 sl ; t#u8 mtu_selector ; t#u8 mtu ; t#u8 rate_selector ; t#u8 rate ; t#u8 packet_life_time_selector ; t#u8 packet_life_time ; t#u8 preference ; union { s#sa_path_rec_ib ib ; s#sa_path_rec_roce roce ; s#sa_path_rec_opa opa ; } ; e#sa_path_rec_type rec_type ; t#u32 flags ; }
s#sa_path_rec_ib struct sa_path_rec_ib { t#__be16 dlid ; t#__be16 slid ; t#u8 raw_traffic ; }
s#sa_path_rec_opa struct sa_path_rec_opa { t#__be32 dlid ; t#__be32 slid ; t#u8 raw_traffic ; t#u8 l2_8B ; t#u8 l2_10B ; t#u8 l2_9B ; t#u8 l2_16B ; t#u8 qos_type ; t#u8 qos_priority ; }
s#sa_path_rec_roce struct sa_path_rec_roce { t#bool route_resolved ; t#u8 dmac [ 6 ] ; }
s#sas_function_template struct sas_function_template { int ( * get_linkerrors ) ( s#sas_phy * ) ; int ( * get_enclosure_identifier ) ( s#sas_rphy * , t#u64 * ) ; int ( * get_bay_identifier ) ( s#sas_rphy * ) ; int ( * phy_reset ) ( s#sas_phy * , int ) ; int ( * phy_enable ) ( s#sas_phy * , int ) ; int ( * phy_setup ) ( s#sas_phy * ) ; void ( * phy_release ) ( s#sas_phy * ) ; int ( * set_phy_speed ) ( s#sas_phy * , s#sas_phy_linkrates * ) ; void ( * smp_handler ) ( s#bsg_job * , s#Scsi_Host * , s#sas_rphy * ) ; }
s#sas_identify struct sas_identify { e#sas_device_type device_type ; e#sas_protocol initiator_port_protocols ; e#sas_protocol target_port_protocols ; t#u64 sas_address ; t#u8 phy_identifier ; }
s#sas_phy struct sas_phy { s#device dev ; int number ; int enabled ; s#sas_identify identify ; e#sas_linkrate negotiated_linkrate ; e#sas_linkrate minimum_linkrate_hw ; e#sas_linkrate minimum_linkrate ; e#sas_linkrate maximum_linkrate_hw ; e#sas_linkrate maximum_linkrate ; t#u32 invalid_dword_count ; t#u32 running_disparity_error_count ; t#u32 loss_of_dword_sync_count ; t#u32 phy_reset_problem_count ; s#list_head port_siblings ; void * hostdata ; }
s#sas_phy_linkrates struct sas_phy_linkrates { e#sas_linkrate maximum_linkrate ; e#sas_linkrate minimum_linkrate ; }
s#sas_port struct sas_port { s#device dev ; int port_identifier ; int num_phys ; unsigned int is_backlink : 1 ; s#sas_rphy * rphy ; s#mutex phy_list_mutex ; s#list_head phy_list ; s#list_head del_list ; }
s#sas_rphy struct sas_rphy { s#device dev ; s#sas_identify identify ; s#list_head list ; s#request_queue * q ; t#u32 scsi_target_id ; }
s#saved_syn struct saved_syn { t#u32 mac_hdrlen ; t#u32 network_hdrlen ; t#u32 tcp_hdrlen ; t#u8 data [ ] ; }
s#sb_writers struct sb_writers { unsigned short frozen ; int freeze_kcount ; int freeze_ucount ; s#percpu_rw_semaphore rw_sem [ ( E#SB_FREEZE_COMPLETE - 1 ) ] ; }
s#sbitmap struct sbitmap { unsigned int depth ; unsigned int shift ; unsigned int map_nr ; t#bool round_robin ; s#sbitmap_word * map ; unsigned int * alloc_hint ; }
s#sbitmap_queue struct sbitmap_queue { s#sbitmap sb ; unsigned int wake_batch ; t#atomic_t wake_index ; s#sbq_wait_state * ws ; t#atomic_t ws_active ; unsigned int min_shallow_depth ; t#atomic_t completion_cnt ; t#atomic_t wakeup_cnt ; }
s#sbitmap_word struct sbitmap_word { unsigned long word ; unsigned long cleared __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; t#raw_spinlock_t swap_lock ; }
s#sbq_wait_state struct sbq_wait_state { t#wait_queue_head_t wait ; }
s#scatterlist@183eecfb struct scatterlist { unsigned long page_link ; unsigned int offset ; unsigned int length ; t#dma_addr_t dma_address ; unsigned int dma_length ; unsigned int dma_flags ; }
s#scatterlist@e4644bed struct scatterlist { UNKNOWN }
s#sched_avg struct sched_avg { t#u64 last_update_time ; t#u64 load_sum ; t#u64 runnable_sum ; t#u32 util_sum ; t#u32 period_contrib ; unsigned long load_avg ; unsigned long runnable_avg ; unsigned long util_avg ; unsigned int util_est ; }
s#sched_class@05ccdc2b struct sched_class { UNKNOWN }
s#sched_class@df8cc923 struct sched_class { t#u8 state ; t#u8 idx ; s#ch_sched_params info ; e#sched_bind_type bind_type ; s#list_head entry_list ; t#atomic_t refcnt ; }
s#sched_class@ed2df786 struct sched_class { void ( * enqueue_task ) ( s#rq * , s#task_struct * , int ) ; t#bool ( * dequeue_task ) ( s#rq * , s#task_struct * , int ) ; void ( * yield_task ) ( s#rq * ) ; t#bool ( * yield_to_task ) ( s#rq * , s#task_struct * ) ; void ( * wakeup_preempt ) ( s#rq * , s#task_struct * , int ) ; int ( * balance ) ( s#rq * , s#task_struct * , s#rq_flags * ) ; s#task_struct * ( * pick_task ) ( s#rq * ) ; s#task_struct * ( * pick_next_task ) ( s#rq * , s#task_struct * ) ; void ( * put_prev_task ) ( s#rq * , s#task_struct * , s#task_struct * ) ; void ( * set_next_task ) ( s#rq * , s#task_struct * , t#bool ) ; int ( * select_task_rq ) ( s#task_struct * , int , int ) ; void ( * migrate_task_rq ) ( s#task_struct * , int ) ; void ( * task_woken ) ( s#rq * , s#task_struct * ) ; void ( * set_cpus_allowed ) ( s#task_struct * , s#affinity_context * ) ; void ( * rq_online ) ( s#rq * ) ; void ( * rq_offline ) ( s#rq * ) ; s#rq * ( * find_lock_rq ) ( s#task_struct * , s#rq * ) ; void ( * task_tick ) ( s#rq * , s#task_struct * , int ) ; void ( * task_fork ) ( s#task_struct * ) ; void ( * task_dead ) ( s#task_struct * ) ; void ( * switching_to ) ( s#rq * , s#task_struct * ) ; void ( * switched_from ) ( s#rq * , s#task_struct * ) ; void ( * switched_to ) ( s#rq * , s#task_struct * ) ; void ( * reweight_task ) ( s#rq * , s#task_struct * , const s#load_weight * ) ; void ( * prio_changed ) ( s#rq * , s#task_struct * , int ) ; unsigned int ( * get_rr_interval ) ( s#rq * , s#task_struct * ) ; void ( * update_curr ) ( s#rq * ) ; void ( * task_change_group ) ( s#task_struct * ) ; int ( * task_is_throttled ) ( s#task_struct * , int ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#sched_dl_entity struct sched_dl_entity { s#rb_node rb_node ; t#u64 dl_runtime ; t#u64 dl_deadline ; t#u64 dl_period ; t#u64 dl_bw ; t#u64 dl_density ; t#s64 runtime ; t#u64 deadline ; unsigned int flags ; unsigned int dl_throttled : 1 ; unsigned int dl_yielded : 1 ; unsigned int dl_non_contending : 1 ; unsigned int dl_overrun : 1 ; unsigned int dl_server : 1 ; unsigned int dl_server_active : 1 ; unsigned int dl_defer : 1 ; unsigned int dl_defer_armed : 1 ; unsigned int dl_defer_running : 1 ; s#hrtimer dl_timer ; s#hrtimer inactive_timer ; s#rq * rq ; t#dl_server_has_tasks_f server_has_tasks ; t#dl_server_pick_f server_pick_task ; s#sched_dl_entity * pi_se ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#sched_domain struct sched_domain { s#sched_domain * parent ; s#sched_domain * child ; s#sched_group * groups ; unsigned long min_interval ; unsigned long max_interval ; unsigned int busy_factor ; unsigned int imbalance_pct ; unsigned int cache_nice_tries ; unsigned int imb_numa_nr ; int nohz_idle ; int flags ; int level ; unsigned long last_balance ; unsigned int balance_interval ; unsigned int nr_balance_failed ; t#u64 max_newidle_lb_cost ; unsigned long last_decay_max_lb_cost ; unsigned int lb_count [ E#CPU_MAX_IDLE_TYPES ] ; unsigned int lb_failed [ E#CPU_MAX_IDLE_TYPES ] ; unsigned int lb_balanced [ E#CPU_MAX_IDLE_TYPES ] ; unsigned int lb_imbalance [ E#CPU_MAX_IDLE_TYPES ] ; unsigned int lb_gained [ E#CPU_MAX_IDLE_TYPES ] ; unsigned int lb_hot_gained [ E#CPU_MAX_IDLE_TYPES ] ; unsigned int lb_nobusyg [ E#CPU_MAX_IDLE_TYPES ] ; unsigned int lb_nobusyq [ E#CPU_MAX_IDLE_TYPES ] ; unsigned int alb_count ; unsigned int alb_failed ; unsigned int alb_pushed ; unsigned int sbe_count ; unsigned int sbe_balanced ; unsigned int sbe_pushed ; unsigned int sbf_count ; unsigned int sbf_balanced ; unsigned int sbf_pushed ; unsigned int ttwu_wake_remote ; unsigned int ttwu_move_affine ; unsigned int ttwu_move_balance ; char * name ; union { void * private ; s#callback_head rcu ; } ; s#sched_domain_shared * shared ; unsigned int span_weight ; unsigned long span [ ] ; }
s#sched_domain_shared struct sched_domain_shared { t#atomic_t ref ; t#atomic_t nr_busy_cpus ; int has_idle_cores ; int nr_idle_scan ; unsigned long uek_reserved1 ; }
s#sched_entity struct sched_entity { s#load_weight load ; s#rb_node run_node ; t#u64 deadline ; t#u64 min_vruntime ; t#u64 min_slice ; s#list_head group_node ; unsigned char on_rq ; unsigned char sched_delayed ; unsigned char rel_deadline ; unsigned char custom_slice ; t#u64 exec_start ; t#u64 sum_exec_runtime ; t#u64 prev_sum_exec_runtime ; t#u64 vruntime ; t#s64 vlag ; t#u64 slice ; t#u64 nr_migrations ; int depth ; s#sched_entity * parent ; s#cfs_rq * cfs_rq ; s#cfs_rq * my_q ; unsigned long runnable_weight ; s#sched_avg avg ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#sched_ext_entity struct sched_ext_entity { s#scx_dispatch_q * dsq ; s#scx_dsq_list_node dsq_list ; s#rb_node dsq_priq ; t#u32 dsq_seq ; t#u32 dsq_flags ; t#u32 flags ; t#u32 weight ; t#s32 sticky_cpu ; t#s32 holding_cpu ; t#u32 kf_mask ; s#task_struct * kf_tasks [ 2 ] ; t#atomic_long_t ops_state ; s#list_head runnable_node ; unsigned long runnable_at ; t#u64 core_sched_at ; t#u64 ddsp_dsq_id ; t#u64 ddsp_enq_flags ; t#u64 slice ; t#u64 dsq_vtime ; t#bool disallow ; s#cgroup * cgrp_moving_from ; s#list_head tasks_node ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; }
s#sched_group struct sched_group { s#sched_group * next ; t#atomic_t ref ; unsigned int group_weight ; unsigned int cores ; s#sched_group_capacity * sgc ; int asym_prefer_cpu ; int flags ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long cpumask [ ] ; }
s#sched_group_capacity struct sched_group_capacity { t#atomic_t ref ; unsigned long capacity ; unsigned long min_capacity ; unsigned long max_capacity ; unsigned long next_update ; int imbalance ; int id ; unsigned long cpumask [ ] ; }
s#sched_info struct sched_info { unsigned long pcount ; unsigned long long run_delay ; unsigned long long last_arrival ; unsigned long long last_queued ; }
s#sched_rt_entity struct sched_rt_entity { s#list_head run_list ; unsigned long timeout ; unsigned long watchdog_stamp ; unsigned int time_slice ; unsigned short on_rq ; unsigned short on_list ; s#sched_rt_entity * back ; }
s#sched_statistics struct sched_statistics { t#u64 wait_start ; t#u64 wait_max ; t#u64 wait_count ; t#u64 wait_sum ; t#u64 iowait_count ; t#u64 iowait_sum ; t#u64 sleep_start ; t#u64 sleep_max ; t#s64 sum_sleep_runtime ; t#u64 block_start ; t#u64 block_max ; t#s64 sum_block_runtime ; t#s64 exec_max ; t#u64 slice_max ; t#u64 nr_migrations_cold ; t#u64 nr_failed_migrations_affine ; t#u64 nr_failed_migrations_running ; t#u64 nr_failed_migrations_hot ; t#u64 nr_forced_migrations ; t#u64 nr_wakeups ; t#u64 nr_wakeups_sync ; t#u64 nr_wakeups_migrate ; t#u64 nr_wakeups_local ; t#u64 nr_wakeups_remote ; t#u64 nr_wakeups_affine ; t#u64 nr_wakeups_affine_attempts ; t#u64 nr_wakeups_passive ; t#u64 nr_wakeups_idle ; t#u64 nr_preempt_delay_granted ; t#u64 core_forceidle_sum ; }
s#scsi_cmnd@59823f46 struct scsi_cmnd { UNKNOWN }
s#scsi_cmnd@d9d0b114 struct scsi_cmnd { s#scsi_device * device ; s#list_head eh_entry ; s#delayed_work abort_work ; s#callback_head rcu ; int eh_eflags ; int budget_token ; unsigned long jiffies_at_alloc ; int retries ; int allowed ; unsigned char prot_op ; unsigned char prot_type ; unsigned char prot_flags ; e#scsi_cmnd_submitter submitter ; unsigned short cmd_len ; e#dma_data_direction sc_data_direction ; unsigned char cmnd [ 32 ] ; s#scsi_data_buffer sdb ; s#scsi_data_buffer * prot_sdb ; unsigned underflow ; unsigned transfersize ; unsigned resid_len ; unsigned sense_len ; unsigned char * sense_buffer ; int flags ; unsigned long state ; unsigned int extra_len ; unsigned char * host_scribble ; int result ; }
s#scsi_data_buffer struct scsi_data_buffer { s#sg_table table ; unsigned length ; }
s#scsi_device@230e9e54 struct scsi_device { UNKNOWN }
s#scsi_device@3ad13230 struct scsi_device { s#Scsi_Host * host ; s#request_queue * request_queue ; s#list_head siblings ; s#list_head same_target_siblings ; s#sbitmap budget_map ; t#atomic_t device_blocked ; t#atomic_t restarts ; t#spinlock_t list_lock ; s#list_head starved_entry ; unsigned short queue_depth ; unsigned short max_queue_depth ; unsigned short last_queue_full_depth ; unsigned short last_queue_full_count ; unsigned long last_queue_full_time ; unsigned long queue_ramp_up_period ; unsigned long last_queue_ramp_up ; unsigned int id , channel ; t#u64 lun ; unsigned int manufacturer ; unsigned sector_size ; void * hostdata ; unsigned char type ; char scsi_level ; char inq_periph_qual ; s#mutex inquiry_mutex ; unsigned char inquiry_len ; unsigned char * inquiry ; const char * vendor ; const char * model ; const char * rev ; s#scsi_vpd * vpd_pg0 ; s#scsi_vpd * vpd_pg83 ; s#scsi_vpd * vpd_pg80 ; s#scsi_vpd * vpd_pg89 ; s#scsi_vpd * vpd_pgb0 ; s#scsi_vpd * vpd_pgb1 ; s#scsi_vpd * vpd_pgb2 ; s#scsi_vpd * vpd_pgb7 ; s#scsi_target * sdev_target ; t#blist_flags_t sdev_bflags ; unsigned int eh_timeout ; unsigned manage_system_start_stop : 1 ; unsigned manage_runtime_start_stop : 1 ; unsigned manage_shutdown : 1 ; unsigned force_runtime_start_on_system_start : 1 ; unsigned removable : 1 ; unsigned changed : 1 ; unsigned busy : 1 ; unsigned lockable : 1 ; unsigned locked : 1 ; unsigned borken : 1 ; unsigned disconnect : 1 ; unsigned soft_reset : 1 ; unsigned sdtr : 1 ; unsigned wdtr : 1 ; unsigned ppr : 1 ; unsigned tagged_supported : 1 ; unsigned simple_tags : 1 ; unsigned was_reset : 1 ; unsigned expecting_cc_ua : 1 ; unsigned use_10_for_rw : 1 ; unsigned use_10_for_ms : 1 ; unsigned set_dbd_for_ms : 1 ; unsigned read_before_ms : 1 ; unsigned no_report_opcodes : 1 ; unsigned no_write_same : 1 ; unsigned use_16_for_rw : 1 ; unsigned use_16_for_sync : 1 ; unsigned skip_ms_page_8 : 1 ; unsigned skip_ms_page_3f : 1 ; unsigned skip_vpd_pages : 1 ; unsigned try_vpd_pages : 1 ; unsigned use_192_bytes_for_3f : 1 ; unsigned no_start_on_add : 1 ; unsigned allow_restart : 1 ; unsigned start_stop_pwr_cond : 1 ; unsigned no_uld_attach : 1 ; unsigned select_no_atn : 1 ; unsigned fix_capacity : 1 ; unsigned guess_capacity : 1 ; unsigned retry_hwerror : 1 ; unsigned last_sector_bug : 1 ; unsigned no_read_disc_info : 1 ; unsigned no_read_capacity_16 : 1 ; unsigned try_rc_10_first : 1 ; unsigned security_supported : 1 ; unsigned is_visible : 1 ; unsigned wce_default_on : 1 ; unsigned no_dif : 1 ; unsigned broken_fua : 1 ; unsigned lun_in_cdb : 1 ; unsigned unmap_limit_for_ws : 1 ; unsigned rpm_autosuspend : 1 ; unsigned ignore_media_change : 1 ; unsigned silence_suspend : 1 ; unsigned no_vpd_size : 1 ; unsigned cdl_supported : 1 ; unsigned cdl_enable : 1 ; unsigned int queue_stopped ; t#bool offline_already ; t#atomic_t disk_events_disable_depth ; unsigned long supported_events [ ( ( ( E#SDEV_EVT_MAXBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; unsigned long pending_events [ ( ( ( E#SDEV_EVT_MAXBITS ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; s#list_head event_list ; s#work_struct event_work ; unsigned int max_device_blocked ; t#atomic_t iorequest_cnt ; t#atomic_t iodone_cnt ; t#atomic_t ioerr_cnt ; t#atomic_t iotmo_cnt ; s#device sdev_gendev , sdev_dev ; s#work_struct requeue_work ; s#scsi_device_handler * handler ; void * handler_data ; t#size_t dma_drain_len ; void * dma_drain_buf ; unsigned int sg_timeout ; unsigned int sg_reserved_size ; s#bsg_device * bsg_dev ; unsigned char access_state ; s#mutex state_mutex ; e#scsi_device_state sdev_state ; s#task_struct * quiesced_by ; unsigned long sdev_data [ ] ; }
s#scsi_device_handler@2fa82fb9 struct scsi_device_handler { UNKNOWN }
s#scsi_device_handler@a8de8a13 struct scsi_device_handler { s#list_head list ; s#module * module ; const char * name ; e#scsi_disposition ( * check_sense ) ( s#scsi_device * , s#scsi_sense_hdr * ) ; int ( * attach ) ( s#scsi_device * ) ; void ( * detach ) ( s#scsi_device * ) ; int ( * activate ) ( s#scsi_device * , t#activate_complete , void * ) ; t#blk_status_t ( * prep_fn ) ( s#scsi_device * , s#request * ) ; int ( * set_params ) ( s#scsi_device * , const char * ) ; void ( * rescan ) ( s#scsi_device * ) ; }
s#scsi_host_template struct scsi_host_template { unsigned int cmd_size ; int ( * queuecommand ) ( s#Scsi_Host * , s#scsi_cmnd * ) ; void ( * commit_rqs ) ( s#Scsi_Host * , t#u16 ) ; s#module * module ; const char * name ; const char * ( * info ) ( s#Scsi_Host * ) ; int ( * ioctl ) ( s#scsi_device * , unsigned int , void * ) ; int ( * compat_ioctl ) ( s#scsi_device * , unsigned int , void * ) ; int ( * init_cmd_priv ) ( s#Scsi_Host * , s#scsi_cmnd * ) ; int ( * exit_cmd_priv ) ( s#Scsi_Host * , s#scsi_cmnd * ) ; int ( * eh_abort_handler ) ( s#scsi_cmnd * ) ; int ( * eh_device_reset_handler ) ( s#scsi_cmnd * ) ; int ( * eh_target_reset_handler ) ( s#scsi_cmnd * ) ; int ( * eh_bus_reset_handler ) ( s#scsi_cmnd * ) ; int ( * eh_host_reset_handler ) ( s#scsi_cmnd * ) ; int ( * slave_alloc ) ( s#scsi_device * ) ; int ( * device_configure ) ( s#scsi_device * , s#queue_limits * ) ; int ( * slave_configure ) ( s#scsi_device * ) ; void ( * slave_destroy ) ( s#scsi_device * ) ; int ( * target_alloc ) ( s#scsi_target * ) ; void ( * target_destroy ) ( s#scsi_target * ) ; int ( * scan_finished ) ( s#Scsi_Host * , unsigned long ) ; void ( * scan_start ) ( s#Scsi_Host * ) ; int ( * change_queue_depth ) ( s#scsi_device * , int ) ; void ( * map_queues ) ( s#Scsi_Host * ) ; int ( * mq_poll ) ( s#Scsi_Host * , unsigned int ) ; t#bool ( * dma_need_drain ) ( s#request * ) ; int ( * bios_param ) ( s#scsi_device * , s#block_device * , t#sector_t , int [ ] ) ; void ( * unlock_native_capacity ) ( s#scsi_device * ) ; int ( * show_info ) ( s#seq_file * , s#Scsi_Host * ) ; int ( * write_info ) ( s#Scsi_Host * , char * , int ) ; e#scsi_timeout_action ( * eh_timed_out ) ( s#scsi_cmnd * ) ; t#bool ( * eh_should_retry_cmd ) ( s#scsi_cmnd * ) ; int ( * host_reset ) ( s#Scsi_Host * , int ) ; const char * proc_name ; int can_queue ; int this_id ; unsigned short sg_tablesize ; unsigned short sg_prot_tablesize ; unsigned int max_sectors ; unsigned int max_segment_size ; unsigned int dma_alignment ; unsigned long dma_boundary ; unsigned long virt_boundary_mask ; short cmd_per_lun ; int tag_alloc_policy ; unsigned track_queue_depth : 1 ; unsigned supported_mode : 2 ; unsigned emulated : 1 ; unsigned skip_settle_delay : 1 ; unsigned no_write_same : 1 ; unsigned host_tagset : 1 ; unsigned queuecommand_may_block : 1 ; unsigned int max_host_blocked ; const s#attribute_group * * shost_groups ; const s#attribute_group * * sdev_groups ; t#u64 vendor_id ; }
s#scsi_lun struct scsi_lun { t#__u8 scsi_lun [ 8 ] ; }
s#scsi_sense_hdr struct scsi_sense_hdr { t#u8 response_code ; t#u8 sense_key ; t#u8 asc ; t#u8 ascq ; t#u8 byte4 ; t#u8 byte5 ; t#u8 byte6 ; t#u8 additional_length ; }
s#scsi_target@7a80b23c struct scsi_target { UNKNOWN }
s#scsi_target@aa610dc7 struct scsi_target { s#scsi_device * starget_sdev_user ; s#list_head siblings ; s#list_head devices ; s#device dev ; s#kref reap_ref ; unsigned int channel ; unsigned int id ; unsigned int create : 1 ; unsigned int single_lun : 1 ; unsigned int pdt_1f_for_no_lun : 1 ; unsigned int no_report_luns : 1 ; unsigned int expecting_lun_change : 1 ; t#atomic_t target_busy ; t#atomic_t target_blocked ; unsigned int can_queue ; unsigned int max_target_blocked ; char scsi_level ; e#scsi_target_state state ; void * hostdata ; unsigned long starget_data [ ] ; }
s#scsi_transport_template@45ac62e3 struct scsi_transport_template { UNKNOWN }
s#scsi_transport_template@4cdd7909 struct scsi_transport_template { s#transport_container host_attrs ; s#transport_container target_attrs ; s#transport_container device_attrs ; int ( * user_scan ) ( s#Scsi_Host * , t#uint , t#uint , t#u64 ) ; int device_size ; int device_private_offset ; int target_size ; int target_private_offset ; int host_size ; unsigned int create_work_queue : 1 ; void ( * eh_strategy_handler ) ( s#Scsi_Host * ) ; }
s#scsi_vpd struct scsi_vpd { s#callback_head rcu ; int len ; unsigned char data [ ] ; }
s#sctp_mib@44a56c3f struct sctp_mib { unsigned long mibs [ E#__SCTP_MIB_MAX ] ; }
s#sctp_mib@9b8f12f8 struct sctp_mib { UNKNOWN }
s#scx_dispatch_q struct scx_dispatch_q { t#raw_spinlock_t lock ; s#list_head list ; s#rb_root priq ; t#u32 nr ; t#u32 seq ; t#u64 id ; s#rhash_head hash_node ; s#llist_node free_node ; s#callback_head rcu ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#scx_dsq_list_node struct scx_dsq_list_node { s#list_head node ; t#u32 flags ; t#u32 priv ; }
s#scx_rq struct scx_rq { s#scx_dispatch_q local_dsq ; s#list_head runnable_list ; s#list_head ddsp_deferred_locals ; unsigned long ops_qseq ; t#u64 extra_enq_flags ; t#u32 nr_running ; t#u32 flags ; t#u32 cpuperf_target ; t#bool cpu_released ; t#cpumask_var_t cpus_to_kick ; t#cpumask_var_t cpus_to_kick_if_idle ; t#cpumask_var_t cpus_to_preempt ; t#cpumask_var_t cpus_to_wait ; unsigned long pnt_seq ; s#balance_callback deferred_bal_cb ; s#irq_work deferred_irq_work ; s#irq_work kick_cpus_irq_work ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#seccomp struct seccomp { int mode ; t#atomic_t filter_count ; s#seccomp_filter * filter ; }
s#seccomp_filter struct seccomp_filter { UNKNOWN }
s#seg6_pernet_data@eb2e9422 struct seg6_pernet_data { UNKNOWN }
s#seg6_pernet_data@ee92c854 struct seg6_pernet_data { s#mutex lock ; s#in6_addr * tun_src ; }
s#sem_undo_list struct sem_undo_list { UNKNOWN }
s#semaphore struct semaphore { t#raw_spinlock_t lock ; unsigned int count ; s#list_head wait_list ; }
s#seq_buf struct seq_buf { char * buffer ; t#size_t size ; t#size_t len ; }
s#seq_file@9257e8df struct seq_file { char * buf ; t#size_t size ; t#size_t from ; t#size_t count ; t#size_t pad_until ; t#loff_t index ; t#loff_t read_pos ; s#mutex lock ; const s#seq_operations * op ; int poll_event ; const s#file * file ; void * private ; }
s#seq_file@9afb65e4 struct seq_file { UNKNOWN }
s#seq_operations@08363422 struct seq_operations { UNKNOWN }
s#seq_operations@af352468 struct seq_operations { void * ( * start ) ( s#seq_file * , t#loff_t * ) ; void ( * stop ) ( s#seq_file * , void * ) ; void * ( * next ) ( s#seq_file * , void * , t#loff_t * ) ; int ( * show ) ( s#seq_file * , void * ) ; }
s#seqcount struct seqcount { unsigned sequence ; }
s#seqcount_raw_spinlock struct seqcount_raw_spinlock { t#seqcount_t seqcount ; ; }
s#seqcount_spinlock struct seqcount_spinlock { t#seqcount_t seqcount ; ; }
s#serial_icounter_struct@07c098b2 struct serial_icounter_struct { int cts , dsr , rng , dcd ; int rx , tx ; int frame , overrun , parity , brk ; int buf_overrun ; int reserved [ 9 ] ; }
s#serial_icounter_struct@d94a6582 struct serial_icounter_struct { UNKNOWN }
s#serial_struct@0187e4b2 struct serial_struct { UNKNOWN }
s#serial_struct@e37eacf1 struct serial_struct { int type ; int line ; unsigned int port ; int irq ; int flags ; int xmit_fifo_size ; int custom_divisor ; int baud_base ; unsigned short close_delay ; char io_type ; char reserved_char [ 1 ] ; int hub6 ; unsigned short closing_wait ; unsigned short closing_wait2 ; unsigned char * iomem_base ; unsigned short iomem_reg_shift ; unsigned int port_high ; unsigned long iomap_base ; }
s#sfp_bus struct sfp_bus { UNKNOWN }
s#sg_table@81d73f88 struct sg_table { s#scatterlist * sgl ; unsigned int nents ; unsigned int orig_nents ; }
s#sg_table@bad89e92 struct sg_table { UNKNOWN }
s#shrink_control struct shrink_control { t#gfp_t gfp_mask ; int nid ; unsigned long nr_to_scan ; unsigned long nr_scanned ; s#mem_cgroup * memcg ; }
s#shrinker struct shrinker { unsigned long ( * count_objects ) ( s#shrinker * , s#shrink_control * ) ; unsigned long ( * scan_objects ) ( s#shrinker * , s#shrink_control * ) ; long batch ; int seeks ; unsigned flags ; t#refcount_t refcount ; s#completion done ; s#callback_head rcu ; void * private_data ; s#list_head list ; int id ; t#atomic_long_t * nr_deferred ; }
s#shrinker_info struct shrinker_info { s#callback_head rcu ; int map_nr_max ; s#shrinker_info_unit * unit [ ] ; }
s#shrinker_info_unit struct shrinker_info_unit { t#atomic_long_t nr_deferred [ 64 ] ; unsigned long map [ ( ( ( 64 ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; }
s#sigaction struct sigaction { t#__sighandler_t sa_handler ; unsigned long sa_flags ; t#__sigrestore_t sa_restorer ; t#sigset_t sa_mask ; }
s#sighand_struct@7ec6c431 struct sighand_struct { t#spinlock_t siglock ; t#refcount_t count ; t#wait_queue_head_t signalfd_wqh ; s#k_sigaction action [ 64 ] ; }
s#sighand_struct@e097dc66 struct sighand_struct { UNKNOWN }
s#signal_struct@a77b7a0b struct signal_struct { t#refcount_t sigcnt ; t#atomic_t live ; int nr_threads ; int quick_threads ; s#list_head thread_head ; t#wait_queue_head_t wait_chldexit ; s#task_struct * curr_target ; s#sigpending shared_pending ; s#hlist_head multiprocess ; int group_exit_code ; int notify_count ; s#task_struct * group_exec_task ; int group_stop_count ; unsigned int flags ; s#core_state * core_state ; unsigned int is_child_subreaper : 1 ; unsigned int has_child_subreaper : 1 ; unsigned int next_posix_timer_id ; s#hlist_head posix_timers ; s#hrtimer real_timer ; t#ktime_t it_real_incr ; s#cpu_itimer it [ 2 ] ; s#thread_group_cputimer cputimer ; s#posix_cputimers posix_cputimers ; s#pid * pids [ E#PIDTYPE_MAX ] ; t#atomic_t tick_dep_mask ; s#pid * tty_old_pgrp ; int leader ; s#tty_struct * tty ; t#seqlock_t stats_lock ; t#u64 utime , stime , cutime , cstime ; t#u64 gtime ; t#u64 cgtime ; s#prev_cputime prev_cputime ; unsigned long nvcsw , nivcsw , cnvcsw , cnivcsw ; unsigned long min_flt , maj_flt , cmin_flt , cmaj_flt ; unsigned long inblock , oublock , cinblock , coublock ; unsigned long maxrss , cmaxrss ; s#task_io_accounting ioac ; unsigned long long sum_sched_runtime ; s#rlimit rlim [ 16 ] ; s#pacct_struct pacct ; s#taskstats * stats ; unsigned audit_tty ; s#tty_audit_buf * tty_audit_buf ; t#bool oom_flag_origin ; short oom_score_adj ; short oom_score_adj_min ; s#mm_struct * oom_mm ; s#mutex cred_guard_mutex ; s#rw_semaphore exec_update_lock ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#signal_struct@f9b7dce5 struct signal_struct { UNKNOWN }
s#sigpending struct sigpending { s#list_head list ; t#sigset_t signal ; }
s#simple_xattrs struct simple_xattrs { s#rb_root rb_root ; t#rwlock_t lock ; }
s#sk_buff@6b30ccf8 struct sk_buff { union { struct { s#sk_buff * next ; s#sk_buff * prev ; union { s#net_device * dev ; unsigned long dev_scratch ; } ; } ; s#rb_node rbnode ; s#list_head list ; s#llist_node ll_node ; } ; s#sock * sk ; union { t#ktime_t tstamp ; t#u64 skb_mstamp_ns ; } ; char cb [ 48 ] __attribute__ ( ( __aligned__ ( 8 ) ) ) ; union { struct { unsigned long _skb_refdst ; void ( * destructor ) ( s#sk_buff * ) ; } ; s#list_head tcp_tsorted_anchor ; unsigned long _sk_redir ; } ; unsigned long _nfct ; unsigned int len , data_len ; t#__u16 mac_len , hdr_len ; t#__u16 queue_mapping ; t#__u8 __cloned_offset [ 0 ] ; t#__u8 cloned : 1 , nohdr : 1 , fclone : 2 , peeked : 1 , head_frag : 1 , pfmemalloc : 1 , pp_recycle : 1 ; t#__u8 active_extensions ; union { struct { t#__u8 __pkt_type_offset [ 0 ] ; t#__u8 pkt_type : 3 ; t#__u8 ignore_df : 1 ; t#__u8 dst_pending_confirm : 1 ; t#__u8 ip_summed : 2 ; t#__u8 ooo_okay : 1 ; t#__u8 __mono_tc_offset [ 0 ] ; t#__u8 tstamp_type : 2 ; t#__u8 tc_at_ingress : 1 ; t#__u8 tc_skip_classify : 1 ; t#__u8 remcsum_offload : 1 ; t#__u8 csum_complete_sw : 1 ; t#__u8 csum_level : 2 ; t#__u8 inner_protocol_type : 1 ; t#__u8 l4_hash : 1 ; t#__u8 sw_hash : 1 ; t#__u8 wifi_acked_valid : 1 ; t#__u8 wifi_acked : 1 ; t#__u8 no_fcs : 1 ; t#__u8 encapsulation : 1 ; t#__u8 encap_hdr_csum : 1 ; t#__u8 csum_valid : 1 ; t#__u8 ndisc_nodetype : 2 ; t#__u8 ipvs_property : 1 ; t#__u8 nf_trace : 1 ; t#__u8 offload_fwd_mark : 1 ; t#__u8 offload_l3_fwd_mark : 1 ; t#__u8 redirected : 1 ; t#__u8 from_ingress : 1 ; t#__u8 nf_skip_egress : 1 ; t#__u8 decrypted : 1 ; t#__u8 slow_gro : 1 ; t#__u8 csum_not_inet : 1 ; t#__u8 unreadable : 1 ; t#__u16 tc_index ; t#u16 alloc_cpu ; union { t#__wsum csum ; struct { t#__u16 csum_start ; t#__u16 csum_offset ; } ; } ; t#__u32 priority ; int skb_iif ; t#__u32 hash ; union { t#u32 vlan_all ; struct { t#__be16 vlan_proto ; t#__u16 vlan_tci ; } ; } ; union { unsigned int napi_id ; unsigned int sender_cpu ; } ; t#__u32 secmark ; union { t#__u32 mark ; t#__u32 reserved_tailroom ; } ; union { t#__be16 inner_protocol ; t#__u8 inner_ipproto ; } ; t#__u16 inner_transport_header ; t#__u16 inner_network_header ; t#__u16 inner_mac_header ; t#__be16 protocol ; t#__u16 transport_header ; t#__u16 network_header ; t#__u16 mac_header ; } ; struct { t#__u8 __pkt_type_offset [ 0 ] ; t#__u8 pkt_type : 3 ; t#__u8 ignore_df : 1 ; t#__u8 dst_pending_confirm : 1 ; t#__u8 ip_summed : 2 ; t#__u8 ooo_okay : 1 ; t#__u8 __mono_tc_offset [ 0 ] ; t#__u8 tstamp_type : 2 ; t#__u8 tc_at_ingress : 1 ; t#__u8 tc_skip_classify : 1 ; t#__u8 remcsum_offload : 1 ; t#__u8 csum_complete_sw : 1 ; t#__u8 csum_level : 2 ; t#__u8 inner_protocol_type : 1 ; t#__u8 l4_hash : 1 ; t#__u8 sw_hash : 1 ; t#__u8 wifi_acked_valid : 1 ; t#__u8 wifi_acked : 1 ; t#__u8 no_fcs : 1 ; t#__u8 encapsulation : 1 ; t#__u8 encap_hdr_csum : 1 ; t#__u8 csum_valid : 1 ; t#__u8 ndisc_nodetype : 2 ; t#__u8 ipvs_property : 1 ; t#__u8 nf_trace : 1 ; t#__u8 offload_fwd_mark : 1 ; t#__u8 offload_l3_fwd_mark : 1 ; t#__u8 redirected : 1 ; t#__u8 from_ingress : 1 ; t#__u8 nf_skip_egress : 1 ; t#__u8 decrypted : 1 ; t#__u8 slow_gro : 1 ; t#__u8 csum_not_inet : 1 ; t#__u8 unreadable : 1 ; t#__u16 tc_index ; t#u16 alloc_cpu ; union { t#__wsum csum ; struct { t#__u16 csum_start ; t#__u16 csum_offset ; } ; } ; t#__u32 priority ; int skb_iif ; t#__u32 hash ; union { t#u32 vlan_all ; struct { t#__be16 vlan_proto ; t#__u16 vlan_tci ; } ; } ; union { unsigned int napi_id ; unsigned int sender_cpu ; } ; t#__u32 secmark ; union { t#__u32 mark ; t#__u32 reserved_tailroom ; } ; union { t#__be16 inner_protocol ; t#__u8 inner_ipproto ; } ; t#__u16 inner_transport_header ; t#__u16 inner_network_header ; t#__u16 inner_mac_header ; t#__be16 protocol ; t#__u16 transport_header ; t#__u16 network_header ; t#__u16 mac_header ; } headers ; } ; t#sk_buff_data_t tail ; t#sk_buff_data_t end ; unsigned char * head , * data ; unsigned int truesize ; t#refcount_t users ; s#skb_ext * extensions ; unsigned long uek_reserved1 ; }
s#sk_buff@d4487beb struct sk_buff { UNKNOWN }
s#sk_buff_head struct sk_buff_head { union { struct { s#sk_buff * next ; s#sk_buff * prev ; } ; s#sk_buff_list list ; } ; t#__u32 qlen ; t#spinlock_t lock ; }
s#sk_buff_list struct sk_buff_list { s#sk_buff * next ; s#sk_buff * prev ; }
s#sk_filter@02e5399f struct sk_filter { UNKNOWN }
s#sk_filter@201051b1 struct sk_filter { t#refcount_t refcnt ; s#callback_head rcu ; s#bpf_prog * prog ; }
s#sk_msg struct sk_msg { s#sk_msg_sg sg ; void * data ; void * data_end ; t#u32 apply_bytes ; t#u32 cork_bytes ; t#u32 flags ; s#sk_buff * skb ; s#sock * sk_redir ; s#sock * sk ; s#list_head list ; }
s#sk_msg_sg struct sk_msg_sg { t#u32 start ; t#u32 curr ; t#u32 end ; t#u32 size ; t#u32 copybreak ; unsigned long copy [ ( ( ( 17 + 2 ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; s#scatterlist data [ 17 + 2 ] ; }
s#sk_psock@54c50505 struct sk_psock { UNKNOWN }
s#sk_psock@badd7f59 struct sk_psock { s#sock * sk ; s#sock * sk_redir ; t#u32 apply_bytes ; t#u32 cork_bytes ; t#u32 eval ; t#bool redir_ingress ; s#sk_msg * cork ; s#sk_psock_progs progs ; s#strparser strp ; t#u32 copied_seq ; t#u32 ingress_bytes ; s#sk_buff_head ingress_skb ; s#list_head ingress_msg ; t#spinlock_t ingress_lock ; unsigned long state ; s#list_head link ; t#spinlock_t link_lock ; t#refcount_t refcnt ; void ( * saved_unhash ) ( s#sock * ) ; void ( * saved_destroy ) ( s#sock * ) ; void ( * saved_close ) ( s#sock * , long ) ; void ( * saved_write_space ) ( s#sock * ) ; void ( * saved_data_ready ) ( s#sock * ) ; int ( * psock_update_sk_prot ) ( s#sock * , s#sk_psock * , t#bool ) ; s#proto * sk_proto ; s#mutex work_mutex ; s#sk_psock_work_state work_state ; s#delayed_work work ; s#sock * sk_pair ; s#rcu_work rwork ; }
s#sk_psock_progs struct sk_psock_progs { s#bpf_prog * msg_parser ; s#bpf_prog * stream_parser ; s#bpf_prog * stream_verdict ; s#bpf_prog * skb_verdict ; s#bpf_link * msg_parser_link ; s#bpf_link * stream_parser_link ; s#bpf_link * stream_verdict_link ; s#bpf_link * skb_verdict_link ; }
s#sk_psock_work_state struct sk_psock_work_state { t#u32 len ; t#u32 off ; }
s#skb_ext struct skb_ext { t#refcount_t refcnt ; t#u8 offset [ E#SKB_EXT_NUM ] ; t#u8 chunks ; char data [ ] __attribute__ ( ( __aligned__ ( 8 ) ) ) ; }
s#skb_shared_hwtstamps struct skb_shared_hwtstamps { union { t#ktime_t hwtstamp ; void * netdev_data ; } ; }
s#smc_hashinfo struct smc_hashinfo { UNKNOWN }
s#sock@25784684 struct sock { UNKNOWN }
s#sock@c64df4d1 struct sock { s#sock_common __sk_common ; t#__u8 __cacheline_group_begin__sock_write_rx [ 0 ] ; t#atomic_t sk_drops ; t#__s32 sk_peek_off ; s#sk_buff_head sk_error_queue ; s#sk_buff_head sk_receive_queue ; struct { t#atomic_t rmem_alloc ; int len ; s#sk_buff * head ; s#sk_buff * tail ; } sk_backlog ; t#__u8 __cacheline_group_end__sock_write_rx [ 0 ] ; t#__u8 __cacheline_group_begin__sock_read_rx [ 0 ] ; s#dst_entry * sk_rx_dst ; int sk_rx_dst_ifindex ; t#u32 sk_rx_dst_cookie ; unsigned int sk_ll_usec ; unsigned int sk_napi_id ; t#u16 sk_busy_poll_budget ; t#u8 sk_prefer_busy_poll ; t#u8 sk_userlocks ; int sk_rcvbuf ; s#sk_filter * sk_filter ; union { s#socket_wq * sk_wq ; s#socket_wq * sk_wq_raw ; } ; void ( * sk_data_ready ) ( s#sock * ) ; long sk_rcvtimeo ; int sk_rcvlowat ; t#__u8 __cacheline_group_end__sock_read_rx [ 0 ] ; t#__u8 __cacheline_group_begin__sock_read_rxtx [ 0 ] ; int sk_err ; s#socket * sk_socket ; s#mem_cgroup * sk_memcg ; s#xfrm_policy * sk_policy [ 2 ] ; t#__u8 __cacheline_group_end__sock_read_rxtx [ 0 ] ; t#__u8 __cacheline_group_begin__sock_write_rxtx [ 0 ] ; t#socket_lock_t sk_lock ; t#u32 sk_reserved_mem ; int sk_forward_alloc ; t#u32 sk_tsflags ; t#__u8 __cacheline_group_end__sock_write_rxtx [ 0 ] ; t#__u8 __cacheline_group_begin__sock_write_tx [ 0 ] ; int sk_write_pending ; t#atomic_t sk_omem_alloc ; int sk_sndbuf ; int sk_wmem_queued ; t#refcount_t sk_wmem_alloc ; unsigned long sk_tsq_flags ; union { s#sk_buff * sk_send_head ; s#rb_root tcp_rtx_queue ; } ; s#sk_buff_head sk_write_queue ; t#u32 sk_dst_pending_confirm ; t#u32 sk_pacing_status ; s#page_frag sk_frag ; s#timer_list sk_timer ; unsigned long sk_pacing_rate ; t#atomic_t sk_zckey ; t#atomic_t sk_tskey ; t#__u8 __cacheline_group_end__sock_write_tx [ 0 ] ; t#__u8 __cacheline_group_begin__sock_read_tx [ 0 ] ; unsigned long sk_max_pacing_rate ; long sk_sndtimeo ; t#u32 sk_priority ; t#u32 sk_mark ; s#dst_entry * sk_dst_cache ; t#netdev_features_t sk_route_caps ; s#sk_buff * ( * sk_validate_xmit_skb ) ( s#sock * , s#net_device * , s#sk_buff * ) ; t#u16 sk_gso_type ; t#u16 sk_gso_max_segs ; unsigned int sk_gso_max_size ; t#gfp_t sk_allocation ; t#u32 sk_txhash ; t#u8 sk_pacing_shift ; t#bool sk_use_task_frag ; t#__u8 __cacheline_group_end__sock_read_tx [ 0 ] ; t#u8 sk_gso_disabled : 1 , sk_kern_sock : 1 , sk_no_check_tx : 1 , sk_no_check_rx : 1 ; t#u8 sk_shutdown ; t#u16 sk_type ; t#u16 sk_protocol ; unsigned long sk_lingertime ; s#proto * sk_prot_creator ; t#rwlock_t sk_callback_lock ; int sk_err_soft ; t#u32 sk_ack_backlog ; t#u32 sk_max_ack_backlog ; t#kuid_t sk_uid ; t#spinlock_t sk_peer_lock ; int sk_bind_phc ; s#pid * sk_peer_pid ; const s#cred * sk_peer_cred ; t#ktime_t sk_stamp ; int sk_disconnects ; t#u8 sk_txrehash ; t#u8 sk_clockid ; t#u8 sk_txtime_deadline_mode : 1 , sk_txtime_report_errors : 1 , sk_txtime_unused : 6 ; void * sk_user_data ; void * sk_security ; s#sock_cgroup_data sk_cgrp_data ; void ( * sk_state_change ) ( s#sock * ) ; void ( * sk_write_space ) ( s#sock * ) ; void ( * sk_error_report ) ( s#sock * ) ; int ( * sk_backlog_rcv ) ( s#sock * , s#sk_buff * ) ; void ( * sk_destruct ) ( s#sock * ) ; s#sock_reuseport * sk_reuseport_cb ; s#bpf_local_storage * sk_bpf_storage ; s#callback_head sk_rcu ; t#netns_tracker ns_tracker ; s#xarray sk_user_frags ; }
s#sock_cgroup_data struct sock_cgroup_data { s#cgroup * cgroup ; t#u32 classid ; t#u16 prioidx ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#sock_common struct sock_common { union { t#__addrpair skc_addrpair ; struct { t#__be32 skc_daddr ; t#__be32 skc_rcv_saddr ; } ; } ; union { unsigned int skc_hash ; t#__u16 skc_u16hashes [ 2 ] ; } ; union { t#__portpair skc_portpair ; struct { t#__be16 skc_dport ; t#__u16 skc_num ; } ; } ; unsigned short skc_family ; volatile unsigned char skc_state ; unsigned char skc_reuse : 4 ; unsigned char skc_reuseport : 1 ; unsigned char skc_ipv6only : 1 ; unsigned char skc_net_refcnt : 1 ; int skc_bound_dev_if ; union { s#hlist_node skc_bind_node ; s#hlist_node skc_portaddr_node ; } ; s#proto * skc_prot ; t#possible_net_t skc_net ; s#in6_addr skc_v6_daddr ; s#in6_addr skc_v6_rcv_saddr ; t#atomic64_t skc_cookie ; union { unsigned long skc_flags ; s#sock * skc_listener ; s#inet_timewait_death_row * skc_tw_dr ; } ; int skc_dontcopy_begin [ 0 ] ; union { s#hlist_node skc_node ; s#hlist_nulls_node skc_nulls_node ; } ; unsigned short skc_tx_queue_mapping ; unsigned short skc_rx_queue_mapping ; union { int skc_incoming_cpu ; t#u32 skc_rcv_wnd ; t#u32 skc_tw_rcv_nxt ; } ; t#refcount_t skc_refcnt ; int skc_dontcopy_end [ 0 ] ; union { t#u32 skc_rxhash ; t#u32 skc_window_clamp ; t#u32 skc_tw_snd_nxt ; } ; }
s#sock_filter struct sock_filter { t#__u16 code ; t#__u8 jt ; t#__u8 jf ; t#__u32 k ; }
s#sock_fprog_kern@078f369c struct sock_fprog_kern { UNKNOWN }
s#sock_fprog_kern@51f2cd25 struct sock_fprog_kern { t#u16 len ; s#sock_filter * filter ; }
s#sock_reuseport@1f233d59 struct sock_reuseport { UNKNOWN }
s#sock_reuseport@36c358d9 struct sock_reuseport { s#callback_head rcu ; t#u16 max_socks ; t#u16 num_socks ; t#u16 num_closed_socks ; t#u16 incoming_cpu ; unsigned int synq_overflow_ts ; unsigned int reuseport_id ; unsigned int bind_inany : 1 ; unsigned int has_conns : 1 ; s#bpf_prog * prog ; s#sock * socks [ ] ; }
s#sockaddr struct sockaddr { t#sa_family_t sa_family ; union { char sa_data_min [ 14 ] ; struct { struct { } __empty_sa_data ; char sa_data [ ] ; } ; } ; }
s#socket@4b8cff44 struct socket { UNKNOWN }
s#socket@7480649c struct socket { t#socket_state state ; short type ; unsigned long flags ; s#file * file ; s#sock * sk ; const s#proto_ops * ops ; s#socket_wq wq ; }
s#socket_wq struct socket_wq { t#wait_queue_head_t wait ; s#fasync_struct * fasync_list ; unsigned long flags ; s#callback_head rcu ; }
s#spinlock struct spinlock { union { s#raw_spinlock rlock ; } ; }
s#srcu_data struct srcu_data { t#atomic_long_t srcu_lock_count [ 2 ] ; t#atomic_long_t srcu_unlock_count [ 2 ] ; int srcu_nmi_safety ; t#spinlock_t lock __attribute__ ( ( __aligned__ ( 1 << ( 6 ) ) ) ) ; s#rcu_segcblist srcu_cblist ; unsigned long srcu_gp_seq_needed ; unsigned long srcu_gp_seq_needed_exp ; t#bool srcu_cblist_invoking ; s#timer_list delay_work ; s#work_struct work ; s#callback_head srcu_barrier_head ; s#srcu_node * mynode ; unsigned long grpmask ; int cpu ; s#srcu_struct * ssp ; }
s#srcu_node struct srcu_node { t#spinlock_t lock ; unsigned long srcu_have_cbs [ 4 ] ; unsigned long srcu_data_have_cbs [ 4 ] ; unsigned long srcu_gp_seq_needed_exp ; s#srcu_node * srcu_parent ; int grplo ; int grphi ; }
s#srcu_struct struct srcu_struct { unsigned int srcu_idx ; s#srcu_data * sda ; s#lockdep_map dep_map ; s#srcu_usage * srcu_sup ; }
s#srcu_usage struct srcu_usage { s#srcu_node * node ; s#srcu_node * level [ 3 + 1 ] ; int srcu_size_state ; s#mutex srcu_cb_mutex ; t#spinlock_t lock ; s#mutex srcu_gp_mutex ; unsigned long srcu_gp_seq ; unsigned long srcu_gp_seq_needed ; unsigned long srcu_gp_seq_needed_exp ; unsigned long srcu_gp_start ; unsigned long srcu_last_gp_end ; unsigned long srcu_size_jiffies ; unsigned long srcu_n_lock_retries ; unsigned long srcu_n_exp_nodelay ; t#bool sda_is_static ; unsigned long srcu_barrier_seq ; s#mutex srcu_barrier_mutex ; s#completion srcu_barrier_completion ; t#atomic_t srcu_barrier_cpu_cnt ; unsigned long reschedule_jiffies ; unsigned long reschedule_count ; s#delayed_work work ; s#srcu_struct * srcu_ssp ; }
s#static_call_key struct static_call_key { void * func ; union { unsigned long type ; s#static_call_mod * mods ; s#static_call_site * sites ; } ; }
s#static_call_mod@47e5f6aa struct static_call_mod { s#static_call_mod * next ; s#module * mod ; s#static_call_site * sites ; }
s#static_call_mod@61b69476 struct static_call_mod { UNKNOWN }
s#static_call_site struct static_call_site { t#s32 addr ; t#s32 key ; }
s#static_key struct static_key { t#atomic_t enabled ; union { unsigned long type ; s#jump_entry * entries ; s#static_key_mod * next ; } ; }
s#static_key_false struct static_key_false { s#static_key key ; }
s#static_key_mod struct static_key_mod { UNKNOWN }
s#static_key_true struct static_key_true { s#static_key key ; }
s#stp_proto struct stp_proto { unsigned char group_address [ 6 ] ; void ( * rcv ) ( const s#stp_proto * , s#sk_buff * , s#net_device * ) ; void * data ; }
s#strp_callbacks struct strp_callbacks { int ( * parse_msg ) ( s#strparser * , s#sk_buff * ) ; void ( * rcv_msg ) ( s#strparser * , s#sk_buff * ) ; int ( * read_sock ) ( s#strparser * , t#read_descriptor_t * , t#sk_read_actor_t ) ; int ( * read_sock_done ) ( s#strparser * , int ) ; void ( * abort_parser ) ( s#strparser * , int ) ; void ( * lock ) ( s#strparser * ) ; void ( * unlock ) ( s#strparser * ) ; }
s#strp_stats struct strp_stats { unsigned long long msgs ; unsigned long long bytes ; unsigned int mem_fail ; unsigned int need_more_hdr ; unsigned int msg_too_big ; unsigned int msg_timeouts ; unsigned int bad_hdr_len ; }
s#strparser struct strparser { s#sock * sk ; t#u32 stopped : 1 ; t#u32 paused : 1 ; t#u32 aborted : 1 ; t#u32 interrupted : 1 ; t#u32 unrecov_intr : 1 ; s#sk_buff * * skb_nextp ; s#sk_buff * skb_head ; unsigned int need_bytes ; s#delayed_work msg_timer_work ; s#work_struct work ; s#strp_stats stats ; s#strp_callbacks cb ; }
s#super_block struct super_block { s#list_head s_list ; t#dev_t s_dev ; unsigned char s_blocksize_bits ; unsigned long s_blocksize ; t#loff_t s_maxbytes ; s#file_system_type * s_type ; const s#super_operations * s_op ; const s#dquot_operations * dq_op ; const s#quotactl_ops * s_qcop ; const s#export_operations * s_export_op ; unsigned long s_flags ; unsigned long s_iflags ; unsigned long s_magic ; s#dentry * s_root ; s#rw_semaphore s_umount ; int s_count ; t#atomic_t s_active ; void * s_security ; const s#xattr_handler * const * s_xattr ; const s#fscrypt_operations * s_cop ; s#fscrypt_keyring * s_master_keys ; const s#fsverity_operations * s_vop ; s#hlist_bl_head s_roots ; s#list_head s_mounts ; s#block_device * s_bdev ; s#file * s_bdev_file ; s#backing_dev_info * s_bdi ; s#mtd_info * s_mtd ; s#hlist_node s_instances ; unsigned int s_quota_types ; s#quota_info s_dquot ; s#sb_writers s_writers ; void * s_fs_info ; t#u32 s_time_gran ; t#time64_t s_time_min ; t#time64_t s_time_max ; t#u32 s_fsnotify_mask ; s#fsnotify_sb_info * s_fsnotify_info ; char s_id [ 32 ] ; t#uuid_t s_uuid ; t#u8 s_uuid_len ; char s_sysfs_name [ 36 + 1 ] ; unsigned int s_max_links ; s#mutex s_vfs_rename_mutex ; const char * s_subtype ; const s#dentry_operations * s_d_op ; s#shrinker * s_shrink ; t#atomic_long_t s_remove_count ; int s_readonly_remount ; t#errseq_t s_wb_err ; s#workqueue_struct * s_dio_done_wq ; s#hlist_head s_pins ; s#user_namespace * s_user_ns ; s#list_lru s_dentry_lru ; s#list_lru s_inode_lru ; s#callback_head rcu ; s#work_struct destroy_work ; s#mutex s_sync_lock ; int s_stack_depth ; t#spinlock_t s_inode_list_lock __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; s#list_head s_inodes ; t#spinlock_t s_inode_wblist_lock ; s#list_head s_inodes_wb ; }
s#super_operations struct super_operations { s#inode * ( * alloc_inode ) ( s#super_block * ) ; void ( * destroy_inode ) ( s#inode * ) ; void ( * free_inode ) ( s#inode * ) ; void ( * dirty_inode ) ( s#inode * , int ) ; int ( * write_inode ) ( s#inode * , s#writeback_control * ) ; int ( * drop_inode ) ( s#inode * ) ; void ( * evict_inode ) ( s#inode * ) ; void ( * put_super ) ( s#super_block * ) ; int ( * sync_fs ) ( s#super_block * , int ) ; int ( * freeze_super ) ( s#super_block * , e#freeze_holder ) ; int ( * freeze_fs ) ( s#super_block * ) ; int ( * thaw_super ) ( s#super_block * , e#freeze_holder ) ; int ( * unfreeze_fs ) ( s#super_block * ) ; int ( * statfs ) ( s#dentry * , s#kstatfs * ) ; int ( * remount_fs ) ( s#super_block * , int * , char * ) ; void ( * umount_begin ) ( s#super_block * ) ; int ( * show_options ) ( s#seq_file * , s#dentry * ) ; int ( * show_devname ) ( s#seq_file * , s#dentry * ) ; int ( * show_path ) ( s#seq_file * , s#dentry * ) ; int ( * show_stats ) ( s#seq_file * , s#dentry * ) ; t#ssize_t ( * quota_read ) ( s#super_block * , int , char * , t#size_t , t#loff_t ) ; t#ssize_t ( * quota_write ) ( s#super_block * , int , const char * , t#size_t , t#loff_t ) ; s#dquot * * ( * get_dquots ) ( s#inode * ) ; long ( * nr_cached_objects ) ( s#super_block * , s#shrink_control * ) ; long ( * free_cached_objects ) ( s#super_block * , s#shrink_control * ) ; void ( * shutdown ) ( s#super_block * ) ; }
s#svc_cred struct svc_cred { t#kuid_t cr_uid ; t#kgid_t cr_gid ; s#group_info * cr_group_info ; t#u32 cr_flavor ; char * cr_raw_principal ; char * cr_principal ; char * cr_targ_princ ; s#gss_api_mech * cr_gss_mech ; }
s#svc_deferred_req struct svc_deferred_req { t#u32 prot ; s#svc_xprt * xprt ; s#__kernel_sockaddr_storage addr ; t#size_t addrlen ; s#__kernel_sockaddr_storage daddr ; t#size_t daddrlen ; void * xprt_ctxt ; s#cache_deferred_req handle ; int argslen ; t#__be32 args [ ] ; }
s#svc_pool struct svc_pool { unsigned int sp_id ; s#lwq sp_xprts ; unsigned int sp_nrthreads ; s#list_head sp_all_threads ; s#llist_head sp_idle_threads ; s#percpu_counter sp_messages_arrived ; s#percpu_counter sp_sockets_queued ; s#percpu_counter sp_threads_woken ; unsigned long sp_flags ; }
s#svc_procedure struct svc_procedure { t#__be32 ( * pc_func ) ( s#svc_rqst * ) ; t#bool ( * pc_decode ) ( s#svc_rqst * , s#xdr_stream * ) ; t#bool ( * pc_encode ) ( s#svc_rqst * , s#xdr_stream * ) ; void ( * pc_release ) ( s#svc_rqst * ) ; unsigned int pc_argsize ; unsigned int pc_argzero ; unsigned int pc_ressize ; unsigned int pc_cachetype ; unsigned int pc_xdrressize ; const char * pc_name ; }
s#svc_process_info struct svc_process_info { union { int ( * dispatch ) ( s#svc_rqst * ) ; struct { unsigned int lovers ; unsigned int hivers ; } mismatch ; } ; }
s#svc_program struct svc_program { t#u32 pg_prog ; unsigned int pg_lovers ; unsigned int pg_hivers ; unsigned int pg_nvers ; const s#svc_version * * pg_vers ; char * pg_name ; char * pg_class ; e#svc_auth_status ( * pg_authenticate ) ( s#svc_rqst * ) ; t#__be32 ( * pg_init_request ) ( s#svc_rqst * , const s#svc_program * , s#svc_process_info * ) ; int ( * pg_rpcbind_set ) ( s#net * , const s#svc_program * , t#u32 , int , unsigned short , unsigned short ) ; }
s#svc_rqst struct svc_rqst { s#list_head rq_all ; s#llist_node rq_idle ; s#callback_head rq_rcu_head ; s#svc_xprt * rq_xprt ; s#__kernel_sockaddr_storage rq_addr ; t#size_t rq_addrlen ; s#__kernel_sockaddr_storage rq_daddr ; t#size_t rq_daddrlen ; s#svc_serv * rq_server ; s#svc_pool * rq_pool ; const s#svc_procedure * rq_procinfo ; s#auth_ops * rq_authop ; s#svc_cred rq_cred ; void * rq_xprt_ctxt ; s#svc_deferred_req * rq_deferred ; s#xdr_buf rq_arg ; s#xdr_stream rq_arg_stream ; s#xdr_stream rq_res_stream ; s#page * rq_scratch_page ; s#xdr_buf rq_res ; s#page * rq_pages [ ( ( ( 1 * 1024 * 1024u ) + ( ( 1UL ) << 12 ) - 1 ) / ( ( 1UL ) << 12 ) + 2 + 1 ) + 1 ] ; s#page * * rq_respages ; s#page * * rq_next_page ; s#page * * rq_page_end ; s#folio_batch rq_fbatch ; s#kvec rq_vec [ ( ( ( 1 * 1024 * 1024u ) + ( ( 1UL ) << 12 ) - 1 ) / ( ( 1UL ) << 12 ) + 2 + 1 ) ] ; s#bio_vec rq_bvec [ ( ( ( 1 * 1024 * 1024u ) + ( ( 1UL ) << 12 ) - 1 ) / ( ( 1UL ) << 12 ) + 2 + 1 ) ] ; t#__be32 rq_xid ; t#u32 rq_prog ; t#u32 rq_vers ; t#u32 rq_proc ; t#u32 rq_prot ; int rq_cachetype ; unsigned long rq_flags ; t#ktime_t rq_qtime ; void * rq_argp ; void * rq_resp ; t#__be32 * rq_accept_statp ; void * rq_auth_data ; t#__be32 rq_auth_stat ; int rq_auth_slack ; int rq_reserved ; t#ktime_t rq_stime ; s#cache_req rq_chandle ; s#auth_domain * rq_client ; s#auth_domain * rq_gssclient ; s#task_struct * rq_task ; s#net * rq_bc_net ; int rq_err ; unsigned long bc_to_initval ; unsigned int bc_to_retries ; void * * rq_lease_breaker ; unsigned int rq_status_counter ; }
s#svc_serv@e52ceed7 struct svc_serv { s#svc_program * sv_programs ; s#svc_stat * sv_stats ; t#spinlock_t sv_lock ; unsigned int sv_nprogs ; unsigned int sv_nrthreads ; unsigned int sv_maxconn ; unsigned int sv_max_payload ; unsigned int sv_max_mesg ; unsigned int sv_xdrsize ; s#list_head sv_permsocks ; s#list_head sv_tempsocks ; int sv_tmpcnt ; s#timer_list sv_temptimer ; char * sv_name ; unsigned int sv_nrpools ; t#bool sv_is_pooled ; s#svc_pool * sv_pools ; int ( * sv_threadfn ) ( void * ) ; s#lwq sv_cb_list ; t#bool sv_bc_enabled ; }
s#svc_serv@e7dddd2a struct svc_serv { UNKNOWN }
s#svc_stat struct svc_stat { s#svc_program * program ; unsigned int netcnt , netudpcnt , nettcpcnt , nettcpconn ; unsigned int rpccnt , rpcbadfmt , rpcbadauth , rpcbadclnt ; }
s#svc_version struct svc_version { t#u32 vs_vers ; t#u32 vs_nproc ; const s#svc_procedure * vs_proc ; unsigned long * vs_count ; t#u32 vs_xdrsize ; t#bool vs_hidden ; t#bool vs_rpcb_optnl ; t#bool vs_need_cong_ctrl ; int ( * vs_dispatch ) ( s#svc_rqst * ) ; }
s#svc_xprt@96d27ccf struct svc_xprt { s#svc_xprt_class * xpt_class ; const s#svc_xprt_ops * xpt_ops ; s#kref xpt_ref ; s#list_head xpt_list ; s#lwq_node xpt_ready ; unsigned long xpt_flags ; s#svc_serv * xpt_server ; t#atomic_t xpt_reserved ; t#atomic_t xpt_nr_rqsts ; s#mutex xpt_mutex ; t#spinlock_t xpt_lock ; void * xpt_auth_cache ; s#list_head xpt_deferred ; s#__kernel_sockaddr_storage xpt_local ; t#size_t xpt_locallen ; s#__kernel_sockaddr_storage xpt_remote ; t#size_t xpt_remotelen ; char xpt_remotebuf [ ( 48 ) + 10 ] ; s#list_head xpt_users ; s#net * xpt_net ; t#netns_tracker ns_tracker ; const s#cred * xpt_cred ; s#rpc_xprt * xpt_bc_xprt ; s#rpc_xprt_switch * xpt_bc_xps ; }
s#svc_xprt@9dbd2a3e struct svc_xprt { UNKNOWN }
s#svc_xprt_class struct svc_xprt_class { const char * xcl_name ; s#module * xcl_owner ; const s#svc_xprt_ops * xcl_ops ; s#list_head xcl_list ; t#u32 xcl_max_payload ; int xcl_ident ; }
s#svc_xprt_ops struct svc_xprt_ops { s#svc_xprt * ( * xpo_create ) ( s#svc_serv * , s#net * , s#sockaddr * , int , int ) ; s#svc_xprt * ( * xpo_accept ) ( s#svc_xprt * ) ; int ( * xpo_has_wspace ) ( s#svc_xprt * ) ; int ( * xpo_recvfrom ) ( s#svc_rqst * ) ; int ( * xpo_sendto ) ( s#svc_rqst * ) ; int ( * xpo_result_payload ) ( s#svc_rqst * , unsigned int , unsigned int ) ; void ( * xpo_release_ctxt ) ( s#svc_xprt * , void * ) ; void ( * xpo_detach ) ( s#svc_xprt * ) ; void ( * xpo_free ) ( s#svc_xprt * ) ; void ( * xpo_kill_temp_xprt ) ( s#svc_xprt * ) ; void ( * xpo_handshake ) ( s#svc_xprt * ) ; }
s#swait_queue_head struct swait_queue_head { t#raw_spinlock_t lock ; s#list_head task_list ; }
s#swap_cluster_info struct swap_cluster_info { t#spinlock_t lock ; t#u16 count ; t#u8 flags ; t#u8 order ; s#list_head list ; }
s#swap_info_struct@568371c0 struct swap_info_struct { s#percpu_ref users ; unsigned long flags ; signed short prio ; s#plist_node list ; signed char type ; unsigned int max ; unsigned char * swap_map ; unsigned long * zeromap ; s#swap_cluster_info * cluster_info ; s#list_head free_clusters ; s#list_head full_clusters ; s#list_head nonfull_clusters [ ( ( 21 - 12 ) + 1 ) ] ; s#list_head frag_clusters [ ( ( 21 - 12 ) + 1 ) ] ; unsigned int frag_cluster_nr [ ( ( 21 - 12 ) + 1 ) ] ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned int lowest_bit ; unsigned int highest_bit ; unsigned int pages ; unsigned long uek_reserved8 ; unsigned int inuse_pages ; unsigned int cluster_next ; unsigned int cluster_nr ; unsigned int * cluster_next_cpu ; s#percpu_cluster * percpu_cluster ; s#rb_root swap_extent_root ; s#block_device * bdev ; s#file * swap_file ; s#completion comp ; t#spinlock_t lock ; t#spinlock_t cont_lock ; s#work_struct discard_work ; s#work_struct reclaim_work ; s#list_head discard_clusters ; s#plist_node avail_lists [ ] ; }
s#swap_info_struct@a9138d45 struct swap_info_struct { UNKNOWN }
s#swap_iocb struct swap_iocb { UNKNOWN }
s#switchdev_brport_flags struct switchdev_brport_flags { unsigned long val ; unsigned long mask ; }
s#switchdev_mst_state struct switchdev_mst_state { t#u16 msti ; t#u8 state ; }
s#switchdev_obj struct switchdev_obj { s#list_head list ; s#net_device * orig_dev ; e#switchdev_obj_id id ; t#u32 flags ; void * complete_priv ; void ( * complete ) ( s#net_device * , int , void * ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#switchdev_obj_mrp struct switchdev_obj_mrp { s#switchdev_obj obj ; s#net_device * p_port ; s#net_device * s_port ; t#u32 ring_id ; t#u16 prio ; }
s#switchdev_obj_port_mdb struct switchdev_obj_port_mdb { s#switchdev_obj obj ; unsigned char addr [ 6 ] ; t#u16 vid ; }
s#switchdev_obj_port_vlan struct switchdev_obj_port_vlan { s#switchdev_obj obj ; t#u16 flags ; t#u16 vid ; t#bool changed ; }
s#switchdev_obj_ring_role_mrp struct switchdev_obj_ring_role_mrp { s#switchdev_obj obj ; t#u8 ring_role ; t#u32 ring_id ; t#u8 sw_backup ; }
s#switchdev_vlan_msti struct switchdev_vlan_msti { t#u16 vid ; t#u16 msti ; }
s#swregs_state struct swregs_state { t#u32 cwd ; t#u32 swd ; t#u32 twd ; t#u32 fip ; t#u32 fcs ; t#u32 foo ; t#u32 fos ; t#u32 st_space [ 20 ] ; t#u8 ftop ; t#u8 changed ; t#u8 lookahead ; t#u8 no_update ; t#u8 rm ; t#u8 alimit ; s#math_emu_info * info ; t#u32 entry_eip ; }
s#syscall_user_dispatch struct syscall_user_dispatch { char * selector ; unsigned long offset ; unsigned long len ; t#bool on_dispatch ; }
s#sysctl_fib_multipath_hash_seed struct sysctl_fib_multipath_hash_seed { t#u32 user_seed ; t#u32 mp_seed ; }
s#sysfs_ops struct sysfs_ops { t#ssize_t ( * show ) ( s#kobject * , s#attribute * , char * ) ; t#ssize_t ( * store ) ( s#kobject * , s#attribute * , const char * , t#size_t ) ; }
s#sysinfo struct sysinfo { t#__kernel_long_t uptime ; t#__kernel_ulong_t loads [ 3 ] ; t#__kernel_ulong_t totalram ; t#__kernel_ulong_t freeram ; t#__kernel_ulong_t sharedram ; t#__kernel_ulong_t bufferram ; t#__kernel_ulong_t totalswap ; t#__kernel_ulong_t freeswap ; t#__u16 procs ; t#__u16 pad ; t#__kernel_ulong_t totalhigh ; t#__kernel_ulong_t freehigh ; t#__u32 mem_unit ; char _f [ 20 - 2 * sizeof ( __kernel_ulong_t ) - sizeof ( __u32 ) ] ; }
s#sysv_sem struct sysv_sem { s#sem_undo_list * undo_list ; }
s#sysv_shm struct sysv_shm { s#list_head shm_clist ; }
s#task_cputime struct task_cputime { t#u64 stime ; t#u64 utime ; unsigned long long sum_exec_runtime ; }
s#task_cputime_atomic struct task_cputime_atomic { t#atomic64_t utime ; t#atomic64_t stime ; t#atomic64_t sum_exec_runtime ; }
s#task_delay_info@57aa8129 struct task_delay_info { UNKNOWN }
s#task_delay_info@58dfc497 struct task_delay_info { t#raw_spinlock_t lock ; t#u64 blkio_start ; t#u64 blkio_delay ; t#u64 swapin_start ; t#u64 swapin_delay ; t#u32 blkio_count ; t#u32 swapin_count ; t#u64 freepages_start ; t#u64 freepages_delay ; t#u64 thrashing_start ; t#u64 thrashing_delay ; t#u64 compact_start ; t#u64 compact_delay ; t#u64 wpcopy_start ; t#u64 wpcopy_delay ; t#u64 irq_delay ; t#u32 freepages_count ; t#u32 thrashing_count ; t#u32 compact_count ; t#u32 wpcopy_count ; t#u32 irq_count ; }
s#task_group@1e8ff265 struct task_group { s#cgroup_subsys_state css ; int idle ; s#sched_entity * * se ; s#cfs_rq * * cfs_rq ; unsigned long shares ; t#atomic_long_t load_avg __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; t#u32 scx_flags ; t#u32 scx_weight ; s#callback_head rcu ; s#list_head list ; s#task_group * parent ; s#list_head siblings ; s#list_head children ; s#cfs_bandwidth cfs_bandwidth ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#task_group@4547b22f struct task_group { UNKNOWN }
s#task_io_accounting struct task_io_accounting { t#u64 rchar ; t#u64 wchar ; t#u64 syscr ; t#u64 syscw ; t#u64 read_bytes ; t#u64 write_bytes ; t#u64 cancelled_write_bytes ; }
s#task_struct struct task_struct { s#thread_info thread_info ; unsigned int __state ; unsigned int saved_state ; void * stack ; t#refcount_t usage ; unsigned int flags ; unsigned int ptrace ; int on_cpu ; s#__call_single_node wake_entry ; unsigned int wakee_flips ; unsigned long wakee_flip_decay_ts ; s#task_struct * last_wakee ; int recent_used_cpu ; int wake_cpu ; int on_rq ; int prio ; int static_prio ; int normal_prio ; unsigned int rt_priority ; s#sched_entity se ; s#sched_rt_entity rt ; s#sched_dl_entity dl ; s#sched_dl_entity * dl_server ; s#sched_ext_entity scx ; const s#sched_class * sched_class ; s#rb_node core_node ; unsigned long core_cookie ; unsigned int core_occupation ; s#task_group * sched_task_group ; s#sched_statistics stats ; s#hlist_head preempt_notifiers ; unsigned int btrace_seq ; unsigned int policy ; unsigned long max_allowed_capacity ; int nr_cpus_allowed ; const t#cpumask_t * cpus_ptr ; t#cpumask_t * user_cpus_ptr ; t#cpumask_t cpus_mask ; void * migration_pending ; unsigned short migration_disabled ; unsigned short migration_flags ; int rcu_read_lock_nesting ; u#rcu_special rcu_read_unlock_special ; s#list_head rcu_node_entry ; s#rcu_node * rcu_blocked_node ; unsigned long rcu_tasks_nvcsw ; t#u8 rcu_tasks_holdout ; t#u8 rcu_tasks_idx ; int rcu_tasks_idle_cpu ; s#list_head rcu_tasks_holdout_list ; int rcu_tasks_exit_cpu ; s#list_head rcu_tasks_exit_list ; int trc_reader_nesting ; int trc_ipi_to_cpu ; u#rcu_special trc_reader_special ; s#list_head trc_holdout_list ; s#list_head trc_blkd_node ; int trc_blkd_cpu ; s#sched_info sched_info ; s#list_head tasks ; s#plist_node pushable_tasks ; s#rb_node pushable_dl_tasks ; unsigned rseq_sched_delay : 1 ; s#mm_struct * mm ; s#mm_struct * active_mm ; s#address_space * faults_disabled_mapping ; int exit_state ; int exit_code ; int exit_signal ; int pdeath_signal ; unsigned long jobctl ; unsigned int personality ; unsigned sched_reset_on_fork : 1 ; unsigned sched_contributes_to_load : 1 ; unsigned sched_migrated : 1 ; unsigned sched_task_hot : 1 ; unsigned : 0 ; unsigned sched_remote_wakeup : 1 ; unsigned sched_rt_mutex : 1 ; unsigned in_execve : 1 ; unsigned in_iowait : 1 ; unsigned restore_sigmask : 1 ; unsigned in_user_fault : 1 ; unsigned in_lru_fault : 1 ; unsigned no_cgroup_migration : 1 ; unsigned frozen : 1 ; unsigned use_memdelay : 1 ; unsigned in_memstall : 1 ; unsigned in_page_owner : 1 ; unsigned in_eventfd : 1 ; unsigned pasid_activated : 1 ; unsigned reported_split_lock : 1 ; unsigned in_thrashing : 1 ; unsigned long atomic_flags ; s#restart_block restart_block ; t#pid_t pid ; t#pid_t tgid ; unsigned long stack_canary ; s#task_struct * real_parent ; s#task_struct * parent ; s#list_head children ; s#list_head sibling ; s#task_struct * group_leader ; s#list_head ptraced ; s#list_head ptrace_entry ; s#pid * thread_pid ; s#hlist_node pid_links [ E#PIDTYPE_MAX ] ; s#list_head thread_node ; s#completion * vfork_done ; int * set_child_tid ; int * clear_child_tid ; void * worker_private ; t#u64 utime ; t#u64 stime ; t#u64 gtime ; s#prev_cputime prev_cputime ; s#vtime vtime ; t#atomic_t tick_dep_mask ; unsigned long nvcsw ; unsigned long nivcsw ; t#u64 start_time ; t#u64 start_boottime ; unsigned long min_flt ; unsigned long maj_flt ; s#posix_cputimers posix_cputimers ; s#posix_cputimers_work posix_cputimers_work ; const s#cred * ptracer_cred ; const s#cred * real_cred ; const s#cred * cred ; s#key * cached_requested_key ; char comm [ E#TASK_COMM_LEN ] ; s#nameidata * nameidata ; s#sysv_sem sysvsem ; s#sysv_shm sysvshm ; unsigned long last_switch_count ; unsigned long last_switch_time ; s#fs_struct * fs ; s#files_struct * files ; s#io_uring_task * io_uring ; s#nsproxy * nsproxy ; s#signal_struct * signal ; s#sighand_struct * sighand ; t#sigset_t blocked ; t#sigset_t real_blocked ; t#sigset_t saved_sigmask ; s#sigpending pending ; unsigned long sas_ss_sp ; t#size_t sas_ss_size ; unsigned int sas_ss_flags ; s#callback_head * task_works ; s#audit_context * audit_context ; t#kuid_t loginuid ; unsigned int sessionid ; s#seccomp seccomp ; s#syscall_user_dispatch syscall_dispatch ; t#u64 parent_exec_id ; t#u64 self_exec_id ; t#spinlock_t alloc_lock ; t#raw_spinlock_t pi_lock ; s#wake_q_node wake_q ; s#rb_root_cached pi_waiters ; s#task_struct * pi_top_task ; s#rt_mutex_waiter * pi_blocked_on ; void * journal_info ; s#bio_list * bio_list ; s#blk_plug * plug ; s#reclaim_state * reclaim_state ; s#io_context * io_context ; s#capture_control * capture_control ; unsigned long ptrace_message ; t#kernel_siginfo_t * last_siginfo ; s#task_io_accounting ioac ; unsigned int psi_flags ; t#u64 acct_rss_mem1 ; t#u64 acct_vm_mem1 ; t#u64 acct_timexpd ; t#nodemask_t mems_allowed ; t#seqcount_spinlock_t mems_allowed_seq ; int cpuset_mem_spread_rotor ; s#css_set * cgroups ; s#list_head cg_list ; t#u32 closid ; t#u32 rmid ; s#robust_list_head * robust_list ; s#compat_robust_list_head * compat_robust_list ; s#list_head pi_state_list ; s#futex_pi_state * pi_state_cache ; s#mutex futex_exit_mutex ; unsigned int futex_state ; t#u8 perf_recursion [ 4 ] ; s#perf_event_context * perf_event_ctxp ; s#mutex perf_event_mutex ; s#list_head perf_event_list ; s#mempolicy * mempolicy ; short il_prev ; t#u8 il_weight ; short pref_node_fork ; int numa_preferred_nid_force ; int numa_scan_seq ; unsigned int numa_scan_period ; unsigned int numa_scan_period_max ; int numa_preferred_nid ; unsigned long numa_migrate_retry ; t#u64 node_stamp ; t#u64 last_task_numa_placement ; t#u64 last_sum_exec_runtime ; s#callback_head numa_work ; s#numa_group * numa_group ; unsigned long * numa_faults ; unsigned long total_numa_faults ; unsigned long numa_faults_locality [ 3 ] ; unsigned long numa_pages_migrated ; s#rseq * rseq ; t#u32 rseq_len ; t#u32 rseq_sig ; unsigned long rseq_event_mask ; int mm_cid ; int last_mm_cid ; int migrate_from_cpu ; int mm_cid_active ; s#callback_head cid_work ; s#tlbflush_unmap_batch tlb_ubc ; s#pipe_inode_info * splice_pipe ; s#page_frag task_frag ; s#task_delay_info * delays ; int nr_dirtied ; int nr_dirtied_pause ; unsigned long dirty_paused_when ; t#u64 timer_slack_ns ; t#u64 default_timer_slack_ns ; int curr_ret_stack ; int curr_ret_depth ; unsigned long * ret_stack ; unsigned long long ftrace_timestamp ; t#atomic_t trace_overrun ; t#atomic_t tracing_graph_pause ; unsigned long trace_recursion ; s#mem_cgroup * memcg_in_oom ; unsigned int memcg_nr_pages_over_high ; s#mem_cgroup * active_memcg ; s#obj_cgroup * objcg ; s#gendisk * throttle_disk ; s#uprobe_task * utask ; unsigned int sequential_io ; unsigned int sequential_io_avg ; s#kmap_ctrl kmap_ctrl ; s#callback_head rcu ; t#refcount_t rcu_users ; int pagefault_disabled ; s#task_struct * oom_reaper_list ; s#timer_list oom_reaper_timer ; s#vm_struct * stack_vm_area ; t#refcount_t stack_refcount ; void * security ; s#bpf_local_storage * bpf_storage ; s#bpf_run_ctx * bpf_ctx ; s#bpf_net_context * bpf_net_context ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; unsigned long uek_reserved9 ; unsigned long uek_reserved10 ; void * mce_vaddr ; t#__u64 mce_kflags ; t#u64 mce_addr ; t#__u64 mce_ripv : 1 , mce_whole_page : 1 , __mce_reserved : 62 ; s#callback_head mce_kill_me ; int mce_count ; s#llist_head kretprobe_instances ; s#llist_head rethooks ; s#callback_head l1d_flush_kill ; s#thread_struct thread ; }
s#tasklet_struct struct tasklet_struct { s#tasklet_struct * next ; unsigned long state ; t#atomic_t count ; t#bool use_callback ; union { void ( * func ) ( unsigned long ) ; void ( * callback ) ( s#tasklet_struct * ) ; } ; unsigned long data ; }
s#taskstats@43548338 struct taskstats { UNKNOWN }
s#taskstats@ff2eca7f struct taskstats { t#__u16 version ; t#__u32 ac_exitcode ; t#__u8 ac_flag ; t#__u8 ac_nice ; t#__u64 cpu_count __attribute__ ( ( aligned ( 8 ) ) ) ; t#__u64 cpu_delay_total ; t#__u64 blkio_count ; t#__u64 blkio_delay_total ; t#__u64 swapin_count ; t#__u64 swapin_delay_total ; t#__u64 cpu_run_real_total ; t#__u64 cpu_run_virtual_total ; char ac_comm [ 32 ] ; t#__u8 ac_sched __attribute__ ( ( aligned ( 8 ) ) ) ; t#__u8 ac_pad [ 3 ] ; t#__u32 ac_uid __attribute__ ( ( aligned ( 8 ) ) ) ; t#__u32 ac_gid ; t#__u32 ac_pid ; t#__u32 ac_ppid ; t#__u32 ac_btime ; t#__u64 ac_etime __attribute__ ( ( aligned ( 8 ) ) ) ; t#__u64 ac_utime ; t#__u64 ac_stime ; t#__u64 ac_minflt ; t#__u64 ac_majflt ; t#__u64 coremem ; t#__u64 virtmem ; t#__u64 hiwater_rss ; t#__u64 hiwater_vm ; t#__u64 read_char ; t#__u64 write_char ; t#__u64 read_syscalls ; t#__u64 write_syscalls ; t#__u64 read_bytes ; t#__u64 write_bytes ; t#__u64 cancelled_write_bytes ; t#__u64 nvcsw ; t#__u64 nivcsw ; t#__u64 ac_utimescaled ; t#__u64 ac_stimescaled ; t#__u64 cpu_scaled_run_real_total ; t#__u64 freepages_count ; t#__u64 freepages_delay_total ; t#__u64 thrashing_count ; t#__u64 thrashing_delay_total ; t#__u64 ac_btime64 ; t#__u64 compact_count ; t#__u64 compact_delay_total ; t#__u32 ac_tgid ; t#__u64 ac_tgetime __attribute__ ( ( aligned ( 8 ) ) ) ; t#__u64 ac_exe_dev ; t#__u64 ac_exe_inode ; t#__u64 wpcopy_count ; t#__u64 wpcopy_delay_total ; t#__u64 irq_count ; t#__u64 irq_delay_total ; }
s#tc_action struct tc_action { const s#tc_action_ops * ops ; t#__u32 type ; s#tcf_idrinfo * idrinfo ; t#u32 tcfa_index ; t#refcount_t tcfa_refcnt ; t#atomic_t tcfa_bindcnt ; int tcfa_action ; s#tcf_t tcfa_tm ; s#gnet_stats_basic_sync tcfa_bstats ; s#gnet_stats_basic_sync tcfa_bstats_hw ; s#gnet_stats_queue tcfa_qstats ; s#net_rate_estimator * tcfa_rate_est ; t#spinlock_t tcfa_lock ; s#gnet_stats_basic_sync * cpu_bstats ; s#gnet_stats_basic_sync * cpu_bstats_hw ; s#gnet_stats_queue * cpu_qstats ; s#tc_cookie * user_cookie ; s#tcf_chain * goto_chain ; t#u32 tcfa_flags ; t#u8 hw_stats ; t#u8 used_hw_stats ; t#bool used_hw_stats_valid ; t#u32 in_hw_count ; }
s#tc_action_ops struct tc_action_ops { s#list_head head ; char kind [ 16 ] ; e#tca_id id ; unsigned int net_id ; t#size_t size ; s#module * owner ; int ( * act ) ( s#sk_buff * , const s#tc_action * , s#tcf_result * ) ; int ( * dump ) ( s#sk_buff * , s#tc_action * , int , int ) ; void ( * cleanup ) ( s#tc_action * ) ; int ( * lookup ) ( s#net * , s#tc_action * * , t#u32 ) ; int ( * init ) ( s#net * , s#nlattr * , s#nlattr * , s#tc_action * * , s#tcf_proto * , t#u32 , s#netlink_ext_ack * ) ; int ( * walk ) ( s#net * , s#sk_buff * , s#netlink_callback * , int , const s#tc_action_ops * , s#netlink_ext_ack * ) ; void ( * stats_update ) ( s#tc_action * , t#u64 , t#u64 , t#u64 , t#u64 , t#bool ) ; t#size_t ( * get_fill_size ) ( const s#tc_action * ) ; s#net_device * ( * get_dev ) ( const s#tc_action * , t#tc_action_priv_destructor * ) ; s#psample_group * ( * get_psample_group ) ( const s#tc_action * , t#tc_action_priv_destructor * ) ; int ( * offload_act_setup ) ( s#tc_action * , void * , t#u32 * , t#bool , s#netlink_ext_ack * ) ; }
s#tc_cookie struct tc_cookie { t#u8 * data ; t#u32 len ; s#callback_head rcu ; }
s#tc_sizespec struct tc_sizespec { unsigned char cell_log ; unsigned char size_log ; short cell_align ; int overhead ; unsigned int linklayer ; unsigned int mpu ; unsigned int mtu ; unsigned int tsize ; }
s#tc_stats struct tc_stats { t#__u64 bytes ; t#__u32 packets ; t#__u32 drops ; t#__u32 overlimits ; t#__u32 bps ; t#__u32 pps ; t#__u32 qlen ; t#__u32 backlog ; }
s#tcf_block struct tcf_block { s#xarray ports ; s#mutex lock ; s#list_head chain_list ; t#u32 index ; t#u32 classid ; t#refcount_t refcnt ; s#net * net ; s#Qdisc * q ; s#rw_semaphore cb_lock ; s#flow_block flow_block ; s#list_head owner_list ; t#bool keep_dst ; t#atomic_t useswcnt ; t#atomic_t offloadcnt ; unsigned int nooffloaddevcnt ; unsigned int lockeddevcnt ; struct { s#tcf_chain * chain ; s#list_head filter_chain_list ; } chain0 ; s#callback_head rcu ; s#hlist_head proto_destroy_ht [ 1 << ( 7 ) ] ; s#mutex proto_destroy_lock ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#tcf_chain struct tcf_chain { s#mutex filter_chain_lock ; s#tcf_proto * filter_chain ; s#list_head list ; s#tcf_block * block ; t#u32 index ; unsigned int refcnt ; unsigned int action_refcnt ; t#bool explicitly_created ; t#bool flushing ; const s#tcf_proto_ops * tmplt_ops ; void * tmplt_priv ; s#callback_head rcu ; }
s#tcf_exts@23125175 struct tcf_exts { t#__u32 type ; int nr_actions ; s#tc_action * * actions ; s#net * net ; t#netns_tracker ns_tracker ; s#tcf_exts_miss_cookie_node * miss_cookie_node ; int action ; int police ; }
s#tcf_exts@805dd0ca struct tcf_exts { UNKNOWN }
s#tcf_exts_miss_cookie_node struct tcf_exts_miss_cookie_node { UNKNOWN }
s#tcf_idrinfo struct tcf_idrinfo { s#mutex lock ; s#idr action_idr ; s#net * net ; }
s#tcf_proto struct tcf_proto { s#tcf_proto * next ; void * root ; int ( * classify ) ( s#sk_buff * , const s#tcf_proto * , s#tcf_result * ) ; t#__be16 protocol ; t#u32 prio ; void * data ; const s#tcf_proto_ops * ops ; s#tcf_chain * chain ; t#spinlock_t lock ; t#bool deleting ; t#bool counted ; t#bool usesw ; t#refcount_t refcnt ; s#callback_head rcu ; s#hlist_node destroy_ht_node ; }
s#tcf_proto_ops struct tcf_proto_ops { s#list_head head ; char kind [ 16 ] ; int ( * classify ) ( s#sk_buff * , const s#tcf_proto * , s#tcf_result * ) ; int ( * init ) ( s#tcf_proto * ) ; void ( * destroy ) ( s#tcf_proto * , t#bool , s#netlink_ext_ack * ) ; void * ( * get ) ( s#tcf_proto * , t#u32 ) ; void ( * put ) ( s#tcf_proto * , void * ) ; int ( * change ) ( s#net * , s#sk_buff * , s#tcf_proto * , unsigned long , t#u32 , s#nlattr * * , void * * , t#u32 , s#netlink_ext_ack * ) ; int ( * delete ) ( s#tcf_proto * , void * , t#bool * , t#bool , s#netlink_ext_ack * ) ; t#bool ( * delete_empty ) ( s#tcf_proto * ) ; void ( * walk ) ( s#tcf_proto * , s#tcf_walker * , t#bool ) ; int ( * reoffload ) ( s#tcf_proto * , t#bool , t#flow_setup_cb_t * , void * , s#netlink_ext_ack * ) ; void ( * hw_add ) ( s#tcf_proto * , void * ) ; void ( * hw_del ) ( s#tcf_proto * , void * ) ; void ( * bind_class ) ( void * , t#u32 , unsigned long , void * , unsigned long ) ; void * ( * tmplt_create ) ( s#net * , s#tcf_chain * , s#nlattr * * , s#netlink_ext_ack * ) ; void ( * tmplt_destroy ) ( void * ) ; void ( * tmplt_reoffload ) ( s#tcf_chain * , t#bool , t#flow_setup_cb_t * , void * ) ; s#tcf_exts * ( * get_exts ) ( const s#tcf_proto * , t#u32 ) ; int ( * dump ) ( s#net * , s#tcf_proto * , void * , s#sk_buff * , s#tcmsg * , t#bool ) ; int ( * terse_dump ) ( s#net * , s#tcf_proto * , void * , s#sk_buff * , s#tcmsg * , t#bool ) ; int ( * tmplt_dump ) ( s#sk_buff * , s#net * , void * ) ; s#module * owner ; int flags ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#tcf_result struct tcf_result { union { struct { unsigned long class ; t#u32 classid ; } ; const s#tcf_proto * goto_tp ; } ; }
s#tcf_t struct tcf_t { t#__u64 install ; t#__u64 lastuse ; t#__u64 expires ; t#__u64 firstuse ; }
s#tcf_walker@0e5bce9a struct tcf_walker { int stop ; int skip ; int count ; t#bool nonempty ; unsigned long cookie ; int ( * fn ) ( s#tcf_proto * , void * , s#tcf_walker * ) ; }
s#tcf_walker@58fadffa struct tcf_walker { UNKNOWN }
s#tcmsg struct tcmsg { unsigned char tcm_family ; unsigned char tcm__pad1 ; unsigned short tcm__pad2 ; int tcm_ifindex ; t#__u32 tcm_handle ; t#__u32 tcm_parent ; t#__u32 tcm_info ; }
s#tcp_bbr_info struct tcp_bbr_info { t#__u32 bbr_bw_lo ; t#__u32 bbr_bw_hi ; t#__u32 bbr_min_rtt ; t#__u32 bbr_pacing_gain ; t#__u32 bbr_cwnd_gain ; }
s#tcp_congestion_ops@a057e2b5 struct tcp_congestion_ops { UNKNOWN }
s#tcp_congestion_ops@f68d33a2 struct tcp_congestion_ops { t#u32 ( * ssthresh ) ( s#sock * ) ; void ( * cong_avoid ) ( s#sock * , t#u32 , t#u32 ) ; void ( * set_state ) ( s#sock * , t#u8 ) ; void ( * cwnd_event ) ( s#sock * , e#tcp_ca_event ) ; void ( * in_ack_event ) ( s#sock * , t#u32 ) ; void ( * pkts_acked ) ( s#sock * , const s#ack_sample * ) ; t#u32 ( * min_tso_segs ) ( s#sock * ) ; void ( * cong_control ) ( s#sock * , t#u32 , int , const s#rate_sample * ) ; t#u32 ( * undo_cwnd ) ( s#sock * ) ; t#u32 ( * sndbuf_expand ) ( s#sock * ) ; t#size_t ( * get_info ) ( s#sock * , t#u32 , int * , u#tcp_cc_info * ) ; char name [ 16 ] ; s#module * owner ; s#list_head list ; t#u32 key ; t#u32 flags ; void ( * init ) ( s#sock * ) ; void ( * release ) ( s#sock * ) ; }
s#tcp_dctcp_info struct tcp_dctcp_info { t#__u16 dctcp_enabled ; t#__u16 dctcp_ce_state ; t#__u32 dctcp_alpha ; t#__u32 dctcp_ab_ecn ; t#__u32 dctcp_ab_tot ; }
s#tcp_fastopen_context@6f553f23 struct tcp_fastopen_context { t#siphash_key_t key [ 2 ] ; int num ; s#callback_head rcu ; }
s#tcp_fastopen_context@8c605e6d struct tcp_fastopen_context { UNKNOWN }
s#tcp_mib struct tcp_mib { unsigned long mibs [ E#__TCP_MIB_MAX ] ; }
s#tcp_states_t struct tcp_states_t { UNKNOWN }
s#tcpvegas_info struct tcpvegas_info { t#__u32 tcpv_enabled ; t#__u32 tcpv_rttcnt ; t#__u32 tcpv_rtt ; t#__u32 tcpv_minrtt ; }
s#thread_group_cputimer struct thread_group_cputimer { s#task_cputime_atomic cputime_atomic ; }
s#thread_info struct thread_info { unsigned long flags ; unsigned long syscall_work ; t#u32 status ; t#u32 cpu ; }
s#thread_shstk struct thread_shstk { t#u64 base ; t#u64 size ; }
s#thread_struct struct thread_struct { s#desc_struct tls_array [ 3 ] ; unsigned long sp ; unsigned short es ; unsigned short ds ; unsigned short fsindex ; unsigned short gsindex ; unsigned long fsbase ; unsigned long gsbase ; s#perf_event * ptrace_bps [ 4 ] ; unsigned long virtual_dr6 ; unsigned long ptrace_dr7 ; unsigned long cr2 ; unsigned long trap_nr ; unsigned long error_code ; s#io_bitmap * io_bitmap ; unsigned long iopl_emul ; unsigned int iopl_warn : 1 ; t#u32 pkru ; unsigned long features ; unsigned long features_locked ; s#thread_shstk shstk ; s#fpu fpu ; }
s#throtl_data struct throtl_data { UNKNOWN }
s#time_namespace@bb07de89 struct time_namespace { s#user_namespace * user_ns ; s#ucounts * ucounts ; s#ns_common ns ; s#timens_offsets offsets ; s#page * vvar_page ; t#bool frozen_offsets ; }
s#time_namespace@dc9d28a7 struct time_namespace { UNKNOWN }
s#timens_offsets struct timens_offsets { s#timespec64 monotonic ; s#timespec64 boottime ; }
s#timer_list struct timer_list { s#hlist_node entry ; unsigned long expires ; void ( * function ) ( s#timer_list * ) ; t#u32 flags ; }
s#timer_rand_state struct timer_rand_state { UNKNOWN }
s#timerqueue_head struct timerqueue_head { s#rb_root_cached rb_root ; }
s#timerqueue_node struct timerqueue_node { s#rb_node node ; t#ktime_t expires ; }
s#timespec64 struct timespec64 { t#time64_t tv_sec ; long tv_nsec ; }
s#timewait_sock_ops@85121b0a struct timewait_sock_ops { s#kmem_cache * twsk_slab ; char * twsk_slab_name ; unsigned int twsk_obj_size ; void ( * twsk_destructor ) ( s#sock * ) ; }
s#timewait_sock_ops@e9b123c0 struct timewait_sock_ops { UNKNOWN }
s#timezone struct timezone { int tz_minuteswest ; int tz_dsttime ; }
s#tipc_bearer@32082cbd struct tipc_bearer { void * media_ptr ; t#u32 mtu ; s#tipc_media_addr addr ; char name [ 32 ] ; s#tipc_media * media ; s#tipc_media_addr bcast_addr ; s#packet_type pt ; s#callback_head rcu ; t#u32 priority ; t#u32 min_win ; t#u32 max_win ; t#u32 tolerance ; t#u32 domain ; t#u32 identity ; s#tipc_discoverer * disc ; char net_plane ; t#u16 encap_hlen ; unsigned long up ; t#refcount_t refcnt ; }
s#tipc_bearer@55f19674 struct tipc_bearer { UNKNOWN }
s#tipc_discoverer struct tipc_discoverer { UNKNOWN }
s#tipc_media struct tipc_media { int ( * send_msg ) ( s#net * , s#sk_buff * , s#tipc_bearer * , s#tipc_media_addr * ) ; int ( * enable_media ) ( s#net * , s#tipc_bearer * , s#nlattr * [ ] ) ; void ( * disable_media ) ( s#tipc_bearer * ) ; int ( * addr2str ) ( s#tipc_media_addr * , char * , int ) ; int ( * addr2msg ) ( char * , s#tipc_media_addr * ) ; int ( * msg2addr ) ( s#tipc_bearer * , s#tipc_media_addr * , char * ) ; int ( * raw2addr ) ( s#tipc_bearer * , s#tipc_media_addr * , const char * ) ; t#u32 priority ; t#u32 tolerance ; t#u32 min_win ; t#u32 max_win ; t#u32 mtu ; t#u32 type_id ; t#u32 hwaddr_len ; char name [ 16 ] ; }
s#tipc_media_addr struct tipc_media_addr { t#u8 value [ 32 ] ; t#u8 media_id ; t#u8 broadcast ; }
s#tlbflush_unmap_batch struct tlbflush_unmap_batch { s#arch_tlbflush_unmap_batch arch ; t#bool flush_required ; t#bool writable ; }
s#tls12_crypto_info_aes_gcm_128 struct tls12_crypto_info_aes_gcm_128 { s#tls_crypto_info info ; unsigned char iv [ 8 ] ; unsigned char key [ 16 ] ; unsigned char salt [ 4 ] ; unsigned char rec_seq [ 8 ] ; }
s#tls12_crypto_info_aes_gcm_256 struct tls12_crypto_info_aes_gcm_256 { s#tls_crypto_info info ; unsigned char iv [ 8 ] ; unsigned char key [ 32 ] ; unsigned char salt [ 4 ] ; unsigned char rec_seq [ 8 ] ; }
s#tls12_crypto_info_chacha20_poly1305 struct tls12_crypto_info_chacha20_poly1305 { s#tls_crypto_info info ; unsigned char iv [ 12 ] ; unsigned char key [ 32 ] ; unsigned char salt [ 0 ] ; unsigned char rec_seq [ 8 ] ; }
s#tls12_crypto_info_sm4_ccm struct tls12_crypto_info_sm4_ccm { s#tls_crypto_info info ; unsigned char iv [ 8 ] ; unsigned char key [ 16 ] ; unsigned char salt [ 4 ] ; unsigned char rec_seq [ 8 ] ; }
s#tls12_crypto_info_sm4_gcm struct tls12_crypto_info_sm4_gcm { s#tls_crypto_info info ; unsigned char iv [ 8 ] ; unsigned char key [ 16 ] ; unsigned char salt [ 4 ] ; unsigned char rec_seq [ 8 ] ; }
s#tls_context struct tls_context { s#tls_prot_info prot_info ; t#u8 tx_conf : 3 ; t#u8 rx_conf : 3 ; t#u8 zerocopy_sendfile : 1 ; t#u8 rx_no_pad : 1 ; int ( * push_pending_record ) ( s#sock * , int ) ; void ( * sk_write_space ) ( s#sock * ) ; void * priv_ctx_tx ; void * priv_ctx_rx ; s#net_device * netdev ; s#cipher_context tx ; s#cipher_context rx ; s#scatterlist * partially_sent_record ; t#u16 partially_sent_offset ; t#bool splicing_pages ; t#bool pending_open_record_frags ; s#mutex tx_lock ; unsigned long flags ; s#proto * sk_proto ; s#sock * sk ; void ( * sk_destruct ) ( s#sock * ) ; u#tls_crypto_context crypto_send ; u#tls_crypto_context crypto_recv ; s#list_head list ; t#refcount_t refcount ; s#callback_head rcu ; }
s#tls_crypto_info struct tls_crypto_info { t#__u16 version ; t#__u16 cipher_type ; }
s#tls_prot_info struct tls_prot_info { t#u16 version ; t#u16 cipher_type ; t#u16 prepend_size ; t#u16 tag_size ; t#u16 overhead_size ; t#u16 iv_size ; t#u16 salt_size ; t#u16 rec_seq_size ; t#u16 aad_size ; t#u16 tail_size ; }
s#tlsdev_ops@4e0b3003 struct tlsdev_ops { UNKNOWN }
s#tlsdev_ops@a62d30e2 struct tlsdev_ops { int ( * tls_dev_add ) ( s#net_device * , s#sock * , e#tls_offload_ctx_dir , s#tls_crypto_info * , t#u32 ) ; void ( * tls_dev_del ) ( s#net_device * , s#tls_context * , e#tls_offload_ctx_dir ) ; int ( * tls_dev_resync ) ( s#net_device * , s#sock * , t#u32 , t#u8 * , e#tls_offload_ctx_dir ) ; }
s#tm struct tm { int tm_sec ; int tm_min ; int tm_hour ; int tm_mday ; int tm_mon ; long tm_year ; int tm_wday ; int tm_yday ; }
s#tnum struct tnum { t#u64 value ; t#u64 mask ; }
s#trace_array@0621e4a4 struct trace_array { UNKNOWN }
s#trace_array@b7744ee1 struct trace_array { s#list_head list ; char * name ; s#array_buffer array_buffer ; s#array_buffer max_buffer ; t#bool allocated_snapshot ; t#spinlock_t snapshot_trigger_lock ; unsigned int snapshot ; unsigned long max_latency ; s#dentry * d_max_latency ; s#work_struct fsnotify_work ; s#irq_work fsnotify_irqwork ; unsigned int mapped ; unsigned long range_addr_start ; unsigned long range_addr_size ; long text_delta ; long data_delta ; s#trace_pid_list * filtered_pids ; s#trace_pid_list * filtered_no_pids ; t#arch_spinlock_t max_lock ; int buffer_disabled ; int sys_refcount_enter ; int sys_refcount_exit ; s#trace_event_file * enter_syscall_files [ ( 463 ) ] ; s#trace_event_file * exit_syscall_files [ ( 463 ) ] ; int stop_count ; int clock_id ; int nr_topts ; t#bool clear_trace ; int buffer_percent ; unsigned int n_err_log_entries ; s#tracer * current_trace ; unsigned int trace_flags ; unsigned char trace_flags_index [ 32 ] ; unsigned int flags ; t#raw_spinlock_t start_lock ; const char * system_names ; s#list_head err_log ; s#dentry * dir ; s#dentry * options ; s#dentry * percpu_dir ; s#eventfs_inode * event_dir ; s#trace_options * topts ; s#list_head systems ; s#list_head events ; s#trace_event_file * trace_marker_file ; t#cpumask_var_t tracing_cpumask ; t#cpumask_var_t pipe_cpumask ; int ref ; int trace_ref ; s#ftrace_ops * ops ; s#trace_pid_list * function_pids ; s#trace_pid_list * function_no_pids ; s#fgraph_ops * gops ; s#list_head func_probes ; s#list_head mod_trace ; s#list_head mod_notrace ; int function_enabled ; int no_filter_buffering_ref ; s#list_head hist_vars ; s#cond_snapshot * cond_snapshot ; s#trace_func_repeats * last_func_repeats ; t#bool ring_buffer_expanded ; }
s#trace_array_cpu struct trace_array_cpu { t#atomic_t disabled ; void * buffer_page ; unsigned long entries ; unsigned long saved_latency ; unsigned long critical_start ; unsigned long critical_end ; unsigned long critical_sequence ; unsigned long nice ; unsigned long policy ; unsigned long rt_priority ; unsigned long skipped_entries ; t#u64 preempt_timestamp ; t#pid_t pid ; t#kuid_t uid ; char comm [ E#TASK_COMM_LEN ] ; int ftrace_ignore_pid ; t#bool ignore_pid ; }
s#trace_buffer struct trace_buffer { UNKNOWN }
s#trace_entry struct trace_entry { unsigned short type ; unsigned char flags ; unsigned char preempt_count ; int pid ; }
s#trace_eval_map@2ac6e30f struct trace_eval_map { UNKNOWN }
s#trace_eval_map@b76c02a9 struct trace_eval_map { const char * system ; const char * eval_string ; unsigned long eval_value ; }
s#trace_event struct trace_event { s#hlist_node node ; int type ; s#trace_event_functions * funcs ; }
s#trace_event_call@1d2f948f struct trace_event_call { s#list_head list ; s#trace_event_class * class ; union { const char * name ; s#tracepoint * tp ; } ; s#trace_event event ; char * print_fmt ; s#event_filter * filter ; union { void * module ; t#atomic_t refcnt ; } ; void * data ; int flags ; int perf_refcount ; s#hlist_head * perf_events ; s#bpf_prog_array * prog_array ; int ( * perf_perm ) ( s#trace_event_call * , s#perf_event * ) ; }
s#trace_event_call@943b33bd struct trace_event_call { UNKNOWN }
s#trace_event_class struct trace_event_class { const char * system ; void * probe ; void * perf_probe ; int ( * reg ) ( s#trace_event_call * , e#trace_reg , void * ) ; s#trace_event_fields * fields_array ; s#list_head * ( * get_fields ) ( s#trace_event_call * ) ; s#list_head fields ; int ( * raw_init ) ( s#trace_event_call * ) ; }
s#trace_event_fields struct trace_event_fields { const char * type ; union { struct { const char * name ; const int size ; const int align ; const unsigned int is_signed : 1 ; unsigned int needs_test : 1 ; const int filter_type ; const int len ; } ; int ( * define_fields ) ( s#trace_event_call * ) ; } ; }
s#trace_event_file struct trace_event_file { s#list_head list ; s#trace_event_call * event_call ; s#event_filter * filter ; s#eventfs_inode * ei ; s#trace_array * tr ; s#trace_subsystem_dir * system ; s#list_head triggers ; unsigned long flags ; t#refcount_t ref ; t#atomic_t sm_ref ; t#atomic_t tm_ref ; }
s#trace_event_functions struct trace_event_functions { t#trace_print_func trace ; t#trace_print_func raw ; t#trace_print_func hex ; t#trace_print_func binary ; }
s#trace_func_repeats struct trace_func_repeats { unsigned long ip ; unsigned long parent_ip ; unsigned long count ; t#u64 ts_last_call ; }
s#trace_iterator struct trace_iterator { s#trace_array * tr ; s#tracer * trace ; s#array_buffer * array_buffer ; void * private ; int cpu_file ; s#mutex mutex ; s#ring_buffer_iter * * buffer_iter ; unsigned long iter_flags ; void * temp ; unsigned int temp_size ; char * fmt ; unsigned int fmt_size ; t#atomic_t wait_index ; s#trace_seq tmp_seq ; t#cpumask_var_t started ; t#bool closed ; t#bool snapshot ; s#trace_seq seq ; s#trace_entry * ent ; unsigned long lost_events ; int leftover ; int ent_size ; int cpu ; t#u64 ts ; t#loff_t pos ; long idx ; unsigned long uek_reserved1 ; }
s#trace_option_dentry struct trace_option_dentry { s#tracer_opt * opt ; s#tracer_flags * flags ; s#trace_array * tr ; s#dentry * entry ; }
s#trace_options struct trace_options { s#tracer * tracer ; s#trace_option_dentry * topts ; }
s#trace_pid_list struct trace_pid_list { t#raw_spinlock_t lock ; s#irq_work refill_irqwork ; u#upper_chunk * upper [ ( 1 << 8 ) ] ; u#upper_chunk * upper_list ; u#lower_chunk * lower_list ; int free_upper_chunks ; int free_lower_chunks ; }
s#trace_seq struct trace_seq { char buffer [ ( 8192 - ( sizeof ( struct seq_buf ) + sizeof ( size_t ) + sizeof ( int ) ) ) ] ; s#seq_buf seq ; t#size_t readpos ; int full ; }
s#trace_subsystem_dir struct trace_subsystem_dir { s#list_head list ; s#event_subsystem * subsystem ; s#trace_array * tr ; s#eventfs_inode * ei ; int ref_count ; int nr_events ; }
s#tracepoint struct tracepoint { const char * name ; s#static_key key ; s#static_call_key * static_call_key ; void * static_call_tramp ; void * iterator ; void * probestub ; int ( * regfunc ) ( void ) ; void ( * unregfunc ) ( void ) ; s#tracepoint_func * funcs ; }
s#tracepoint_func struct tracepoint_func { void * func ; void * data ; int prio ; }
s#tracer@04454c6c struct tracer { const char * name ; int ( * init ) ( s#trace_array * ) ; void ( * reset ) ( s#trace_array * ) ; void ( * start ) ( s#trace_array * ) ; void ( * stop ) ( s#trace_array * ) ; int ( * update_thresh ) ( s#trace_array * ) ; void ( * open ) ( s#trace_iterator * ) ; void ( * pipe_open ) ( s#trace_iterator * ) ; void ( * close ) ( s#trace_iterator * ) ; void ( * pipe_close ) ( s#trace_iterator * ) ; t#ssize_t ( * read ) ( s#trace_iterator * , s#file * , char * , t#size_t , t#loff_t * ) ; t#ssize_t ( * splice_read ) ( s#trace_iterator * , s#file * , t#loff_t * , s#pipe_inode_info * , t#size_t , unsigned int ) ; void ( * print_header ) ( s#seq_file * ) ; e#print_line_t ( * print_line ) ( s#trace_iterator * ) ; int ( * set_flag ) ( s#trace_array * , t#u32 , t#u32 , int ) ; int ( * flag_changed ) ( s#trace_array * , t#u32 , int ) ; s#tracer * next ; s#tracer_flags * flags ; int enabled ; t#bool print_max ; t#bool allow_instances ; t#bool use_max_tr ; t#bool noboot ; }
s#tracer@3969359b struct tracer { UNKNOWN }
s#tracer_flags struct tracer_flags { t#u32 val ; s#tracer_opt * opts ; s#tracer * trace ; }
s#tracer_opt struct tracer_opt { const char * name ; t#u32 bit ; }
s#transport_container struct transport_container { s#attribute_container ac ; const s#attribute_group * statistics ; }
s#tty_audit_buf struct tty_audit_buf { UNKNOWN }
s#tty_buffer struct tty_buffer { union { s#tty_buffer * next ; s#llist_node free ; } ; unsigned int used ; unsigned int size ; unsigned int commit ; unsigned int lookahead ; unsigned int read ; t#bool flags ; t#u8 data [ ] __attribute__ ( ( __aligned__ ( sizeof ( unsigned long ) ) ) ) ; }
s#tty_bufhead struct tty_bufhead { s#tty_buffer * head ; s#work_struct work ; s#mutex lock ; t#atomic_t priority ; s#tty_buffer sentinel ; s#llist_head free ; t#atomic_t mem_used ; int mem_limit ; s#tty_buffer * tail ; }
s#tty_driver@1bbe640d struct tty_driver { s#kref kref ; s#cdev * * cdevs ; s#module * owner ; const char * driver_name ; const char * name ; int name_base ; int major ; int minor_start ; unsigned int num ; short type ; short subtype ; s#ktermios init_termios ; unsigned long flags ; s#proc_dir_entry * proc_entry ; s#tty_driver * other ; s#tty_struct * * ttys ; s#tty_port * * ports ; s#ktermios * * termios ; void * driver_state ; const s#tty_operations * ops ; s#list_head tty_drivers ; }
s#tty_driver@1e9dab09 struct tty_driver { UNKNOWN }
s#tty_ldisc struct tty_ldisc { s#tty_ldisc_ops * ops ; s#tty_struct * tty ; }
s#tty_ldisc_ops struct tty_ldisc_ops { char * name ; int num ; int ( * open ) ( s#tty_struct * ) ; void ( * close ) ( s#tty_struct * ) ; void ( * flush_buffer ) ( s#tty_struct * ) ; t#ssize_t ( * read ) ( s#tty_struct * , s#file * , t#u8 * , t#size_t , void * * , unsigned long ) ; t#ssize_t ( * write ) ( s#tty_struct * , s#file * , const t#u8 * , t#size_t ) ; int ( * ioctl ) ( s#tty_struct * , unsigned int , unsigned long ) ; int ( * compat_ioctl ) ( s#tty_struct * , unsigned int , unsigned long ) ; void ( * set_termios ) ( s#tty_struct * , const s#ktermios * ) ; t#__poll_t ( * poll ) ( s#tty_struct * , s#file * , s#poll_table_struct * ) ; void ( * hangup ) ( s#tty_struct * ) ; void ( * receive_buf ) ( s#tty_struct * , const t#u8 * , const t#u8 * , t#size_t ) ; void ( * write_wakeup ) ( s#tty_struct * ) ; void ( * dcd_change ) ( s#tty_struct * , t#bool ) ; t#size_t ( * receive_buf2 ) ( s#tty_struct * , const t#u8 * , const t#u8 * , t#size_t ) ; void ( * lookahead_buf ) ( s#tty_struct * , const t#u8 * , const t#u8 * , t#size_t ) ; s#module * owner ; }
s#tty_operations struct tty_operations { s#tty_struct * ( * lookup ) ( s#tty_driver * , s#file * , int ) ; int ( * install ) ( s#tty_driver * , s#tty_struct * ) ; void ( * remove ) ( s#tty_driver * , s#tty_struct * ) ; int ( * open ) ( s#tty_struct * , s#file * ) ; void ( * close ) ( s#tty_struct * , s#file * ) ; void ( * shutdown ) ( s#tty_struct * ) ; void ( * cleanup ) ( s#tty_struct * ) ; t#ssize_t ( * write ) ( s#tty_struct * , const t#u8 * , t#size_t ) ; int ( * put_char ) ( s#tty_struct * , t#u8 ) ; void ( * flush_chars ) ( s#tty_struct * ) ; unsigned int ( * write_room ) ( s#tty_struct * ) ; unsigned int ( * chars_in_buffer ) ( s#tty_struct * ) ; int ( * ioctl ) ( s#tty_struct * , unsigned int , unsigned long ) ; long ( * compat_ioctl ) ( s#tty_struct * , unsigned int , unsigned long ) ; void ( * set_termios ) ( s#tty_struct * , const s#ktermios * ) ; void ( * throttle ) ( s#tty_struct * ) ; void ( * unthrottle ) ( s#tty_struct * ) ; void ( * stop ) ( s#tty_struct * ) ; void ( * start ) ( s#tty_struct * ) ; void ( * hangup ) ( s#tty_struct * ) ; int ( * break_ctl ) ( s#tty_struct * , int ) ; void ( * flush_buffer ) ( s#tty_struct * ) ; int ( * ldisc_ok ) ( s#tty_struct * , int ) ; void ( * set_ldisc ) ( s#tty_struct * ) ; void ( * wait_until_sent ) ( s#tty_struct * , int ) ; void ( * send_xchar ) ( s#tty_struct * , t#u8 ) ; int ( * tiocmget ) ( s#tty_struct * ) ; int ( * tiocmset ) ( s#tty_struct * , unsigned int , unsigned int ) ; int ( * resize ) ( s#tty_struct * , s#winsize * ) ; int ( * get_icount ) ( s#tty_struct * , s#serial_icounter_struct * ) ; int ( * get_serial ) ( s#tty_struct * , s#serial_struct * ) ; int ( * set_serial ) ( s#tty_struct * , s#serial_struct * ) ; void ( * show_fdinfo ) ( s#tty_struct * , s#seq_file * ) ; int ( * poll_init ) ( s#tty_driver * , int , char * ) ; int ( * poll_get_char ) ( s#tty_driver * , int ) ; void ( * poll_put_char ) ( s#tty_driver * , int , char ) ; int ( * proc_show ) ( s#seq_file * , void * ) ; }
s#tty_port struct tty_port { s#tty_bufhead buf ; s#tty_struct * tty ; s#tty_struct * itty ; const s#tty_port_operations * ops ; const s#tty_port_client_operations * client_ops ; t#spinlock_t lock ; int blocked_open ; int count ; t#wait_queue_head_t open_wait ; t#wait_queue_head_t delta_msr_wait ; unsigned long flags ; unsigned long iflags ; unsigned char console : 1 ; s#mutex mutex ; s#mutex buf_mutex ; t#u8 * xmit_buf ; struct { union { s#__kfifo kfifo ; t#u8 * type ; const t#u8 * const_type ; char ( * rectype ) [ 0 ] ; t#u8 * ptr ; t#u8 const * ptr_const ; } ; t#u8 buf [ 0 ] ; } xmit_fifo ; unsigned int close_delay ; unsigned int closing_wait ; int drain_delay ; s#kref kref ; void * client_data ; }
s#tty_port_client_operations struct tty_port_client_operations { t#size_t ( * receive_buf ) ( s#tty_port * , const t#u8 * , const t#u8 * , t#size_t ) ; void ( * lookahead_buf ) ( s#tty_port * , const t#u8 * , const t#u8 * , t#size_t ) ; void ( * write_wakeup ) ( s#tty_port * ) ; }
s#tty_port_operations struct tty_port_operations { t#bool ( * carrier_raised ) ( s#tty_port * ) ; void ( * dtr_rts ) ( s#tty_port * , t#bool ) ; void ( * shutdown ) ( s#tty_port * ) ; int ( * activate ) ( s#tty_port * , s#tty_struct * ) ; void ( * destruct ) ( s#tty_port * ) ; }
s#tty_struct@71ff2bce struct tty_struct { UNKNOWN }
s#tty_struct@9bd315b1 struct tty_struct { s#kref kref ; int index ; s#device * dev ; s#tty_driver * driver ; s#tty_port * port ; const s#tty_operations * ops ; s#tty_ldisc * ldisc ; s#ld_semaphore ldisc_sem ; s#mutex atomic_write_lock ; s#mutex legacy_mutex ; s#mutex throttle_mutex ; s#rw_semaphore termios_rwsem ; s#mutex winsize_mutex ; s#ktermios termios , termios_locked ; char name [ 64 ] ; unsigned long flags ; int count ; unsigned int receive_room ; s#winsize winsize ; struct { t#spinlock_t lock ; t#bool stopped ; t#bool tco_stopped ; } flow ; struct { s#pid * pgrp ; s#pid * session ; t#spinlock_t lock ; unsigned char pktstatus ; t#bool packet ; } ctrl ; t#bool hw_stopped ; t#bool closing ; int flow_change ; s#tty_struct * link ; s#fasync_struct * fasync ; t#wait_queue_head_t write_wait ; t#wait_queue_head_t read_wait ; s#work_struct hangup_work ; void * disc_data ; void * driver_data ; t#spinlock_t files_lock ; int write_cnt ; t#u8 * write_buf ; s#list_head tty_files ; s#work_struct SAK_work ; }
s#u64_stats_sync struct u64_stats_sync { }
s#uapi_definition@79e8f687 struct uapi_definition { UNKNOWN }
s#uapi_definition@e25e7334 struct uapi_definition { t#u8 kind ; t#u8 scope ; union { struct { t#u16 object_id ; } object_start ; struct { t#u16 command_num ; t#u8 is_ex : 1 ; t#u8 has_udata : 1 ; t#u8 has_resp : 1 ; t#u8 req_size ; t#u8 resp_size ; } write ; } ; union { t#bool ( * func_is_supported ) ( s#ib_device * ) ; int ( * func_write ) ( s#uverbs_attr_bundle * ) ; const s#uapi_definition * chain ; const s#uverbs_object_def * chain_obj_tree ; t#size_t needs_fn_offset ; } ; }
s#ubuf_info@483e26ff struct ubuf_info { UNKNOWN }
s#ubuf_info@f851873b struct ubuf_info { const s#ubuf_info_ops * ops ; t#refcount_t refcnt ; t#u8 flags ; }
s#ubuf_info_ops struct ubuf_info_ops { void ( * complete ) ( s#sk_buff * , s#ubuf_info * , t#bool ) ; int ( * link_skb ) ( s#sk_buff * , s#ubuf_info * ) ; }
s#ucounts@94c8bcd2 struct ucounts { s#hlist_node node ; s#user_namespace * ns ; t#kuid_t uid ; t#atomic_t count ; t#atomic_long_t ucount [ E#UCOUNT_COUNTS ] ; t#atomic_long_t rlimit [ E#UCOUNT_RLIMIT_COUNTS ] ; }
s#ucounts@ce8044bf struct ucounts { UNKNOWN }
s#udp_hslot struct udp_hslot { s#hlist_head head ; int count ; t#spinlock_t lock ; }
s#udp_mib struct udp_mib { unsigned long mibs [ E#__UDP_MIB_MAX ] ; }
s#udp_table@65f9c4a3 struct udp_table { s#udp_hslot * hash ; s#udp_hslot * hash2 ; unsigned int mask ; unsigned int log ; }
s#udp_table@fd544100 struct udp_table { UNKNOWN }
s#udp_tunnel_info struct udp_tunnel_info { unsigned short type ; t#sa_family_t sa_family ; t#__be16 port ; t#u8 hw_priv ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#udp_tunnel_nic struct udp_tunnel_nic { UNKNOWN }
s#udp_tunnel_nic_info@588e4f93 struct udp_tunnel_nic_info { int ( * set_port ) ( s#net_device * , unsigned int , unsigned int , s#udp_tunnel_info * ) ; int ( * unset_port ) ( s#net_device * , unsigned int , unsigned int , s#udp_tunnel_info * ) ; int ( * sync_table ) ( s#net_device * , unsigned int ) ; s#udp_tunnel_nic_shared * shared ; unsigned int flags ; s#udp_tunnel_nic_table_info tables [ 4 ] ; }
s#udp_tunnel_nic_info@ae20cdf5 struct udp_tunnel_nic_info { UNKNOWN }
s#udp_tunnel_nic_shared struct udp_tunnel_nic_shared { s#udp_tunnel_nic * udp_tunnel_nic_info ; s#list_head devices ; }
s#udp_tunnel_nic_table_info struct udp_tunnel_nic_table_info { unsigned int n_entries ; unsigned int tunnel_types ; }
s#uevent_sock struct uevent_sock { UNKNOWN }
s#uid_gid_extent struct uid_gid_extent { t#u32 first ; t#u32 lower_first ; t#u32 count ; }
s#uid_gid_map struct uid_gid_map { union { struct { s#uid_gid_extent extent [ 5 ] ; t#u32 nr_extents ; } ; struct { s#uid_gid_extent * forward ; s#uid_gid_extent * reverse ; } ; } ; }
s#uncached_list struct uncached_list { UNKNOWN }
s#unix_table struct unix_table { t#spinlock_t * locks ; s#hlist_head * buckets ; }
s#upid struct upid { int nr ; s#pid_namespace * ns ; }
s#uprobe struct uprobe { UNKNOWN }
s#uprobe_task@38512121 struct uprobe_task { UNKNOWN }
s#uprobe_task@d5702d22 struct uprobe_task { e#uprobe_task_state state ; union { struct { s#arch_uprobe_task autask ; unsigned long vaddr ; } ; struct { s#callback_head dup_xol_work ; unsigned long dup_xol_addr ; } ; } ; s#uprobe * active_uprobe ; unsigned long xol_vaddr ; s#arch_uprobe * auprobe ; s#return_instance * return_instances ; unsigned int depth ; }
s#uprobe_xol_ops struct uprobe_xol_ops { UNKNOWN }
s#uprobes_state struct uprobes_state { s#xol_area * xol_area ; }
s#user_namespace@bf1c3b98 struct user_namespace { s#uid_gid_map uid_map ; s#uid_gid_map gid_map ; s#uid_gid_map projid_map ; s#user_namespace * parent ; int level ; t#kuid_t owner ; t#kgid_t group ; s#ns_common ns ; unsigned long flags ; t#bool parent_could_setfcap ; s#list_head keyring_name_list ; s#key * user_keyring_register ; s#rw_semaphore keyring_sem ; s#key * persistent_keyring_register ; s#work_struct work ; s#ctl_table_set set ; s#ctl_table_header * sysctls ; s#ucounts * ucounts ; long ucount_max [ E#UCOUNT_COUNTS ] ; long rlimit_max [ E#UCOUNT_RLIMIT_COUNTS ] ; s#binfmt_misc * binfmt_misc ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#user_namespace@e4129c73 struct user_namespace { UNKNOWN }
s#user_struct struct user_struct { t#refcount_t __count ; s#percpu_counter epoll_watches ; unsigned long unix_inflight ; t#atomic_long_t pipe_bufs ; s#hlist_node uidhash_node ; t#kuid_t uid ; t#atomic_long_t locked_vm ; t#atomic_t nr_watches ; s#ratelimit_state ratelimit ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#userfaultfd_ctx@37162c45 struct userfaultfd_ctx { UNKNOWN }
s#userfaultfd_ctx@d2776060 struct userfaultfd_ctx { t#wait_queue_head_t fault_pending_wqh ; t#wait_queue_head_t fault_wqh ; t#wait_queue_head_t fd_wqh ; t#wait_queue_head_t event_wqh ; t#seqcount_spinlock_t refile_seq ; t#refcount_t refcount ; unsigned int flags ; unsigned int features ; t#bool released ; s#rw_semaphore map_changing_lock ; t#atomic_t mmap_changing ; s#mm_struct * mm ; }
s#uts_namespace@7dd4191c struct uts_namespace { s#new_utsname name ; s#user_namespace * user_ns ; s#ucounts * ucounts ; s#ns_common ns ; }
s#uts_namespace@d3e2a34d struct uts_namespace { UNKNOWN }
s#uv_alloc_info struct uv_alloc_info { int limit ; int blade ; unsigned long offset ; char * name ; }
s#uverbs_api@3604cec6 struct uverbs_api { s#xarray radix ; e#rdma_driver_id driver_id ; unsigned int num_write ; unsigned int num_write_ex ; s#uverbs_api_write_method notsupp_method ; const s#uverbs_api_write_method * * write_methods ; const s#uverbs_api_write_method * * write_ex_methods ; }
s#uverbs_api@ea764430 struct uverbs_api { UNKNOWN }
s#uverbs_api_attr@428d1534 struct uverbs_api_attr { s#uverbs_attr_spec spec ; }
s#uverbs_api_attr@9e8cb8b0 struct uverbs_api_attr { UNKNOWN }
s#uverbs_api_object@3c5e1a24 struct uverbs_api_object { UNKNOWN }
s#uverbs_api_object@a13b7d02 struct uverbs_api_object { const s#uverbs_obj_type * type_attrs ; const s#uverbs_obj_type_class * type_class ; t#u8 disabled : 1 ; t#u32 id ; }
s#uverbs_api_write_method struct uverbs_api_write_method { int ( * handler ) ( s#uverbs_attr_bundle * ) ; t#u8 disabled : 1 ; t#u8 is_ex : 1 ; t#u8 has_udata : 1 ; t#u8 has_resp : 1 ; t#u8 req_size ; t#u8 resp_size ; }
s#uverbs_attr struct uverbs_attr { union { s#uverbs_ptr_attr ptr_attr ; s#uverbs_obj_attr obj_attr ; s#uverbs_objs_arr_attr objs_arr_attr ; } ; }
s#uverbs_attr_bundle@2df4b5b0 struct uverbs_attr_bundle { union { struct { s#ib_udata driver_udata ; s#ib_udata ucore ; s#ib_uverbs_file * ufile ; s#ib_ucontext * context ; s#ib_uobject * uobject ; unsigned long attr_present [ ( ( ( E#UVERBS_API_ATTR_BKEY_LEN ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; } ; s#uverbs_attr_bundle_hdr hdr ; } ; s#uverbs_attr attrs [ ] ; }
s#uverbs_attr_bundle@ff8704af struct uverbs_attr_bundle { UNKNOWN }
s#uverbs_attr_bundle_hdr struct uverbs_attr_bundle_hdr { s#ib_udata driver_udata ; s#ib_udata ucore ; s#ib_uverbs_file * ufile ; s#ib_ucontext * context ; s#ib_uobject * uobject ; unsigned long attr_present [ ( ( ( E#UVERBS_API_ATTR_BKEY_LEN ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; }
s#uverbs_attr_def struct uverbs_attr_def { t#u16 id ; s#uverbs_attr_spec attr ; }
s#uverbs_attr_spec struct uverbs_attr_spec { t#u8 type ; t#u8 zero_trailing : 1 ; t#u8 alloc_and_copy : 1 ; t#u8 mandatory : 1 ; t#u8 is_udata : 1 ; union { struct { t#u16 len ; t#u16 min_len ; } ptr ; struct { t#u16 obj_type ; t#u8 access ; } obj ; struct { t#u8 num_elems ; } enum_def ; } u ; union { struct { const s#uverbs_attr_spec * ids ; } enum_def ; struct { t#u16 obj_type ; t#u16 min_len ; t#u16 max_len ; t#u8 access ; } objs_arr ; } u2 ; }
s#uverbs_method_def struct uverbs_method_def { t#u16 id ; t#u32 flags ; t#size_t num_attrs ; const s#uverbs_attr_def * const ( * attrs ) [ ] ; int ( * handler ) ( s#uverbs_attr_bundle * ) ; }
s#uverbs_obj_attr struct uverbs_obj_attr { s#ib_uobject * uobject ; const s#uverbs_api_attr * attr_elm ; }
s#uverbs_obj_type struct uverbs_obj_type { const s#uverbs_obj_type_class * const type_class ; t#size_t obj_size ; }
s#uverbs_obj_type_class struct uverbs_obj_type_class { s#ib_uobject * ( * alloc_begin ) ( const s#uverbs_api_object * , s#uverbs_attr_bundle * ) ; void ( * alloc_commit ) ( s#ib_uobject * ) ; void ( * alloc_abort ) ( s#ib_uobject * ) ; s#ib_uobject * ( * lookup_get ) ( const s#uverbs_api_object * , s#ib_uverbs_file * , t#s64 , e#rdma_lookup_mode ) ; void ( * lookup_put ) ( s#ib_uobject * , e#rdma_lookup_mode ) ; int __attribute__ ( ( __warn_unused_result__ ) ) ( * destroy_hw ) ( s#ib_uobject * , e#rdma_remove_reason , s#uverbs_attr_bundle * ) ; void ( * remove_handle ) ( s#ib_uobject * ) ; void ( * swap_uobjects ) ( s#ib_uobject * , s#ib_uobject * ) ; }
s#uverbs_object_def struct uverbs_object_def { t#u16 id ; const s#uverbs_obj_type * type_attrs ; t#size_t num_methods ; const s#uverbs_method_def * const ( * methods ) [ ] ; }
s#uverbs_objs_arr_attr struct uverbs_objs_arr_attr { s#ib_uobject * * uobjects ; t#u16 len ; }
s#uverbs_ptr_attr struct uverbs_ptr_attr { union { void * ptr ; t#u64 data ; } ; t#u16 len ; t#u16 uattr_idx ; t#u8 enum_id ; }
s#vdso_image@20f1c9bb struct vdso_image { void * data ; unsigned long size ; unsigned long alt , alt_len ; unsigned long extable_base , extable_len ; const void * extable ; long sym_vvar_start ; long sym_vvar_page ; long sym_pvclock_page ; long sym_hvclock_page ; long sym_timens_page ; long sym_VDSO32_NOTE_MASK ; long sym___kernel_sigreturn ; long sym___kernel_rt_sigreturn ; long sym___kernel_vsyscall ; long sym_int80_landing_pad ; long sym_vdso32_sigreturn_landing_pad ; long sym_vdso32_rt_sigreturn_landing_pad ; }
s#vdso_image@a6dd4e37 struct vdso_image { UNKNOWN }
s#vfsmount struct vfsmount { s#dentry * mnt_root ; s#super_block * mnt_sb ; int mnt_flags ; s#mnt_idmap * mnt_idmap ; }
s#vlan_group struct vlan_group { unsigned int nr_vlan_devs ; s#hlist_node hlist ; s#net_device * * vlan_devices_arrays [ E#VLAN_PROTO_NUM ] [ 8 ] ; }
s#vlan_info@226d9bcf struct vlan_info { s#net_device * real_dev ; s#vlan_group grp ; s#list_head vid_list ; unsigned int nr_vids ; s#callback_head rcu ; }
s#vlan_info@f17b3f88 struct vlan_info { UNKNOWN }
s#vm_area_struct struct vm_area_struct { union { struct { unsigned long vm_start ; unsigned long vm_end ; } ; s#callback_head vm_rcu ; } ; s#mm_struct * vm_mm ; t#pgprot_t vm_page_prot ; union { const t#vm_flags_t vm_flags ; t#vm_flags_t __vm_flags ; } ; t#bool detached ; int vm_lock_seq ; s#vma_lock * vm_lock ; struct { s#rb_node rb ; unsigned long rb_subtree_last ; } shared ; s#list_head anon_vma_chain ; s#anon_vma * anon_vma ; const s#vm_operations_struct * vm_ops ; unsigned long vm_pgoff ; s#file * vm_file ; void * vm_private_data ; t#atomic_long_t swap_readahead_info ; s#mempolicy * vm_policy ; s#vma_numab_state * numab_state ; s#vm_userfaultfd_ctx vm_userfaultfd_ctx ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#vm_fault struct vm_fault { const struct { s#vm_area_struct * vma ; t#gfp_t gfp_mask ; unsigned long pgoff ; unsigned long address ; unsigned long real_address ; } ; e#fault_flag flags ; t#pmd_t * pmd ; t#pud_t * pud ; union { t#pte_t orig_pte ; t#pmd_t orig_pmd ; } ; s#page * cow_page ; s#page * page ; t#pte_t * pte ; t#spinlock_t * ptl ; t#pgtable_t prealloc_pte ; }
s#vm_operations_struct@3620399f struct vm_operations_struct { UNKNOWN }
s#vm_operations_struct@edf46a8f struct vm_operations_struct { void ( * open ) ( s#vm_area_struct * ) ; void ( * close ) ( s#vm_area_struct * ) ; int ( * may_split ) ( s#vm_area_struct * , unsigned long ) ; int ( * mremap ) ( s#vm_area_struct * ) ; int ( * mprotect ) ( s#vm_area_struct * , unsigned long , unsigned long , unsigned long ) ; t#vm_fault_t ( * fault ) ( s#vm_fault * ) ; t#vm_fault_t ( * huge_fault ) ( s#vm_fault * , unsigned int ) ; t#vm_fault_t ( * map_pages ) ( s#vm_fault * , unsigned long , unsigned long ) ; unsigned long ( * pagesize ) ( s#vm_area_struct * ) ; t#vm_fault_t ( * page_mkwrite ) ( s#vm_fault * ) ; t#vm_fault_t ( * pfn_mkwrite ) ( s#vm_fault * ) ; int ( * access ) ( s#vm_area_struct * , unsigned long , void * , int , int ) ; const char * ( * name ) ( s#vm_area_struct * ) ; int ( * set_policy ) ( s#vm_area_struct * , s#mempolicy * ) ; s#mempolicy * ( * get_policy ) ( s#vm_area_struct * , unsigned long , unsigned long * ) ; s#page * ( * find_special_page ) ( s#vm_area_struct * , unsigned long ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#vm_struct@61a4eee6 struct vm_struct { s#vm_struct * next ; void * addr ; unsigned long size ; unsigned long flags ; s#page * * pages ; unsigned int page_order ; unsigned int nr_pages ; t#phys_addr_t phys_addr ; const void * caller ; }
s#vm_struct@b8b98380 struct vm_struct { UNKNOWN }
s#vm_userfaultfd_ctx struct vm_userfaultfd_ctx { s#userfaultfd_ctx * ctx ; }
s#vma_lock struct vma_lock { s#rw_semaphore lock ; }
s#vma_numab_state struct vma_numab_state { unsigned long next_scan ; unsigned long pids_active_reset ; unsigned long pids_active [ 2 ] ; int start_scan_seq ; int prev_scan_seq ; }
s#vmem_altmap struct vmem_altmap { unsigned long base_pfn ; const unsigned long end_pfn ; const unsigned long reserve ; unsigned long free ; unsigned long align ; unsigned long alloc ; t#bool inaccessible ; }
s#vmpressure struct vmpressure { unsigned long scanned ; unsigned long reclaimed ; unsigned long tree_scanned ; unsigned long tree_reclaimed ; t#spinlock_t sr_lock ; s#list_head events ; s#mutex events_lock ; s#work_struct work ; }
s#vtime struct vtime { t#seqcount_t seqcount ; unsigned long long starttime ; e#vtime_state state ; unsigned int cpu ; t#u64 utime ; t#u64 stime ; t#u64 gtime ; }
s#wait_page_queue@402c95c4 struct wait_page_queue { s#folio * folio ; int bit_nr ; t#wait_queue_entry_t wait ; }
s#wait_page_queue@779e9ef8 struct wait_page_queue { UNKNOWN }
s#wait_queue_entry struct wait_queue_entry { unsigned int flags ; void * private ; t#wait_queue_func_t func ; s#list_head entry ; }
s#wait_queue_head struct wait_queue_head { t#spinlock_t lock ; s#list_head head ; }
s#wake_irq@491e180a struct wake_irq { UNKNOWN }
s#wake_irq@c4d4f412 struct wake_irq { s#device * dev ; unsigned int status ; int irq ; const char * name ; }
s#wake_q_node struct wake_q_node { s#wake_q_node * next ; }
s#wakeup_source struct wakeup_source { const char * name ; int id ; s#list_head entry ; t#spinlock_t lock ; s#wake_irq * wakeirq ; s#timer_list timer ; unsigned long timer_expires ; t#ktime_t total_time ; t#ktime_t max_time ; t#ktime_t last_time ; t#ktime_t start_prevent_time ; t#ktime_t prevent_sleep_time ; unsigned long event_count ; unsigned long active_count ; unsigned long relax_count ; unsigned long expire_count ; unsigned long wakeup_count ; s#device * dev ; t#bool active : 1 ; t#bool autosleep_enabled : 1 ; }
s#watch struct watch { union { s#callback_head rcu ; t#u32 info_id ; } ; s#watch_queue * queue ; s#hlist_node queue_node ; s#watch_list * watch_list ; s#hlist_node list_node ; const s#cred * cred ; void * private ; t#u64 id ; s#kref usage ; }
s#watch_filter struct watch_filter { union { s#callback_head rcu ; unsigned long type_filter [ ( ( ( E#WATCH_TYPE__NR ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; } ; t#u32 nr_filters ; s#watch_type_filter filters [ ] ; }
s#watch_list@9efb3bb2 struct watch_list { UNKNOWN }
s#watch_list@dfc9bdaa struct watch_list { s#callback_head rcu ; s#hlist_head watchers ; void ( * release_watch ) ( s#watch * ) ; t#spinlock_t lock ; }
s#watch_queue@9d43b42f struct watch_queue { s#callback_head rcu ; s#watch_filter * filter ; s#pipe_inode_info * pipe ; s#hlist_head watches ; s#page * * notes ; unsigned long * notes_bitmap ; s#kref usage ; t#spinlock_t lock ; unsigned int nr_notes ; unsigned int nr_pages ; }
s#watch_queue@abc0efda struct watch_queue { UNKNOWN }
s#watch_type_filter struct watch_type_filter { e#watch_notification_type type ; t#__u32 subtype_filter [ 1 ] ; t#__u32 info_filter ; t#__u32 info_mask ; }
s#wb_completion struct wb_completion { t#atomic_t cnt ; t#wait_queue_head_t * waitq ; }
s#wb_domain struct wb_domain { t#spinlock_t lock ; s#fprop_global completions ; s#timer_list period_timer ; unsigned long period_time ; unsigned long dirty_limit_tstamp ; unsigned long dirty_limit ; }
s#winsize struct winsize { unsigned short ws_row ; unsigned short ws_col ; unsigned short ws_xpixel ; unsigned short ws_ypixel ; }
s#wiphy struct wiphy { s#mutex mtx ; t#u8 perm_addr [ 6 ] ; t#u8 addr_mask [ 6 ] ; s#mac_address * addresses ; const s#ieee80211_txrx_stypes * mgmt_stypes ; const s#ieee80211_iface_combination * iface_combinations ; int n_iface_combinations ; t#u16 software_iftypes ; t#u16 n_addresses ; t#u16 interface_modes ; t#u16 max_acl_mac_addrs ; t#u32 flags , regulatory_flags , features ; t#u8 ext_features [ ( ( ( E#NUM_NL80211_EXT_FEATURES ) + ( 8 ) - 1 ) / ( 8 ) ) ] ; t#u32 ap_sme_capa ; e#cfg80211_signal_type signal_type ; int bss_priv_size ; t#u8 max_scan_ssids ; t#u8 max_sched_scan_reqs ; t#u8 max_sched_scan_ssids ; t#u8 max_match_sets ; t#u16 max_scan_ie_len ; t#u16 max_sched_scan_ie_len ; t#u32 max_sched_scan_plans ; t#u32 max_sched_scan_plan_interval ; t#u32 max_sched_scan_plan_iterations ; int n_cipher_suites ; const t#u32 * cipher_suites ; int n_akm_suites ; const t#u32 * akm_suites ; const s#wiphy_iftype_akm_suites * iftype_akm_suites ; unsigned int num_iftype_akm_suites ; t#u8 retry_short ; t#u8 retry_long ; t#u32 frag_threshold ; t#u32 rts_threshold ; t#u8 coverage_class ; char fw_version [ 32 ] ; t#u32 hw_version ; const s#wiphy_wowlan_support * wowlan ; s#cfg80211_wowlan * wowlan_config ; t#u16 max_remain_on_channel_duration ; t#u8 max_num_pmkids ; t#u32 available_antennas_tx ; t#u32 available_antennas_rx ; t#u32 probe_resp_offload ; const t#u8 * extended_capabilities , * extended_capabilities_mask ; t#u8 extended_capabilities_len ; const s#wiphy_iftype_ext_capab * iftype_ext_capab ; unsigned int num_iftype_ext_capab ; const void * privid ; s#ieee80211_supported_band * bands [ E#NUM_NL80211_BANDS ] ; void ( * reg_notifier ) ( s#wiphy * , s#regulatory_request * ) ; const s#ieee80211_regdomain * regd ; s#device dev ; t#bool registered ; s#dentry * debugfsdir ; const s#ieee80211_ht_cap * ht_capa_mod_mask ; const s#ieee80211_vht_cap * vht_capa_mod_mask ; s#list_head wdev_list ; t#possible_net_t _net ; const s#iw_handler_def * wext ; const s#wiphy_coalesce_support * coalesce ; const s#wiphy_vendor_command * vendor_commands ; const s#nl80211_vendor_cmd_info * vendor_events ; int n_vendor_commands , n_vendor_events ; t#u16 max_ap_assoc_sta ; t#u8 max_num_csa_counters ; t#u32 bss_select_support ; t#u8 nan_supported_bands ; t#u32 txq_limit ; t#u32 txq_memory_limit ; t#u32 txq_quantum ; unsigned long tx_queue_len ; t#u8 support_mbssid : 1 , support_only_he_mbssid : 1 ; const s#cfg80211_pmsr_capabilities * pmsr_capa ; struct { t#u64 peer , vif ; t#u8 max_retry ; } tid_config_support ; t#u8 max_data_retry_count ; const s#cfg80211_sar_capa * sar_capa ; s#rfkill * rfkill ; t#u8 mbssid_max_interfaces ; t#u8 ema_max_profile_periodicity ; t#u16 max_num_akm_suites ; t#u16 hw_timestamp_max_peers ; int n_radio ; const s#wiphy_radio * radio ; char priv [ ] __attribute__ ( ( __aligned__ ( 32 ) ) ) ; }
s#wiphy_coalesce_support struct wiphy_coalesce_support { int n_rules ; int max_delay ; int n_patterns ; int pattern_max_len ; int pattern_min_len ; int max_pkt_offset ; }
s#wiphy_iftype_akm_suites struct wiphy_iftype_akm_suites { t#u16 iftypes_mask ; const t#u32 * akm_suites ; int n_akm_suites ; }
s#wiphy_iftype_ext_capab struct wiphy_iftype_ext_capab { e#nl80211_iftype iftype ; const t#u8 * extended_capabilities ; const t#u8 * extended_capabilities_mask ; t#u8 extended_capabilities_len ; t#u16 eml_capabilities ; t#u16 mld_capa_and_ops ; }
s#wiphy_radio struct wiphy_radio { const s#wiphy_radio_freq_range * freq_range ; int n_freq_range ; const s#ieee80211_iface_combination * iface_combinations ; int n_iface_combinations ; }
s#wiphy_radio_freq_range struct wiphy_radio_freq_range { t#u32 start_freq ; t#u32 end_freq ; }
s#wiphy_vendor_command struct wiphy_vendor_command { s#nl80211_vendor_cmd_info info ; t#u32 flags ; int ( * doit ) ( s#wiphy * , s#wireless_dev * , const void * , int ) ; int ( * dumpit ) ( s#wiphy * , s#wireless_dev * , s#sk_buff * , const void * , int , unsigned long * ) ; const s#nla_policy * policy ; unsigned int maxattr ; }
s#wiphy_work struct wiphy_work { s#list_head entry ; t#wiphy_work_func_t func ; }
s#wiphy_wowlan_support struct wiphy_wowlan_support { t#u32 flags ; int n_patterns ; int pattern_max_len ; int pattern_min_len ; int max_pkt_offset ; int max_nd_match_sets ; const s#wiphy_wowlan_tcp_support * tcp ; }
s#wiphy_wowlan_tcp_support struct wiphy_wowlan_tcp_support { const s#nl80211_wowlan_tcp_data_token_feature * tok ; t#u32 data_payload_max ; t#u32 data_interval_max ; t#u32 wake_payload_max ; t#bool seq ; }
s#wireless_dev@375c869e struct wireless_dev { s#wiphy * wiphy ; e#nl80211_iftype iftype ; s#list_head list ; s#net_device * netdev ; t#u32 identifier ; s#list_head mgmt_registrations ; t#u8 mgmt_registrations_need_update : 1 ; t#bool use_4addr , is_running , registered , registering ; t#u8 address [ 6 ] __attribute__ ( ( __aligned__ ( sizeof ( u16 ) ) ) ) ; s#cfg80211_conn * conn ; s#cfg80211_cached_keys * connect_keys ; e#ieee80211_bss_type conn_bss_type ; t#u32 conn_owner_nlportid ; s#work_struct disconnect_wk ; t#u8 disconnect_bssid [ 6 ] ; s#list_head event_list ; t#spinlock_t event_lock ; t#u8 connected : 1 ; t#bool ps ; int ps_timeout ; t#u32 ap_unexpected_nlportid ; t#u32 owner_nlportid ; t#bool nl_owner_dead ; struct { s#cfg80211_ibss_params ibss ; s#cfg80211_connect_params connect ; s#cfg80211_cached_keys * keys ; const t#u8 * ie ; t#size_t ie_len ; t#u8 bssid [ 6 ] ; t#u8 prev_bssid [ 6 ] ; t#u8 ssid [ 32 ] ; t#s8 default_key , default_mgmt_key ; t#bool prev_bssid_valid ; } wext ; s#wiphy_work cqm_rssi_work ; s#cfg80211_cqm_config * cqm_config ; s#list_head pmsr_list ; t#spinlock_t pmsr_lock ; s#work_struct pmsr_free_wk ; unsigned long unprot_beacon_reported ; union { struct { t#u8 connected_addr [ 6 ] __attribute__ ( ( __aligned__ ( 2 ) ) ) ; t#u8 ssid [ 32 ] ; t#u8 ssid_len ; } client ; struct { int beacon_interval ; s#cfg80211_chan_def preset_chandef ; s#cfg80211_chan_def chandef ; t#u8 id [ 32 ] ; t#u8 id_len , id_up_len ; } mesh ; struct { s#cfg80211_chan_def preset_chandef ; t#u8 ssid [ 32 ] ; t#u8 ssid_len ; } ap ; struct { s#cfg80211_internal_bss * current_bss ; s#cfg80211_chan_def chandef ; int beacon_interval ; t#u8 ssid [ 32 ] ; t#u8 ssid_len ; } ibss ; struct { s#cfg80211_chan_def chandef ; } ocb ; } u ; struct { t#u8 addr [ 6 ] __attribute__ ( ( __aligned__ ( 2 ) ) ) ; union { struct { unsigned int beacon_interval ; s#cfg80211_chan_def chandef ; } ap ; struct { s#cfg80211_internal_bss * current_bss ; } client ; } ; t#bool cac_started ; unsigned long cac_start_time ; unsigned int cac_time_ms ; } links [ 15 ] ; t#u16 valid_links ; }
s#wireless_dev@7bc3c537 struct wireless_dev { UNKNOWN }
s#work_struct struct work_struct { t#atomic_long_t data ; s#list_head entry ; t#work_func_t func ; }
s#workqueue_struct struct workqueue_struct { UNKNOWN }
s#wpan_dev@dcad4f7d struct wpan_dev { UNKNOWN }
s#wpan_dev@e6997b6f struct wpan_dev { s#wpan_phy * wpan_phy ; int iftype ; s#list_head list ; s#net_device * netdev ; const s#wpan_dev_header_ops * header_ops ; s#net_device * lowpan_dev ; t#u32 identifier ; t#__le16 pan_id ; t#__le16 short_addr ; t#__le64 extended_addr ; t#atomic_t bsn ; t#atomic_t dsn ; t#u8 min_be ; t#u8 max_be ; t#u8 csma_retries ; t#s8 frame_retries ; t#bool lbt ; t#bool ackreq ; s#mutex association_lock ; s#ieee802154_pan_device * parent ; s#list_head children ; unsigned int max_associations ; unsigned int nchildren ; }
s#wpan_dev_header_ops struct wpan_dev_header_ops { int ( * create ) ( s#sk_buff * , s#net_device * , const s#ieee802154_addr * , const s#ieee802154_addr * , unsigned int ) ; }
s#wpan_phy struct wpan_phy { const void * privid ; unsigned long flags ; t#u8 current_channel ; t#u8 current_page ; s#wpan_phy_supported supported ; t#s32 transmit_power ; s#wpan_phy_cca cca ; t#__le64 perm_extended_addr ; t#s32 cca_ed_level ; t#u32 symbol_duration ; t#u16 lifs_period ; t#u16 sifs_period ; s#device dev ; t#possible_net_t _net ; t#spinlock_t queue_lock ; t#atomic_t ongoing_txs ; t#atomic_t hold_txs ; t#wait_queue_head_t sync_txq ; e#ieee802154_filtering_level filtering ; char priv [ ] __attribute__ ( ( __aligned__ ( 32 ) ) ) ; }
s#wpan_phy_cca struct wpan_phy_cca { e#nl802154_cca_modes mode ; e#nl802154_cca_opts opt ; }
s#wpan_phy_supported struct wpan_phy_supported { t#u32 channels [ 31 + 1 ] , cca_modes , cca_opts , iftypes ; e#nl802154_supported_bool_states lbt ; t#u8 min_minbe , max_minbe , min_maxbe , max_maxbe , min_csma_backoffs , max_csma_backoffs ; t#s8 min_frame_retries , max_frame_retries ; t#size_t tx_powers_size , cca_ed_levels_size ; const t#s32 * tx_powers , * cca_ed_levels ; }
s#writeback_control@480d8bf2 struct writeback_control { UNKNOWN }
s#writeback_control@ac4b7257 struct writeback_control { long nr_to_write ; long pages_skipped ; t#loff_t range_start ; t#loff_t range_end ; e#writeback_sync_modes sync_mode ; unsigned for_kupdate : 1 ; unsigned for_background : 1 ; unsigned tagged_writepages : 1 ; unsigned for_reclaim : 1 ; unsigned range_cyclic : 1 ; unsigned for_sync : 1 ; unsigned unpinned_netfs_wb : 1 ; unsigned no_cgroup_owner : 1 ; s#swap_iocb * * swap_plug ; s#list_head * list ; s#folio_batch fbatch ; unsigned long index ; int saved_err ; s#bdi_writeback * wb ; s#inode * inode ; int wb_id ; int wb_lcand_id ; int wb_tcand_id ; t#size_t wb_bytes ; t#size_t wb_lcand_bytes ; t#size_t wb_tcand_bytes ; }
s#ww_acquire_ctx struct ww_acquire_ctx { s#task_struct * task ; unsigned long stamp ; unsigned int acquired ; unsigned short wounded ; unsigned short is_wait_die ; }
s#x86_msi_addr_hi struct x86_msi_addr_hi { t#u32 reserved : 8 , destid_8_31 : 24 ; }
s#x86_msi_addr_lo struct x86_msi_addr_lo { union { struct { t#u32 reserved_0 : 2 , dest_mode_logical : 1 , redirect_hint : 1 , reserved_1 : 1 , virt_destid_8_14 : 7 , destid_0_7 : 8 , base_address : 12 ; } ; struct { t#u32 dmar_reserved_0 : 2 , dmar_index_15 : 1 , dmar_subhandle_valid : 1 , dmar_format : 1 , dmar_index_0_14 : 15 , dmar_base_address : 12 ; } ; } ; }
s#x86_msi_data struct x86_msi_data { union { struct { t#u32 vector : 8 , delivery_mode : 3 , dest_mode_logical : 1 , reserved : 2 , active_low : 1 , is_level : 1 ; } ; t#u32 dmar_subhandle ; } ; }
s#xarray struct xarray { t#spinlock_t xa_lock ; t#gfp_t xa_flags ; void * xa_head ; }
s#xattr struct xattr { const char * name ; void * value ; t#size_t value_len ; }
s#xattr_handler@16eddf4d struct xattr_handler { UNKNOWN }
s#xattr_handler@9dab2a04 struct xattr_handler { const char * name ; const char * prefix ; int flags ; t#bool ( * list ) ( s#dentry * ) ; int ( * get ) ( const s#xattr_handler * , s#dentry * , s#inode * , const char * , void * , t#size_t ) ; int ( * set ) ( const s#xattr_handler * , s#mnt_idmap * , s#dentry * , s#inode * , const char * , const void * , t#size_t , int ) ; }
s#xdp_buff@824aab4a struct xdp_buff { void * data ; void * data_end ; void * data_meta ; void * data_hard_start ; s#xdp_rxq_info * rxq ; s#xdp_txq_info * txq ; t#u32 frame_sz ; t#u32 flags ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#xdp_buff@e3d549f9 struct xdp_buff { UNKNOWN }
s#xdp_buff_xsk struct xdp_buff_xsk { s#xdp_buff xdp ; t#u8 cb [ 24 ] ; t#dma_addr_t dma ; t#dma_addr_t frame_dma ; s#xsk_buff_pool * pool ; t#u64 orig_addr ; s#list_head free_list_node ; s#list_head xskb_list_node ; }
s#xdp_desc struct xdp_desc { t#__u64 addr ; t#__u32 len ; t#__u32 options ; }
s#xdp_dev_bulk_queue struct xdp_dev_bulk_queue { UNKNOWN }
s#xdp_frame@87db4985 struct xdp_frame { void * data ; t#u16 len ; t#u16 headroom ; t#u32 metasize ; s#xdp_mem_info mem ; s#net_device * dev_rx ; t#u32 frame_sz ; t#u32 flags ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#xdp_frame@9dbad4b3 struct xdp_frame { UNKNOWN }
s#xdp_md struct xdp_md { t#__u32 data ; t#__u32 data_end ; t#__u32 data_meta ; t#__u32 ingress_ifindex ; t#__u32 rx_queue_index ; t#__u32 egress_ifindex ; }
s#xdp_mem_info struct xdp_mem_info { t#u32 type ; t#u32 id ; }
s#xdp_metadata_ops@ed3230e7 struct xdp_metadata_ops { int ( * xmo_rx_timestamp ) ( const s#xdp_md * , t#u64 * ) ; int ( * xmo_rx_hash ) ( const s#xdp_md * , t#u32 * , e#xdp_rss_hash_type * ) ; int ( * xmo_rx_vlan_tag ) ( const s#xdp_md * , t#__be16 * , t#u16 * ) ; }
s#xdp_metadata_ops@f9442117 struct xdp_metadata_ops { UNKNOWN }
s#xdp_ring struct xdp_ring { t#u32 producer __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; t#u32 pad1 __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; t#u32 consumer __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; t#u32 pad2 __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; t#u32 flags ; t#u32 pad3 __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; }
s#xdp_rxq_info struct xdp_rxq_info { s#net_device * dev ; t#u32 queue_index ; t#u32 reg_state ; s#xdp_mem_info mem ; unsigned int napi_id ; t#u32 frag_size ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#xdp_txq_info struct xdp_txq_info { s#net_device * dev ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#xdp_umem struct xdp_umem { void * addrs ; t#u64 size ; t#u32 headroom ; t#u32 chunk_size ; t#u32 chunks ; t#u32 npgs ; s#user_struct * user ; t#refcount_t users ; t#u8 flags ; t#u8 tx_metadata_len ; t#bool zc ; s#page * * pgs ; int id ; s#list_head xsk_dma_list ; s#work_struct work ; }
s#xdr_buf struct xdr_buf { s#kvec head [ 1 ] , tail [ 1 ] ; s#bio_vec * bvec ; s#page * * pages ; unsigned int page_base , page_len , flags ; unsigned int buflen , len ; }
s#xdr_netobj struct xdr_netobj { unsigned int len ; t#u8 * data ; }
s#xdr_stream struct xdr_stream { t#__be32 * p ; s#xdr_buf * buf ; t#__be32 * end ; s#kvec * iov ; s#kvec scratch ; s#page * * page_ptr ; void * page_kaddr ; unsigned int nwords ; s#rpc_rqst * rqst ; }
s#xfrm_address_filter struct xfrm_address_filter { t#xfrm_address_t saddr ; t#xfrm_address_t daddr ; t#__u16 family ; t#__u8 splen ; t#__u8 dplen ; }
s#xfrm_algo struct xfrm_algo { char alg_name [ 64 ] ; unsigned int alg_key_len ; char alg_key [ ] ; }
s#xfrm_algo_aead struct xfrm_algo_aead { char alg_name [ 64 ] ; unsigned int alg_key_len ; unsigned int alg_icv_len ; char alg_key [ ] ; }
s#xfrm_algo_auth struct xfrm_algo_auth { char alg_name [ 64 ] ; unsigned int alg_key_len ; unsigned int alg_trunc_len ; char alg_key [ ] ; }
s#xfrm_dev_offload struct xfrm_dev_offload { s#net_device * dev ; t#netdevice_tracker dev_tracker ; s#net_device * real_dev ; unsigned long offload_handle ; t#u8 dir : 2 ; t#u8 type : 2 ; t#u8 flags : 2 ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#xfrm_encap_tmpl struct xfrm_encap_tmpl { t#__u16 encap_type ; t#__be16 encap_sport ; t#__be16 encap_dport ; t#xfrm_address_t encap_oa ; }
s#xfrm_id struct xfrm_id { t#xfrm_address_t daddr ; t#__be32 spi ; t#__u8 proto ; }
s#xfrm_lifetime_cfg struct xfrm_lifetime_cfg { t#__u64 soft_byte_limit ; t#__u64 hard_byte_limit ; t#__u64 soft_packet_limit ; t#__u64 hard_packet_limit ; t#__u64 soft_add_expires_seconds ; t#__u64 hard_add_expires_seconds ; t#__u64 soft_use_expires_seconds ; t#__u64 hard_use_expires_seconds ; }
s#xfrm_lifetime_cur struct xfrm_lifetime_cur { t#__u64 bytes ; t#__u64 packets ; t#__u64 add_time ; t#__u64 use_time ; }
s#xfrm_mark struct xfrm_mark { t#__u32 v ; t#__u32 m ; }
s#xfrm_md_info struct xfrm_md_info { t#u32 if_id ; int link ; s#dst_entry * dst_orig ; }
s#xfrm_mode struct xfrm_mode { t#u8 encap ; t#u8 family ; t#u8 flags ; }
s#xfrm_policy@a692f712 struct xfrm_policy { UNKNOWN }
s#xfrm_policy@f23b9978 struct xfrm_policy { t#possible_net_t xp_net ; s#hlist_node bydst ; s#hlist_node byidx ; s#hlist_head state_cache_list ; t#rwlock_t lock ; t#refcount_t refcnt ; t#u32 pos ; s#timer_list timer ; t#atomic_t genid ; t#u32 priority ; t#u32 index ; t#u32 if_id ; s#xfrm_mark mark ; s#xfrm_selector selector ; s#xfrm_lifetime_cfg lft ; s#xfrm_lifetime_cur curlft ; s#xfrm_policy_walk_entry walk ; s#xfrm_policy_queue polq ; t#bool bydst_reinsert ; t#u8 type ; t#u8 action ; t#u8 flags ; t#u8 xfrm_nr ; t#u16 family ; s#xfrm_sec_ctx * security ; s#xfrm_tmpl xfrm_vec [ 6 ] ; s#callback_head rcu ; s#xfrm_dev_offload xdo ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#xfrm_policy_hash struct xfrm_policy_hash { s#hlist_head * table ; unsigned int hmask ; t#u8 dbits4 ; t#u8 sbits4 ; t#u8 dbits6 ; t#u8 sbits6 ; }
s#xfrm_policy_hthresh struct xfrm_policy_hthresh { s#work_struct work ; t#seqlock_t lock ; t#u8 lbits4 ; t#u8 rbits4 ; t#u8 lbits6 ; t#u8 rbits6 ; }
s#xfrm_policy_queue struct xfrm_policy_queue { s#sk_buff_head hold_queue ; s#timer_list hold_timer ; unsigned long timeout ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; }
s#xfrm_policy_walk_entry struct xfrm_policy_walk_entry { s#list_head all ; t#u8 dead ; }
s#xfrm_replay_state struct xfrm_replay_state { t#__u32 oseq ; t#__u32 seq ; t#__u32 bitmap ; }
s#xfrm_replay_state_esn struct xfrm_replay_state_esn { unsigned int bmp_len ; t#__u32 oseq ; t#__u32 seq ; t#__u32 oseq_hi ; t#__u32 seq_hi ; t#__u32 replay_window ; t#__u32 bmp [ ] ; }
s#xfrm_sec_ctx struct xfrm_sec_ctx { t#__u8 ctx_doi ; t#__u8 ctx_alg ; t#__u16 ctx_len ; t#__u32 ctx_sid ; char ctx_str [ ] ; }
s#xfrm_selector struct xfrm_selector { t#xfrm_address_t daddr ; t#xfrm_address_t saddr ; t#__be16 dport ; t#__be16 dport_mask ; t#__be16 sport ; t#__be16 sport_mask ; t#__u16 family ; t#__u8 prefixlen_d ; t#__u8 prefixlen_s ; t#__u8 proto ; int ifindex ; t#__kernel_uid32_t user ; }
s#xfrm_state@92682e23 struct xfrm_state { UNKNOWN }
s#xfrm_state@9fe0fb67 struct xfrm_state { t#possible_net_t xs_net ; union { s#hlist_node gclist ; s#hlist_node bydst ; } ; union { s#hlist_node dev_gclist ; s#hlist_node bysrc ; } ; s#hlist_node byspi ; s#hlist_node byseq ; s#hlist_node state_cache ; s#hlist_node state_cache_input ; t#refcount_t refcnt ; t#spinlock_t lock ; t#u32 pcpu_num ; s#xfrm_id id ; s#xfrm_selector sel ; s#xfrm_mark mark ; t#u32 if_id ; t#u32 tfcpad ; t#u32 genid ; s#xfrm_state_walk km ; struct { t#u32 reqid ; t#u8 mode ; t#u8 replay_window ; t#u8 aalgo , ealgo , calgo ; t#u8 flags ; t#u16 family ; t#xfrm_address_t saddr ; int header_len ; int trailer_len ; t#u32 extra_flags ; s#xfrm_mark smark ; } props ; s#xfrm_lifetime_cfg lft ; s#xfrm_algo_auth * aalg ; s#xfrm_algo * ealg ; s#xfrm_algo * calg ; s#xfrm_algo_aead * aead ; const char * geniv ; t#__be16 new_mapping_sport ; t#u32 new_mapping ; t#u32 mapping_maxage ; s#xfrm_encap_tmpl * encap ; s#sock * encap_sk ; t#u32 nat_keepalive_interval ; t#time64_t nat_keepalive_expiration ; t#xfrm_address_t * coaddr ; s#xfrm_state * tunnel ; t#atomic_t tunnel_users ; s#xfrm_replay_state replay ; s#xfrm_replay_state_esn * replay_esn ; s#xfrm_replay_state preplay ; s#xfrm_replay_state_esn * preplay_esn ; e#xfrm_replay_mode repl_mode ; t#u32 xflags ; t#u32 replay_maxage ; t#u32 replay_maxdiff ; s#timer_list rtimer ; s#xfrm_stats stats ; s#xfrm_lifetime_cur curlft ; s#hrtimer mtimer ; s#xfrm_dev_offload xso ; long saved_tmo ; t#time64_t lastused ; s#page_frag xfrag ; const s#xfrm_type * type ; s#xfrm_mode inner_mode ; s#xfrm_mode inner_mode_iaf ; s#xfrm_mode outer_mode ; const s#xfrm_type_offload * type_offload ; s#xfrm_sec_ctx * security ; void * data ; t#u8 dir ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; unsigned long uek_reserved8 ; }
s#xfrm_state_walk struct xfrm_state_walk { s#list_head all ; t#u8 state ; t#u8 dying ; t#u8 proto ; t#u32 seq ; s#xfrm_address_filter * filter ; unsigned long uek_reserved1 ; }
s#xfrm_stats struct xfrm_stats { t#__u32 replay_window ; t#__u32 replay ; t#__u32 integrity_failed ; }
s#xfrm_tmpl struct xfrm_tmpl { s#xfrm_id id ; t#xfrm_address_t saddr ; unsigned short encap_family ; t#u32 reqid ; t#u8 mode ; t#u8 share ; t#u8 optional ; t#u8 allalgs ; t#u32 aalgos ; t#u32 ealgos ; t#u32 calgos ; }
s#xfrm_type struct xfrm_type { s#module * owner ; t#u8 proto ; t#u8 flags ; int ( * init_state ) ( s#xfrm_state * , s#netlink_ext_ack * ) ; void ( * destructor ) ( s#xfrm_state * ) ; int ( * input ) ( s#xfrm_state * , s#sk_buff * ) ; int ( * output ) ( s#xfrm_state * , s#sk_buff * ) ; int ( * reject ) ( s#xfrm_state * , s#sk_buff * , const s#flowi * ) ; }
s#xfrm_type_offload struct xfrm_type_offload { s#module * owner ; t#u8 proto ; void ( * encap ) ( s#xfrm_state * , s#sk_buff * ) ; int ( * input_tail ) ( s#xfrm_state * , s#sk_buff * ) ; int ( * xmit ) ( s#xfrm_state * , s#sk_buff * , t#netdev_features_t ) ; }
s#xfrmdev_ops struct xfrmdev_ops { int ( * xdo_dev_state_add ) ( s#xfrm_state * , s#netlink_ext_ack * ) ; void ( * xdo_dev_state_delete ) ( s#xfrm_state * ) ; void ( * xdo_dev_state_free ) ( s#xfrm_state * ) ; t#bool ( * xdo_dev_offload_ok ) ( s#sk_buff * , s#xfrm_state * ) ; void ( * xdo_dev_state_advance_esn ) ( s#xfrm_state * ) ; void ( * xdo_dev_state_update_stats ) ( s#xfrm_state * ) ; int ( * xdo_dev_policy_add ) ( s#xfrm_policy * , s#netlink_ext_ack * ) ; void ( * xdo_dev_policy_delete ) ( s#xfrm_policy * ) ; void ( * xdo_dev_policy_free ) ( s#xfrm_policy * ) ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; unsigned long uek_reserved3 ; unsigned long uek_reserved4 ; unsigned long uek_reserved5 ; unsigned long uek_reserved6 ; unsigned long uek_reserved7 ; }
s#xol_area struct xol_area { UNKNOWN }
s#xprt_class struct xprt_class { s#list_head list ; int ident ; s#rpc_xprt * ( * setup ) ( s#xprt_create * ) ; s#module * owner ; char name [ 32 ] ; const char * netid [ ] ; }
s#xprt_create struct xprt_create { int ident ; s#net * net ; s#sockaddr * srcaddr ; s#sockaddr * dstaddr ; t#size_t addrlen ; const char * servername ; s#svc_xprt * bc_xprt ; s#rpc_xprt_switch * bc_xps ; unsigned int flags ; s#xprtsec_parms xprtsec ; unsigned long connect_timeout ; unsigned long reconnect_timeout ; }
s#xprtsec_parms struct xprtsec_parms { e#xprtsec_policies policy ; t#key_serial_t cert_serial ; t#key_serial_t privkey_serial ; }
s#xps_dev_maps struct xps_dev_maps { s#callback_head rcu ; unsigned int nr_ids ; t#s16 num_tc ; s#xps_map * attr_map [ ] ; }
s#xps_map struct xps_map { unsigned int len ; unsigned int alloc_len ; s#callback_head rcu ; t#u16 queues [ ] ; }
s#xregs_state struct xregs_state { s#fxregs_state i387 ; s#xstate_header header ; t#u8 extended_state_area [ ] ; }
s#xsk_buff_pool@30761ba9 struct xsk_buff_pool { s#device * dev ; s#net_device * netdev ; s#list_head xsk_tx_list ; t#spinlock_t xsk_tx_list_lock ; t#refcount_t users ; s#xdp_umem * umem ; s#work_struct work ; s#list_head free_list ; s#list_head xskb_list ; t#u32 heads_cnt ; t#u16 queue_id ; s#xsk_queue * fq __attribute__ ( ( __aligned__ ( ( 1 << ( 6 ) ) ) ) ) ; s#xsk_queue * cq ; t#dma_addr_t * dma_pages ; s#xdp_buff_xsk * heads ; s#xdp_desc * tx_descs ; t#u64 chunk_mask ; t#u64 addrs_cnt ; t#u32 free_list_cnt ; t#u32 dma_pages_cnt ; t#u32 free_heads_cnt ; t#u32 headroom ; t#u32 chunk_size ; t#u32 chunk_shift ; t#u32 frame_len ; t#u8 tx_metadata_len ; t#u8 cached_need_wakeup ; t#bool uses_need_wakeup ; t#bool unaligned ; t#bool tx_sw_csum ; void * addrs ; t#spinlock_t cq_lock ; s#xdp_buff_xsk * free_heads [ ] ; }
s#xsk_buff_pool@6a898e0c struct xsk_buff_pool { UNKNOWN }
s#xsk_queue@210033fd struct xsk_queue { UNKNOWN }
s#xsk_queue@bc047df1 struct xsk_queue { t#u32 ring_mask ; t#u32 nentries ; t#u32 cached_prod ; t#u32 cached_cons ; s#xdp_ring * ring ; t#u64 invalid_descs ; t#u64 queue_empty_descs ; t#size_t ring_vmalloc_size ; }
s#xsk_tx_metadata_ops@35dc8735 struct xsk_tx_metadata_ops { UNKNOWN }
s#xsk_tx_metadata_ops@b2641782 struct xsk_tx_metadata_ops { void ( * tmo_request_timestamp ) ( void * ) ; t#u64 ( * tmo_fill_timestamp ) ( void * ) ; void ( * tmo_request_checksum ) ( t#u16 , t#u16 , void * ) ; }
s#xstate_header struct xstate_header { t#u64 xfeatures ; t#u64 xcomp_bv ; t#u64 reserved [ 6 ] ; }
s#zone struct zone { unsigned long _watermark [ E#NR_WMARK ] ; unsigned long watermark_boost ; unsigned long nr_reserved_highatomic ; unsigned long nr_free_highatomic ; long lowmem_reserve [ 5 ] ; int node ; s#pglist_data * zone_pgdat ; s#per_cpu_pages * per_cpu_pageset ; s#per_cpu_zonestat * per_cpu_zonestats ; int pageset_high_min ; int pageset_high_max ; int pageset_batch ; unsigned long zone_start_pfn ; t#atomic_long_t managed_pages ; unsigned long spanned_pages ; unsigned long present_pages ; unsigned long present_early_pages ; unsigned long cma_pages ; const char * name ; unsigned long nr_isolate_pageblock ; t#seqlock_t span_seqlock ; int initialized ; s#cacheline_padding _pad1_ ; s#free_area free_area [ ( 10 + 1 ) ] ; s#list_head unaccepted_pages ; unsigned long flags ; t#spinlock_t lock ; s#cacheline_padding _pad2_ ; unsigned long percpu_drift_mark ; unsigned long compact_cached_free_pfn ; unsigned long compact_cached_migrate_pfn [ 2 ] ; unsigned long compact_init_migrate_pfn ; unsigned long compact_init_free_pfn ; unsigned int compact_considered ; unsigned int compact_defer_shift ; int compact_order_failed ; t#bool compact_blockskip_flush ; t#bool contiguous ; s#cacheline_padding _pad3_ ; t#atomic_long_t vm_stat [ E#NR_VM_ZONE_STAT_ITEMS ] ; t#atomic_long_t vm_numa_event [ E#NR_VM_NUMA_EVENT_ITEMS ] ; unsigned long uek_reserved1 ; unsigned long uek_reserved2 ; }
s#zonelist struct zonelist { s#zoneref _zonerefs [ ( ( 1 << 10 ) * 5 ) + 1 ] ; }
s#zoneref struct zoneref { s#zone * zone ; int zone_idx ; }
s#zswap_lruvec_state struct zswap_lruvec_state { t#atomic_long_t nr_disk_swapins ; }
sas_attach_transport extern s#scsi_transport_template * sas_attach_transport ( s#sas_function_template * )
sas_end_device_alloc extern s#sas_rphy * sas_end_device_alloc ( s#sas_port * )
sas_expander_alloc extern s#sas_rphy * sas_expander_alloc ( s#sas_port * , e#sas_device_type )
sas_phy_add extern int sas_phy_add ( s#sas_phy * )
sas_phy_alloc extern s#sas_phy * sas_phy_alloc ( s#device * , int )
sas_phy_delete extern void sas_phy_delete ( s#sas_phy * )
sas_port_add int sas_port_add ( s#sas_port * )
sas_port_add_phy void sas_port_add_phy ( s#sas_port * , s#sas_phy * )
sas_port_alloc_num s#sas_port * sas_port_alloc_num ( s#device * )
sas_port_delete void sas_port_delete ( s#sas_port * )
sas_port_delete_phy void sas_port_delete_phy ( s#sas_port * , s#sas_phy * )
sas_port_free void sas_port_free ( s#sas_port * )
sas_release_transport extern void sas_release_transport ( s#scsi_transport_template * )
sas_rphy_add extern int sas_rphy_add ( s#sas_rphy * )
sas_rphy_free void sas_rphy_free ( s#sas_rphy * )
sb_set_blocksize extern int sb_set_blocksize ( s#super_block * , int )
schedule void schedule ( void )
schedule_timeout extern long schedule_timeout ( long )
schedule_timeout_uninterruptible extern long schedule_timeout_uninterruptible ( long )
scnprintf __attribute__ ( ( __format__ ( printf , 3 , 4 ) ) ) int scnprintf ( char * , t#size_t , const char * , ... )
scsi_add_device extern int scsi_add_device ( s#Scsi_Host * , t#uint , t#uint , t#u64 )
scsi_add_host_with_dma extern int __attribute__ ( ( __warn_unused_result__ ) ) scsi_add_host_with_dma ( s#Scsi_Host * , s#device * , s#device * )
scsi_block_requests extern void scsi_block_requests ( s#Scsi_Host * )
scsi_build_sense_buffer extern void scsi_build_sense_buffer ( int , t#u8 * , t#u8 , t#u8 , t#u8 )
scsi_change_queue_depth extern int scsi_change_queue_depth ( s#scsi_device * , int )
scsi_device_set_state extern int scsi_device_set_state ( s#scsi_device * , e#scsi_device_state )
scsi_device_type extern const char * scsi_device_type ( unsigned )
scsi_dma_map extern int scsi_dma_map ( s#scsi_cmnd * )
scsi_dma_unmap extern void scsi_dma_unmap ( s#scsi_cmnd * )
scsi_done void scsi_done ( s#scsi_cmnd * )
scsi_host_alloc extern s#Scsi_Host * scsi_host_alloc ( const s#scsi_host_template * , int )
scsi_host_busy extern int scsi_host_busy ( s#Scsi_Host * )
scsi_host_put extern void scsi_host_put ( s#Scsi_Host * )
scsi_is_fc_rport int scsi_is_fc_rport ( const s#device * )
scsi_is_host_device int scsi_is_host_device ( const s#device * )
scsi_normalize_sense extern t#bool scsi_normalize_sense ( const t#u8 * , int , s#scsi_sense_hdr * )
scsi_remove_device extern void scsi_remove_device ( s#scsi_device * )
scsi_remove_host extern void scsi_remove_host ( s#Scsi_Host * )
scsi_rescan_device extern int scsi_rescan_device ( s#scsi_device * )
scsi_unblock_requests extern void scsi_unblock_requests ( s#Scsi_Host * )
security_inode_init_security int security_inode_init_security ( s#inode * , s#inode * , const s#qstr * , t#initxattrs t#initxattrs , void * )
send_sig extern int send_sig ( int , s#task_struct * , int )
seq_printf __attribute__ ( ( __format__ ( printf , 2 , 3 ) ) ) void seq_printf ( s#seq_file * , const char * , ... )
set_capacity void set_capacity ( s#gendisk * , t#sector_t )
set_disk_ro void set_disk_ro ( s#gendisk * , t#bool )
set_nlink extern void set_nlink ( s#inode * , unsigned int )
set_normalized_timespec64 extern void set_normalized_timespec64 ( s#timespec64 * , t#time64_t , t#s64 )
set_page_dirty t#bool set_page_dirty ( s#page * )
set_page_writeback void set_page_writeback ( s#page * )
set_user_nice extern void set_user_nice ( s#task_struct * , long )
setattr_prepare int setattr_prepare ( s#mnt_idmap * , s#dentry * , s#iattr * )
sg_copy_from_buffer t#size_t sg_copy_from_buffer ( s#scatterlist * , unsigned int , const void * , t#size_t )
sg_copy_to_buffer t#size_t sg_copy_to_buffer ( s#scatterlist * , unsigned int , void * , t#size_t )
sg_next s#scatterlist * sg_next ( s#scatterlist * )
si_meminfo extern void si_meminfo ( s#sysinfo * )
sigprocmask extern int sigprocmask ( int , t#sigset_t * , t#sigset_t * )
simple_read_from_buffer extern t#ssize_t simple_read_from_buffer ( void * , t#size_t , t#loff_t * , const void * , t#size_t )
simple_strtol extern long simple_strtol ( const char * , char * * , unsigned int )
simple_strtoull extern unsigned long long simple_strtoull ( const char * , char * * , unsigned int )
simple_write_to_buffer extern t#ssize_t simple_write_to_buffer ( void * , t#size_t , t#loff_t * , const void * , t#size_t )
sized_strscpy t#ssize_t sized_strscpy ( char * , const char * , t#size_t )
snprintf __attribute__ ( ( __format__ ( printf , 3 , 4 ) ) ) int snprintf ( char * , t#size_t , const char * , ... )
sock_create_kern int sock_create_kern ( s#net * , int , int , int , s#socket * * )
sock_release void sock_release ( s#socket * )
sock_setsockopt int sock_setsockopt ( s#socket * , int , int , t#sockptr_t , unsigned int )
sockfd_lookup s#socket * sockfd_lookup ( int , int * )
sprint_symbol extern int sprint_symbol ( char * , unsigned long )
sprintf __attribute__ ( ( __format__ ( printf , 2 , 3 ) ) ) int sprintf ( char * , const char * , ... )
sscanf __attribute__ ( ( __format__ ( scanf , 2 , 3 ) ) ) int sscanf ( const char * , const char * , ... )
strchr extern char * strchr ( const char * , int )
strcmp int strcmp ( const char * , const char * )
strcpy char * strcpy ( char * , const char * )
strim extern char * strim ( char * )
strlcat extern t#size_t strlcat ( char * , const char * , t#__kernel_size_t )
strlen t#size_t strlen ( const char * )
strncmp extern int strncmp ( const char * , const char * , t#__kernel_size_t )
strncpy extern char * strncpy ( char * , const char * , t#__kernel_size_t )
strncpy_from_user extern __attribute__ ( ( __warn_unused_result__ ) ) long strncpy_from_user ( char * , const char * , long )
strnlen extern t#__kernel_size_t strnlen ( const char * , t#__kernel_size_t )
strrchr extern char * strrchr ( const char * , int )
strsep extern char * strsep ( char * * , const char * )
strspn extern t#__kernel_size_t strspn ( const char * , const char * )
strstr extern char * strstr ( const char * , const char * )
submit_bio void submit_bio ( s#bio * )
sync_blockdev int sync_blockdev ( s#block_device * )
sys_tz extern s#timezone sys_tz
system_state extern e#system_states system_state
system_wq extern s#workqueue_struct * system_wq
t#Elf64_Addr typedef t#__u64 Elf64_Addr
t#Elf64_Half typedef t#__u16 Elf64_Half
t#Elf64_Sym typedef s#elf64_sym Elf64_Sym
t#Elf64_Word typedef t#__u32 Elf64_Word
t#Elf64_Xword typedef t#__u64 Elf64_Xword
t#__addrpair typedef t#__u64 __addrpair
t#__be16 typedef t#__u16 __be16
t#__be32 typedef t#__u32 __be32
t#__be64 typedef t#__u64 __be64
t#__kernel_clock_t typedef t#__kernel_long_t __kernel_clock_t
t#__kernel_clockid_t typedef int __kernel_clockid_t
t#__kernel_dev_t typedef t#u32 __kernel_dev_t
t#__kernel_fsid_t typedef struct { int val [ 2 ] ; } __kernel_fsid_t
t#__kernel_gid32_t typedef unsigned int __kernel_gid32_t
t#__kernel_loff_t typedef long long __kernel_loff_t
t#__kernel_long_t typedef long __kernel_long_t
t#__kernel_mqd_t typedef int __kernel_mqd_t
t#__kernel_pid_t typedef int __kernel_pid_t
t#__kernel_rwf_t typedef int __kernel_rwf_t
t#__kernel_sa_family_t typedef unsigned short __kernel_sa_family_t
t#__kernel_size_t typedef t#__kernel_ulong_t __kernel_size_t
t#__kernel_ssize_t typedef t#__kernel_long_t __kernel_ssize_t
t#__kernel_time64_t typedef long long __kernel_time64_t
t#__kernel_timer_t typedef int __kernel_timer_t
t#__kernel_uid32_t typedef unsigned int __kernel_uid32_t
t#__kernel_ulong_t typedef unsigned long __kernel_ulong_t
t#__le16 typedef t#__u16 __le16
t#__le32 typedef t#__u32 __le32
t#__le64 typedef t#__u64 __le64
t#__poll_t typedef unsigned __poll_t
t#__portpair typedef t#__u32 __portpair
t#__restorefn_t typedef void __restorefn_t ( void )
t#__s16 typedef __signed__ short __s16
t#__s32 typedef __signed__ int __s32
t#__s64 __extension__ typedef __signed__ long long __s64
t#__s8 typedef __signed__ char __s8
t#__sighandler_t typedef t#__signalfn_t * __sighandler_t
t#__signalfn_t typedef void __signalfn_t ( int )
t#__sigrestore_t typedef t#__restorefn_t * __sigrestore_t
t#__sum16 typedef t#__u16 __sum16
t#__u16 typedef unsigned short __u16
t#__u32 typedef unsigned int __u32
t#__u64 __extension__ typedef unsigned long long __u64
t#__u8 typedef unsigned char __u8
t#__wsum typedef t#__u32 __wsum
t#action_destr typedef void ( * action_destr ) ( void * )
t#activate_complete typedef void ( * activate_complete ) ( void * , int )
t#arch_msi_msg_addr_hi_t typedef s#x86_msi_addr_hi __attribute__ ( ( packed ) ) arch_msi_msg_addr_hi_t
t#arch_msi_msg_addr_lo_t typedef s#x86_msi_addr_lo __attribute__ ( ( packed ) ) arch_msi_msg_addr_lo_t
t#arch_msi_msg_data_t typedef s#x86_msi_data __attribute__ ( ( packed ) ) arch_msi_msg_data_t
t#arch_rwlock_t typedef s#qrwlock arch_rwlock_t
t#arch_spinlock_t typedef s#qspinlock arch_spinlock_t
t#atomic64_t typedef struct { t#s64 counter ; } atomic64_t
t#atomic_long_t typedef t#atomic64_t atomic_long_t
t#atomic_t typedef struct { int counter ; } atomic_t
t#bh_end_io_t typedef void ( bh_end_io_t ) ( s#buffer_head * , int )
t#bio_end_io_t typedef void ( bio_end_io_t ) ( s#bio * )
t#blist_flags_t typedef t#__u64 blist_flags_t
t#blk_features_t typedef unsigned int blk_features_t
t#blk_flags_t typedef unsigned int blk_flags_t
t#blk_insert_t typedef unsigned int blk_insert_t
t#blk_mode_t typedef unsigned int blk_mode_t
t#blk_mq_req_flags_t typedef t#__u32 blk_mq_req_flags_t
t#blk_opf_t typedef t#__u32 blk_opf_t
t#blk_qc_t typedef unsigned int blk_qc_t
t#blk_status_t typedef t#u8 blk_status_t
t#blkcnt_t typedef t#u64 blkcnt_t
t#bool typedef _Bool bool
t#bpf_callback_t typedef t#u64 ( * bpf_callback_t ) ( t#u64 , t#u64 , t#u64 , t#u64 , t#u64 )
t#bpf_iter_fini_seq_priv_t typedef void ( * bpf_iter_fini_seq_priv_t ) ( void * )
t#bpf_iter_init_seq_priv_t typedef int ( * bpf_iter_init_seq_priv_t ) ( void * , s#bpf_iter_aux_info * )
t#bpfptr_t typedef t#sockptr_t bpfptr_t
t#btf_dtor_kfunc_t typedef void ( * btf_dtor_kfunc_t ) ( void * )
t#call_single_data_t typedef s#__call_single_data call_single_data_t
t#cc_t typedef unsigned char cc_t
t#cisco_proto typedef struct { unsigned int interval ; unsigned int timeout ; } cisco_proto
t#clockid_t typedef t#__kernel_clockid_t clockid_t
t#compat_long_t typedef t#s32 compat_long_t
t#compat_uptr_t typedef t#u32 compat_uptr_t
t#cond_update_fn_t typedef t#bool ( * cond_update_fn_t ) ( s#trace_array * , void * )
t#cpu_stop_fn_t typedef int ( * cpu_stop_fn_t ) ( void * )
t#cpumask_t typedef s#cpumask cpumask_t
t#cpumask_var_t typedef s#cpumask * cpumask_var_t
t#dev_t typedef t#__kernel_dev_t dev_t
t#dl_server_has_tasks_f typedef t#bool ( * dl_server_has_tasks_f ) ( s#sched_dl_entity * )
t#dl_server_pick_f typedef s#task_struct * ( * dl_server_pick_f ) ( s#sched_dl_entity * )
t#dma_addr_t typedef t#u64 dma_addr_t
t#dsa_fdb_dump_cb_t typedef int dsa_fdb_dump_cb_t ( const unsigned char * , t#u16 , t#bool , void * )
t#errseq_t typedef t#u32 errseq_t
t#filldir_t typedef t#bool ( * filldir_t ) ( s#dir_context * , const char * , int , t#loff_t , t#u64 , unsigned )
t#filler_t typedef int filler_t ( s#file * , s#folio * )
t#fl_owner_t typedef void * fl_owner_t
t#flow_setup_cb_t typedef int flow_setup_cb_t ( e#tc_setup_type , void * , void * )
t#fmode_t typedef unsigned int fmode_t
t#fop_flags_t typedef unsigned int fop_flags_t
t#fr_proto typedef struct { unsigned int t391 ; unsigned int t392 ; unsigned int n391 ; unsigned int n392 ; unsigned int n393 ; unsigned short lmi ; unsigned short dce ; } fr_proto
t#fr_proto_pvc typedef struct { unsigned int dlci ; } fr_proto_pvc
t#fr_proto_pvc_info typedef struct { unsigned int dlci ; char master [ 16 ] ; } fr_proto_pvc_info
t#freeptr_t typedef struct { unsigned long v ; } freeptr_t
t#fs_param_type typedef int fs_param_type ( s#p_log * , const s#fs_parameter_spec * , s#fs_parameter * , s#fs_parse_result * )
t#ftrace_func_t typedef void ( * ftrace_func_t ) ( unsigned long , unsigned long , s#ftrace_ops * , s#ftrace_regs * )
t#ftrace_ops_func_t typedef int ( * ftrace_ops_func_t ) ( s#ftrace_ops * , e#ftrace_ops_cmd )
t#gate_desc typedef s#gate_struct gate_desc
t#get_block_t typedef int ( get_block_t ) ( s#inode * , t#sector_t , s#buffer_head * , int )
t#gfp_t typedef unsigned int gfp_t
t#gid_t typedef t#__kernel_gid32_t gid_t
t#ib_comp_handler typedef void ( * ib_comp_handler ) ( s#ib_cq * , void * )
t#initxattrs typedef int ( * initxattrs ) ( s#inode * , const s#xattr * , void * )
t#ino_t typedef t#__kernel_ulong_t ino_t
t#int32_t typedef t#s32 int32_t
t#io_req_flags_t typedef t#u64 io_req_flags_t
t#io_req_tw_func_t typedef void ( * io_req_tw_func_t ) ( s#io_kiocb * , s#io_tw_state * )
t#ioasid_t typedef unsigned int ioasid_t
t#iommu_fault_handler_t typedef int ( * iommu_fault_handler_t ) ( s#iommu_domain * , s#device * , unsigned long , int , void * )
t#irq_flow_handler_t typedef void ( * irq_flow_handler_t ) ( s#irq_desc * )
t#irq_handler_t typedef t#irqreturn_t ( * irq_handler_t ) ( int , void * )
t#irq_hw_number_t typedef unsigned long irq_hw_number_t
t#irq_poll_fn typedef int ( irq_poll_fn ) ( s#irq_poll * , int )
t#irqreturn_t typedef e#irqreturn irqreturn_t
t#iw_cm_handler typedef int ( * iw_cm_handler ) ( s#iw_cm_id * , s#iw_cm_event * )
t#iw_event_handler typedef int ( * iw_event_handler ) ( s#iw_cm_id * , s#iw_cm_event * )
t#iw_handler typedef int ( * iw_handler ) ( s#net_device * , s#iw_request_info * , u#iwreq_data * , char * )
t#kernel_cap_t typedef struct { t#u64 val ; } kernel_cap_t
t#kernel_siginfo_t typedef s#kernel_siginfo kernel_siginfo_t
t#kernel_ulong_t typedef unsigned long kernel_ulong_t
t#key_perm_t typedef t#uint32_t key_perm_t
t#key_restrict_link_func_t typedef int ( * key_restrict_link_func_t ) ( s#key * , const s#key_type * , const u#key_payload * , s#key * )
t#key_serial_t typedef t#int32_t key_serial_t
t#kgid_t typedef struct { t#gid_t val ; } kgid_t
t#kmem_buckets typedef s#kmem_cache * kmem_buckets [ ( 12 + 1 ) + 1 ]
t#kprojid_t typedef struct { t#projid_t val ; } kprojid_t
t#ktime_t typedef t#s64 ktime_t
t#kuid_t typedef struct { t#uid_t val ; } kuid_t
t#kxdrdproc_t typedef int ( * kxdrdproc_t ) ( s#rpc_rqst * , s#xdr_stream * , void * )
t#kxdreproc_t typedef void ( * kxdreproc_t ) ( s#rpc_rqst * , s#xdr_stream * , const void * )
t#local64_t typedef struct { t#local_t a ; } local64_t
t#local_t typedef struct { t#atomic_long_t a ; } local_t
t#lockdep_map_p typedef struct { } lockdep_map_p
t#loff_t typedef t#__kernel_loff_t loff_t
t#match_table_t typedef s#match_token match_table_t [ ]
t#mempool_alloc_t typedef void * ( mempool_alloc_t ) ( t#gfp_t , void * )
t#mempool_free_t typedef void ( mempool_free_t ) ( void * , void * )
t#mempool_t typedef s#mempool_s mempool_t
t#mm_context_t typedef struct { t#u64 ctx_id ; t#atomic64_t tlb_gen ; unsigned long next_trim_cpumask ; s#rw_semaphore ldt_usr_sem ; s#ldt_struct * ldt ; unsigned long flags ; s#mutex lock ; void * vdso ; const s#vdso_image * vdso_image ; t#atomic_t perf_rdpmc_allowed ; t#u16 pkey_allocation_map ; t#s16 execute_only_pkey ; } mm_context_t
t#mqd_t typedef t#__kernel_mqd_t mqd_t
t#msi_alloc_info_t typedef s#irq_alloc_info msi_alloc_info_t
t#netdev_features_t typedef t#u64 netdev_features_t
t#netdev_tx_t typedef e#netdev_tx netdev_tx_t
t#netdevice_tracker typedef struct { } netdevice_tracker
t#netfs_io_terminated_t typedef void ( * netfs_io_terminated_t ) ( void * , t#ssize_t , t#bool )
t#netmem_ref typedef unsigned long netmem_ref
t#netns_tracker typedef struct { } netns_tracker
t#nf_hookfn typedef unsigned int nf_hookfn ( void * , s#sk_buff * , const s#nf_hook_state * )
t#nf_logfn typedef void nf_logfn ( s#net * , t#u_int8_t , unsigned int , const s#sk_buff * , const s#net_device * , const s#net_device * , const s#nf_loginfo * , const char * )
t#nfs4_stateid typedef s#nfs4_stateid_struct nfs4_stateid
t#nfs4_verifier typedef struct { char data [ 8 ] ; } nfs4_verifier
t#nlink_t typedef t#u32 nlink_t
t#nodemask_t typedef struct { unsigned long bits [ ( ( ( ( 1 << 10 ) ) + ( ( sizeof ( long ) * 8 ) ) - 1 ) / ( ( sizeof ( long ) * 8 ) ) ) ] ; } nodemask_t
t#notifier_fn_t typedef int ( * notifier_fn_t ) ( s#notifier_block * , unsigned long , void * )
t#nvmem_cell_post_process_t typedef int ( * nvmem_cell_post_process_t ) ( void * , const char * , int , unsigned int , void * , t#size_t )
t#nvmem_reg_read_t typedef int ( * nvmem_reg_read_t ) ( void * , unsigned int , void * , t#size_t )
t#nvmem_reg_write_t typedef int ( * nvmem_reg_write_t ) ( void * , unsigned int , void * , t#size_t )
t#old_time32_t typedef t#s32 old_time32_t
t#p4d_t typedef struct { t#p4dval_t p4d ; } p4d_t
t#p4dval_t typedef unsigned long p4dval_t
t#pci_bus_flags_t typedef unsigned short pci_bus_flags_t
t#pci_channel_state_t typedef unsigned int pci_channel_state_t
t#pci_dev_flags_t typedef unsigned short pci_dev_flags_t
t#pci_ers_result_t typedef unsigned int pci_ers_result_t
t#pci_power_t typedef int pci_power_t
t#percpu_ref_func_t typedef void ( percpu_ref_func_t ) ( s#percpu_ref * )
t#perf_copy_f typedef unsigned long ( * perf_copy_f ) ( void * , const void * , unsigned long , unsigned long )
t#perf_overflow_handler_t typedef void ( * perf_overflow_handler_t ) ( s#perf_event * , s#perf_sample_data * , s#pt_regs * )
t#pgd_t typedef struct { t#pgdval_t pgd ; } pgd_t
t#pgdval_t typedef unsigned long pgdval_t
t#pgprot_t typedef s#pgprot pgprot_t
t#pgprotval_t typedef unsigned long pgprotval_t
t#pgtable_t typedef s#page * pgtable_t
t#phandle typedef t#u32 phandle
t#phy_interface_t typedef enum { PHY_INTERFACE_MODE_NA , PHY_INTERFACE_MODE_INTERNAL , PHY_INTERFACE_MODE_MII , PHY_INTERFACE_MODE_GMII , PHY_INTERFACE_MODE_SGMII , PHY_INTERFACE_MODE_TBI , PHY_INTERFACE_MODE_REVMII , PHY_INTERFACE_MODE_RMII , PHY_INTERFACE_MODE_REVRMII , PHY_INTERFACE_MODE_RGMII , PHY_INTERFACE_MODE_RGMII_ID , PHY_INTERFACE_MODE_RGMII_RXID , PHY_INTERFACE_MODE_RGMII_TXID , PHY_INTERFACE_MODE_RTBI , PHY_INTERFACE_MODE_SMII , PHY_INTERFACE_MODE_XGMII , PHY_INTERFACE_MODE_XLGMII , PHY_INTERFACE_MODE_MOCA , PHY_INTERFACE_MODE_PSGMII , PHY_INTERFACE_MODE_QSGMII , PHY_INTERFACE_MODE_TRGMII , PHY_INTERFACE_MODE_100BASEX , PHY_INTERFACE_MODE_1000BASEX , PHY_INTERFACE_MODE_2500BASEX , PHY_INTERFACE_MODE_5GBASER , PHY_INTERFACE_MODE_RXAUI , PHY_INTERFACE_MODE_XAUI , PHY_INTERFACE_MODE_10GBASER , PHY_INTERFACE_MODE_25GBASER , PHY_INTERFACE_MODE_USXGMII , PHY_INTERFACE_MODE_10GKR , PHY_INTERFACE_MODE_QUSGMII , PHY_INTERFACE_MODE_1000BASEKX , PHY_INTERFACE_MODE_10G_QXGMII , PHY_INTERFACE_MODE_MAX , } phy_interface_t
t#phys_addr_t typedef t#u64 phys_addr_t
t#pid_t typedef t#__kernel_pid_t pid_t
t#pm_message_t typedef s#pm_message pm_message_t
t#pmd_t typedef struct { t#pmdval_t pmd ; } pmd_t
t#pmdval_t typedef unsigned long pmdval_t
t#pn_t typedef u#pn pn_t
t#poll_queue_proc typedef void ( * poll_queue_proc ) ( s#file * , t#wait_queue_head_t * , s#poll_table_struct * )
t#possible_net_t typedef struct { s#net * net ; } possible_net_t
t#proc_handler typedef int proc_handler ( const s#ctl_table * , int , void * , t#size_t * , t#loff_t * )
t#proc_write_t typedef int ( * proc_write_t ) ( s#file * , char * , t#size_t )
t#projid_t typedef t#__kernel_uid32_t projid_t
t#pte_t typedef struct { t#pteval_t pte ; } pte_t
t#pteval_t typedef unsigned long pteval_t
t#pud_t typedef struct { t#pudval_t pud ; } pud_t
t#pudval_t typedef unsigned long pudval_t
t#qsize_t typedef long long qsize_t
t#raw_hdlc_proto typedef struct { unsigned short encoding ; unsigned short parity ; } raw_hdlc_proto
t#raw_spinlock_t typedef s#raw_spinlock raw_spinlock_t
t#rcuref_t typedef struct { t#atomic_t refcnt ; } rcuref_t
t#rdma_cm_event_handler typedef int ( * rdma_cm_event_handler ) ( s#rdma_cm_id * , s#rdma_cm_event * )
t#read_descriptor_t typedef struct { t#size_t written ; t#size_t count ; union { char * buf ; void * data ; } arg ; int error ; } read_descriptor_t
t#refcount_t typedef s#refcount_struct refcount_t
t#release_pages_arg typedef union { s#page * * pages ; s#folio * * folios ; s#encoded_page * * encoded_pages ; } release_pages_arg
t#report_zones_cb typedef int ( * report_zones_cb ) ( s#blk_zone * , unsigned int , void * )
t#req_flags_t typedef t#__u32 req_flags_t
t#request_key_actor_t typedef int ( * request_key_actor_t ) ( s#key * , void * )
t#resource_size_t typedef t#phys_addr_t resource_size_t
t#retpoline_thunk_t typedef t#u8 retpoline_thunk_t [ 32 ]
t#rht_hashfn_t typedef t#u32 ( * rht_hashfn_t ) ( const void * , t#u32 , t#u32 )
t#rht_obj_cmpfn_t typedef int ( * rht_obj_cmpfn_t ) ( s#rhashtable_compare_arg * , const void * )
t#rht_obj_hashfn_t typedef t#u32 ( * rht_obj_hashfn_t ) ( const void * , t#u32 , t#u32 )
t#rpc_authflavor_t typedef t#u32 rpc_authflavor_t
t#rq_end_io_fn typedef e#rq_end_io_ret ( rq_end_io_fn ) ( s#request * , t#blk_status_t )
t#rwf_t typedef t#__kernel_rwf_t rwf_t
t#rwlock_t typedef struct { t#arch_rwlock_t raw_lock ; } rwlock_t
t#rx_handler_func_t typedef t#rx_handler_result_t rx_handler_func_t ( s#sk_buff * * )
t#rx_handler_result_t typedef e#rx_handler_result rx_handler_result_t
t#s16 typedef t#__s16 s16
t#s32 typedef t#__s32 s32
t#s64 typedef t#__s64 s64
t#s8 typedef t#__s8 s8
t#sa_family_t typedef t#__kernel_sa_family_t sa_family_t
t#salt_t typedef u#salt __attribute__ ( ( __packed__ ) ) salt_t
t#sci_t typedef t#u64 sci_t
t#sector_t typedef t#u64 sector_t
t#seqcount_raw_spinlock_t typedef s#seqcount_raw_spinlock seqcount_raw_spinlock_t
t#seqcount_spinlock_t typedef s#seqcount_spinlock seqcount_spinlock_t
t#seqcount_t typedef s#seqcount seqcount_t
t#seqlock_t typedef struct { t#seqcount_spinlock_t seqcount ; t#spinlock_t lock ; } seqlock_t
t#sigset_t typedef struct { unsigned long sig [ ( 64 / 64 ) ] ; } sigset_t
t#sigval_t typedef u#sigval sigval_t
t#siphash_key_t typedef struct { t#u64 key [ 2 ] ; } siphash_key_t
t#size_t typedef t#__kernel_size_t size_t
t#sk_buff_data_t typedef unsigned int sk_buff_data_t
t#sk_read_actor_t typedef int ( * sk_read_actor_t ) ( t#read_descriptor_t * , s#sk_buff * , unsigned int , t#size_t )
t#skb_read_actor_t typedef int ( * skb_read_actor_t ) ( s#sock * , s#sk_buff * )
t#slab_flags_t typedef unsigned int slab_flags_t
t#smp_call_func_t typedef void ( * smp_call_func_t ) ( void * )
t#socket_lock_t typedef struct { t#spinlock_t slock ; int owned ; t#wait_queue_head_t wq ; } socket_lock_t
t#socket_state typedef enum { SS_FREE = 0 , SS_UNCONNECTED , SS_CONNECTING , SS_CONNECTED , SS_DISCONNECTING } socket_state
t#sockptr_t typedef struct { union { void * kernel ; void * user ; } ; t#bool is_kernel : 1 ; } sockptr_t
t#speed_t typedef unsigned int speed_t
t#spinlock_t typedef s#spinlock spinlock_t
t#ssci_t typedef t#u32 ssci_t
t#ssize_t typedef t#__kernel_ssize_t ssize_t
t#substring_t typedef struct { char * from ; char * to ; } substring_t
t#swp_entry_t typedef struct { unsigned long val ; } swp_entry_t
t#sync_serial_settings typedef struct { unsigned int clock_rate ; unsigned int clock_type ; unsigned short loopback ; } sync_serial_settings
t#tc_action_priv_destructor typedef void ( * tc_action_priv_destructor ) ( void * )
t#tcflag_t typedef unsigned int tcflag_t
t#te1_settings typedef struct { unsigned int clock_rate ; unsigned int clock_type ; unsigned short loopback ; unsigned int slot_map ; } te1_settings
t#time64_t typedef t#__s64 time64_t
t#trace_func_graph_ent_t typedef int ( * trace_func_graph_ent_t ) ( s#ftrace_graph_ent * , s#fgraph_ops * )
t#trace_func_graph_ret_t typedef void ( * trace_func_graph_ret_t ) ( s#ftrace_graph_ret * , s#fgraph_ops * )
t#trace_print_func typedef e#print_line_t ( * trace_print_func ) ( s#trace_iterator * , int , s#trace_event * )
t#tracepoint_ptr_t typedef const int tracepoint_ptr_t
t#u16 typedef t#__u16 u16
t#u32 typedef t#__u32 u32
t#u64 typedef t#__u64 u64
t#u64_stats_t typedef struct { t#local64_t v ; } u64_stats_t
t#u8 typedef t#__u8 u8
t#u_char typedef unsigned char u_char
t#u_int16_t typedef t#u16 u_int16_t
t#u_int32_t typedef t#u32 u_int32_t
t#u_int64_t typedef t#u64 u_int64_t
t#u_int8_t typedef t#u8 u_int8_t
t#uid_t typedef t#__kernel_uid32_t uid_t
t#uint typedef unsigned int uint
t#uint32_t typedef t#u32 uint32_t
t#uint64_t typedef t#u64 uint64_t
t#uint8_t typedef t#u8 uint8_t
t#umode_t typedef unsigned short umode_t
t#uuid_t typedef struct { t#__u8 b [ 16 ] ; } uuid_t
t#va_list typedef __builtin_va_list va_list
t#vfsgid_t typedef struct { t#gid_t val ; } vfsgid_t
t#vfsuid_t typedef struct { t#uid_t val ; } vfsuid_t
t#vm_fault_t typedef unsigned int vm_fault_t
t#vm_flags_t typedef unsigned long vm_flags_t
t#wait_queue_entry_t typedef s#wait_queue_entry wait_queue_entry_t
t#wait_queue_func_t typedef int ( * wait_queue_func_t ) ( s#wait_queue_entry * , unsigned , int , void * )
t#wait_queue_head_t typedef s#wait_queue_head wait_queue_head_t
t#wiphy_work_func_t typedef void ( * wiphy_work_func_t ) ( s#wiphy * , s#wiphy_work * )
t#work_func_t typedef void ( * work_func_t ) ( s#work_struct * )
t#x25_hdlc_proto typedef struct { unsigned short dce ; unsigned int modulo ; unsigned int window ; unsigned int t1 ; unsigned int t2 ; unsigned int n2 ; } x25_hdlc_proto
t#xa_mark_t typedef unsigned xa_mark_t
t#xdp_features_t typedef t#u32 xdp_features_t
t#xfrm_address_t typedef union { t#__be32 a4 ; t#__be32 a6 [ 4 ] ; s#in6_addr in6 ; } xfrm_address_t
tag_pages_for_writeback void tag_pages_for_writeback ( s#address_space * , unsigned long , unsigned long )
tasklet_init extern void tasklet_init ( s#tasklet_struct * , void ( * ) ( unsigned long ) , unsigned long )
time64_to_tm void time64_to_tm ( t#time64_t , int , s#tm * )
timer_delete_sync extern int timer_delete_sync ( s#timer_list * )
truncate_inode_pages extern void truncate_inode_pages ( s#address_space * , t#loff_t )
truncate_inode_pages_final extern void truncate_inode_pages_final ( s#address_space * )
truncate_inode_pages_range extern void truncate_inode_pages_range ( s#address_space * , t#loff_t , t#loff_t )
truncate_pagecache extern void truncate_pagecache ( s#inode * , t#loff_t )
truncate_setsize extern void truncate_setsize ( s#inode * , t#loff_t )
try_module_get extern t#bool try_module_get ( s#module * )
u#__sifields union __sifields { struct { t#__kernel_pid_t _pid ; t#__kernel_uid32_t _uid ; } _kill ; struct { t#__kernel_timer_t _tid ; int _overrun ; t#sigval_t _sigval ; int _sys_private ; } _timer ; struct { t#__kernel_pid_t _pid ; t#__kernel_uid32_t _uid ; t#sigval_t _sigval ; } _rt ; struct { t#__kernel_pid_t _pid ; t#__kernel_uid32_t _uid ; int _status ; t#__kernel_clock_t _utime ; t#__kernel_clock_t _stime ; } _sigchld ; struct { void * _addr ; union { int _trapno ; short _addr_lsb ; struct { char _dummy_bnd [ ( __alignof__ ( void * ) < sizeof ( short ) ? sizeof ( short ) : __alignof__ ( void * ) ) ] ; void * _lower ; void * _upper ; } _addr_bnd ; struct { char _dummy_pkey [ ( __alignof__ ( void * ) < sizeof ( short ) ? sizeof ( short ) : __alignof__ ( void * ) ) ] ; t#__u32 _pkey ; } _addr_pkey ; struct { unsigned long _data ; t#__u32 _type ; t#__u32 _flags ; } _perf ; } ; } _sigfault ; struct { long _band ; int _fd ; } _sigpoll ; struct { void * _call_addr ; int _syscall ; unsigned int _arch ; } _sigsys ; }
u#bpf_attr union bpf_attr { struct { t#__u32 map_type ; t#__u32 key_size ; t#__u32 value_size ; t#__u32 max_entries ; t#__u32 map_flags ; t#__u32 inner_map_fd ; t#__u32 numa_node ; char map_name [ 16U ] ; t#__u32 map_ifindex ; t#__u32 btf_fd ; t#__u32 btf_key_type_id ; t#__u32 btf_value_type_id ; t#__u32 btf_vmlinux_value_type_id ; t#__u64 map_extra ; t#__s32 value_type_btf_obj_fd ; t#__s32 map_token_fd ; } ; struct { t#__u32 map_fd ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) key ; union { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) value ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) next_key ; } ; t#__u64 flags ; } ; struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) in_batch ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) out_batch ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) keys ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) values ; t#__u32 count ; t#__u32 map_fd ; t#__u64 elem_flags ; t#__u64 flags ; } batch ; struct { t#__u32 prog_type ; t#__u32 insn_cnt ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) insns ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) license ; t#__u32 log_level ; t#__u32 log_size ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) log_buf ; t#__u32 kern_version ; t#__u32 prog_flags ; char prog_name [ 16U ] ; t#__u32 prog_ifindex ; t#__u32 expected_attach_type ; t#__u32 prog_btf_fd ; t#__u32 func_info_rec_size ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) func_info ; t#__u32 func_info_cnt ; t#__u32 line_info_rec_size ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) line_info ; t#__u32 line_info_cnt ; t#__u32 attach_btf_id ; union { t#__u32 attach_prog_fd ; t#__u32 attach_btf_obj_fd ; } ; t#__u32 core_relo_cnt ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) fd_array ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) core_relos ; t#__u32 core_relo_rec_size ; t#__u32 log_true_size ; t#__s32 prog_token_fd ; } ; struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) pathname ; t#__u32 bpf_fd ; t#__u32 file_flags ; t#__s32 path_fd ; } ; struct { union { t#__u32 target_fd ; t#__u32 target_ifindex ; } ; t#__u32 attach_bpf_fd ; t#__u32 attach_type ; t#__u32 attach_flags ; t#__u32 replace_bpf_fd ; union { t#__u32 relative_fd ; t#__u32 relative_id ; } ; t#__u64 expected_revision ; } ; struct { t#__u32 prog_fd ; t#__u32 retval ; t#__u32 data_size_in ; t#__u32 data_size_out ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) data_in ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) data_out ; t#__u32 repeat ; t#__u32 duration ; t#__u32 ctx_size_in ; t#__u32 ctx_size_out ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) ctx_in ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) ctx_out ; t#__u32 flags ; t#__u32 cpu ; t#__u32 batch_size ; } test ; struct { union { t#__u32 start_id ; t#__u32 prog_id ; t#__u32 map_id ; t#__u32 btf_id ; t#__u32 link_id ; } ; t#__u32 next_id ; t#__u32 open_flags ; } ; struct { t#__u32 bpf_fd ; t#__u32 info_len ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) info ; } info ; struct { union { t#__u32 target_fd ; t#__u32 target_ifindex ; } ; t#__u32 attach_type ; t#__u32 query_flags ; t#__u32 attach_flags ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) prog_ids ; union { t#__u32 prog_cnt ; t#__u32 count ; } ; t#__u32 : 32 ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) prog_attach_flags ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) link_ids ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) link_attach_flags ; t#__u64 revision ; } query ; struct { t#__u64 name ; t#__u32 prog_fd ; t#__u32 : 32 ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) cookie ; } raw_tracepoint ; struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) btf ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) btf_log_buf ; t#__u32 btf_size ; t#__u32 btf_log_size ; t#__u32 btf_log_level ; t#__u32 btf_log_true_size ; t#__u32 btf_flags ; t#__s32 btf_token_fd ; } ; struct { t#__u32 pid ; t#__u32 fd ; t#__u32 flags ; t#__u32 buf_len ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) buf ; t#__u32 prog_id ; t#__u32 fd_type ; t#__u64 probe_offset ; t#__u64 probe_addr ; } task_fd_query ; struct { union { t#__u32 prog_fd ; t#__u32 map_fd ; } ; union { t#__u32 target_fd ; t#__u32 target_ifindex ; } ; t#__u32 attach_type ; t#__u32 flags ; union { t#__u32 target_btf_id ; struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) iter_info ; t#__u32 iter_info_len ; } ; struct { t#__u64 bpf_cookie ; } perf_event ; struct { t#__u32 flags ; t#__u32 cnt ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) syms ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) addrs ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) cookies ; } kprobe_multi ; struct { t#__u32 target_btf_id ; t#__u64 cookie ; } tracing ; struct { t#__u32 pf ; t#__u32 hooknum ; t#__s32 priority ; t#__u32 flags ; } netfilter ; struct { union { t#__u32 relative_fd ; t#__u32 relative_id ; } ; t#__u64 expected_revision ; } tcx ; struct { t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) path ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) offsets ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) ref_ctr_offsets ; t#__u64 __attribute__ ( ( aligned ( 8 ) ) ) cookies ; t#__u32 cnt ; t#__u32 flags ; t#__u32 pid ; } uprobe_multi ; struct { union { t#__u32 relative_fd ; t#__u32 relative_id ; } ; t#__u64 expected_revision ; } netkit ; } ; } link_create ; struct { t#__u32 link_fd ; union { t#__u32 new_prog_fd ; t#__u32 new_map_fd ; } ; t#__u32 flags ; union { t#__u32 old_prog_fd ; t#__u32 old_map_fd ; } ; } link_update ; struct { t#__u32 link_fd ; } link_detach ; struct { t#__u32 type ; } enable_stats ; struct { t#__u32 link_fd ; t#__u32 flags ; } iter_create ; struct { t#__u32 prog_fd ; t#__u32 map_fd ; t#__u32 flags ; } prog_bind_map ; struct { t#__u32 flags ; t#__u32 bpffs_fd ; } token_create ; }
u#cdrom_addr union cdrom_addr { s#cdrom_msf0 msf ; int lba ; }
u#devlink_param_value union devlink_param_value { t#u8 vu8 ; t#u16 vu16 ; t#u32 vu32 ; char vstr [ 32 ] ; t#bool vbool ; }
u#ethtool_flow_union union ethtool_flow_union { s#ethtool_tcpip4_spec tcp_ip4_spec ; s#ethtool_tcpip4_spec udp_ip4_spec ; s#ethtool_tcpip4_spec sctp_ip4_spec ; s#ethtool_ah_espip4_spec ah_ip4_spec ; s#ethtool_ah_espip4_spec esp_ip4_spec ; s#ethtool_usrip4_spec usr_ip4_spec ; s#ethtool_tcpip6_spec tcp_ip6_spec ; s#ethtool_tcpip6_spec udp_ip6_spec ; s#ethtool_tcpip6_spec sctp_ip6_spec ; s#ethtool_ah_espip6_spec ah_ip6_spec ; s#ethtool_ah_espip6_spec esp_ip6_spec ; s#ethtool_usrip6_spec usr_ip6_spec ; s#ethhdr ether_spec ; t#__u8 hdata [ 52 ] ; }
u#flowi_uli union flowi_uli { struct { t#__be16 dport ; t#__be16 sport ; } ports ; struct { t#__u8 type ; t#__u8 code ; } icmpt ; t#__be32 gre_key ; struct { t#__u8 type ; } mht ; }
u#fpregs_state union fpregs_state { s#fregs_state fsave ; s#fxregs_state fxsave ; s#swregs_state soft ; s#xregs_state xsave ; t#u8 __padding [ ( ( 1UL ) << 12 ) ] ; }
u#fscrypt_policy@ca8cb5b3 union fscrypt_policy { t#u8 version ; s#fscrypt_policy_v1 v1 ; s#fscrypt_policy_v2 v2 ; }
u#fscrypt_policy@cc542eb0 union fscrypt_policy { UNKNOWN }
u#gpio_irq_fwspec union gpio_irq_fwspec { s#irq_fwspec fwspec ; t#msi_alloc_info_t msiinfo ; }
u#ib_flow_spec union ib_flow_spec { struct { t#u32 type ; t#u16 size ; } ; s#ib_flow_spec_eth eth ; s#ib_flow_spec_ib ib ; s#ib_flow_spec_ipv4 ipv4 ; s#ib_flow_spec_tcp_udp tcp_udp ; s#ib_flow_spec_ipv6 ipv6 ; s#ib_flow_spec_tunnel tunnel ; s#ib_flow_spec_esp esp ; s#ib_flow_spec_gre gre ; s#ib_flow_spec_mpls mpls ; s#ib_flow_spec_action_tag flow_tag ; s#ib_flow_spec_action_drop drop ; s#ib_flow_spec_action_handle action ; s#ib_flow_spec_action_count flow_count ; s#ib_flow_spec_sniffer sniffer ; }
u#ib_gid union ib_gid { t#u8 raw [ 16 ] ; struct { t#__be64 subnet_prefix ; t#__be64 interface_id ; } global ; }
u#inet_addr union inet_addr { t#__u32 all [ 4 ] ; t#__be32 ip ; t#__be32 ip6 [ 4 ] ; s#in_addr in ; s#in6_addr in6 ; }
u#iwreq_data union iwreq_data { char name [ 16 ] ; s#iw_point essid ; s#iw_param nwid ; s#iw_freq freq ; s#iw_param sens ; s#iw_param bitrate ; s#iw_param txpower ; s#iw_param rts ; s#iw_param frag ; t#__u32 mode ; s#iw_param retry ; s#iw_point encoding ; s#iw_param power ; s#iw_quality qual ; s#sockaddr ap_addr ; s#sockaddr addr ; s#iw_param param ; s#iw_point data ; }
u#key_payload union key_payload { void * rcu_data0 ; void * data [ 4 ] ; }
u#lower_chunk union lower_chunk { u#lower_chunk * next ; unsigned long data [ ( ( 1 << 14 ) / 64 ) ] ; }
u#msi_domain_cookie union msi_domain_cookie { t#u64 value ; void * ptr ; void * iobase ; }
u#msi_instance_cookie union msi_instance_cookie { t#u64 value ; void * ptr ; }
u#nf_conntrack_man_proto union nf_conntrack_man_proto { t#__be16 all ; struct { t#__be16 port ; } tcp ; struct { t#__be16 port ; } udp ; struct { t#__be16 id ; } icmp ; struct { t#__be16 port ; } dccp ; struct { t#__be16 port ; } sctp ; struct { t#__be16 key ; } gre ; }
u#nf_conntrack_proto union nf_conntrack_proto { s#nf_ct_dccp dccp ; s#ip_ct_sctp sctp ; s#ip_ct_tcp tcp ; s#nf_ct_udp udp ; s#nf_ct_gre gre ; unsigned int tmpl_padto ; }
u#nf_inet_addr union nf_inet_addr { t#__u32 all [ 4 ] ; t#__be32 ip ; t#__be32 ip6 [ 4 ] ; s#in_addr in ; s#in6_addr in6 ; }
u#perf_mem_data_src union perf_mem_data_src { t#__u64 val ; struct { t#__u64 mem_op : 5 , mem_lvl : 14 , mem_snoop : 5 , mem_lock : 2 , mem_dtlb : 7 , mem_lvl_num : 4 , mem_remote : 1 , mem_snoopx : 2 , mem_blk : 3 , mem_hops : 3 , mem_rsvd : 18 ; } ; }
u#perf_sample_weight union perf_sample_weight { t#__u64 full ; struct { t#__u32 var1_dw ; t#__u16 var2_w ; t#__u16 var3_w ; } ; }
u#pn union pn { struct { t#u32 lower ; t#u32 upper ; } ; t#u64 full64 ; }
u#rcu_special union rcu_special { struct { t#u8 blocked ; t#u8 need_qs ; t#u8 exp_hint ; t#u8 need_mb ; } b ; t#u32 s ; }
u#salt union salt { struct { t#u32 ssci ; t#u64 pn ; } __attribute__ ( ( __packed__ ) ) ; t#u8 bytes [ 12 ] ; }
u#sigval union sigval { int sival_int ; void * sival_ptr ; }
u#tcp_cc_info@270739f8 union tcp_cc_info { UNKNOWN }
u#tcp_cc_info@dd26ac50 union tcp_cc_info { s#tcpvegas_info vegas ; s#tcp_dctcp_info dctcp ; s#tcp_bbr_info bbr ; }
u#tls_crypto_context union tls_crypto_context { s#tls_crypto_info info ; union { s#tls12_crypto_info_aes_gcm_128 aes_gcm_128 ; s#tls12_crypto_info_aes_gcm_256 aes_gcm_256 ; s#tls12_crypto_info_chacha20_poly1305 chacha20_poly1305 ; s#tls12_crypto_info_sm4_gcm sm4_gcm ; s#tls12_crypto_info_sm4_ccm sm4_ccm ; } ; }
u#upper_chunk union upper_chunk { u#upper_chunk * next ; u#lower_chunk * data [ ( 1 << 8 ) ] ; }
unlock_page void unlock_page ( s#page * )
unlock_rename extern void unlock_rename ( s#dentry * , s#dentry * )
unmap_mapping_range void unmap_mapping_range ( s#address_space * , t#loff_t const , t#loff_t const , int )
unregister_blkdev void unregister_blkdev ( unsigned int , const char * )
unregister_chrdev_region extern void unregister_chrdev_region ( t#dev_t , unsigned )
unregister_filesystem extern int unregister_filesystem ( s#file_system_type * )
unregister_reboot_notifier extern int unregister_reboot_notifier ( s#notifier_block * )
up extern void up ( s#semaphore * )
up_read extern void up_read ( s#rw_semaphore * )
up_write extern void up_write ( s#rw_semaphore * )
usleep_range_state void usleep_range_state ( unsigned long , unsigned long , unsigned int )
vfree extern void vfree ( const void * )
vfs_create_mount extern s#vfsmount * vfs_create_mount ( s#fs_context * )
vfs_fsync extern int vfs_fsync ( s#file * , int )
vfs_fsync_range extern int vfs_fsync_range ( s#file * , t#loff_t , t#loff_t , int )
vfs_iter_read t#ssize_t vfs_iter_read ( s#file * , s#iov_iter * , t#loff_t * , t#rwf_t )
vfs_iter_write t#ssize_t vfs_iter_write ( s#file * , s#iov_iter * , t#loff_t * , t#rwf_t )
vfs_llseek extern t#loff_t vfs_llseek ( s#file * , t#loff_t , int )
vfs_mkdir int vfs_mkdir ( s#mnt_idmap * , s#inode * , s#dentry * , t#umode_t )
vfs_rename int vfs_rename ( s#renamedata * )
vfs_unlink int vfs_unlink ( s#mnt_idmap * , s#inode * , s#dentry * , s#inode * * )
vm_mmap extern unsigned long __attribute__ ( ( __warn_unused_result__ ) ) vm_mmap ( s#file * , unsigned long , unsigned long , unsigned long , unsigned long , unsigned long )
vm_munmap extern int vm_munmap ( unsigned long , t#size_t )
vmalloc_base extern unsigned long vmalloc_base
vmalloc_node_noprof extern void * vmalloc_node_noprof ( unsigned long , int )
vmalloc_noprof extern void * vmalloc_noprof ( unsigned long )
vmalloc_to_page s#page * vmalloc_to_page ( const void * )
vmemmap_base extern unsigned long vmemmap_base
vprintk __attribute__ ( ( __format__ ( printf , 1 , 0 ) ) ) int vprintk ( const char * , t#va_list )
vscnprintf __attribute__ ( ( __format__ ( printf , 3 , 0 ) ) ) int vscnprintf ( char * , t#size_t , const char * , t#va_list )
vsnprintf __attribute__ ( ( __format__ ( printf , 3 , 0 ) ) ) int vsnprintf ( char * , t#size_t , const char * , t#va_list )
vsprintf __attribute__ ( ( __format__ ( printf , 2 , 0 ) ) ) int vsprintf ( char * , const char * , t#va_list )
vzalloc_node_noprof extern void * vzalloc_node_noprof ( unsigned long , int )
vzalloc_noprof extern void * vzalloc_noprof ( unsigned long )
wait_for_completion extern void wait_for_completion ( s#completion * )
wait_for_completion_interruptible extern int wait_for_completion_interruptible ( s#completion * )
wait_for_completion_io_timeout extern unsigned long wait_for_completion_io_timeout ( s#completion * , unsigned long )
wait_for_completion_timeout extern unsigned long wait_for_completion_timeout ( s#completion * , unsigned long )
wake_up_process extern int wake_up_process ( s#task_struct * )
write_inode_now int write_inode_now ( s#inode * , int )
xa_find void * xa_find ( s#xarray * , unsigned long * , unsigned long , t#xa_mark_t )
xa_find_after void * xa_find_after ( s#xarray * , unsigned long * , unsigned long , t#xa_mark_t )
xa_load void * xa_load ( s#xarray * , unsigned long )
yield void yield ( void )
F#arch/x86/kernel/alternative.symtypes BUG_func
F#arch/x86/kernel/cpu/common.symtypes const_pcpu_hot pcpu_hot s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@581f6d64 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@fd172377 s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@7dd4191c s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#arch/x86/kernel/ftrace_64.symtypes __fentry__
F#arch/x86/kernel/head64.symtypes page_offset_base vmalloc_base vmemmap_base
F#arch/x86/kernel/head_64.symtypes empty_zero_page phys_base
F#arch/x86/kernel/paravirt.symtypes pv_ops s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@581f6d64 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@fd172377 s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#arch/x86/kernel/setup.symtypes boot_cpu_data
F#arch/x86/kernel/setup_percpu.symtypes __per_cpu_offset
F#arch/x86/lib/copy_user_64.symtypes rep_movs_alternative
F#arch/x86/lib/delay.symtypes __const_udelay
F#arch/x86/lib/iomem.symtypes memcpy_fromio memcpy_toio
F#arch/x86/lib/memcpy_64.symtypes memcpy
F#arch/x86/lib/memmove_64.symtypes memmove
F#arch/x86/lib/memset_64.symtypes memset
F#arch/x86/lib/retpoline.symtypes __x86_indirect_thunk_r10 __x86_indirect_thunk_r12 __x86_indirect_thunk_r13 __x86_indirect_thunk_r14 __x86_indirect_thunk_r15 __x86_indirect_thunk_r8 __x86_indirect_thunk_rax __x86_indirect_thunk_rbp __x86_indirect_thunk_rbx __x86_indirect_thunk_rcx __x86_indirect_thunk_rdx __x86_return_thunk
F#arch/x86/mm/ioremap.symtypes ioremap iounmap
F#arch/x86/mm/numa.symtypes node_to_cpumask_map
F#arch/x86/mm/pgtable.symtypes physical_mask
F#arch/x86/mm/physaddr.symtypes __virt_addr_valid
F#block/bdev.symtypes I_BDEV bdev_file_open_by_dev bdev_file_open_by_path bdev_fput bdev_freeze bdev_thaw file_bdev s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@93c3ca65 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@73ebe792 s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@4b99ea9b s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d sb_set_blocksize sync_blockdev
F#block/bio-integrity.symtypes bio_integrity_add_page bio_integrity_alloc s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@93c3ca65 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@73ebe792 s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#block/bio.symtypes bio_add_page bio_alloc_bioset bio_endio bio_init bio_put fs_bio_set s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@93c3ca65 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@73ebe792 s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_debugfs_attr@9913c52c s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@e03dedc0 s#blkcg_gq@0386a888 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@353020bc s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#block/blk-core.symtypes bdev_end_io_acct bdev_start_io_acct blk_finish_plug blk_put_queue blk_start_plug kblockd_mod_delayed_work_on s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@93c3ca65 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@73ebe792 s#blk_holder_ops@3d630586 s#blk_mq_ctx@159718d5 s#blk_mq_debugfs_attr@26a35b37 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@e03dedc0 s#blkcg_gq@0386a888 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@4b99ea9b s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@68d4da21 s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d submit_bio
F#block/blk-lib.symtypes blkdev_issue_discard s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@93c3ca65 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@73ebe792 s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#block/blk-mq-cpumap.symtypes blk_mq_map_queues
F#block/blk-mq-pci.symtypes blk_mq_pci_map_queues s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@159718d5 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hotplug_slot@1b7da886 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#pci_dev@0a024d59 s#pci_sriov@8eb10e41 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_dir_entry@615cd3ba s#rcec_ea@e5415a95 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#block/blk-mq-tag.symtypes blk_mq_unique_tag s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@93c3ca65 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@73ebe792 s#blk_holder_ops@3d630586 s#blk_mq_ctx@159718d5 s#blk_mq_debugfs_attr@26a35b37 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@68d4da21 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#block/blk-mq.symtypes __blk_mq_alloc_disk blk_mq_alloc_tag_set blk_mq_complete_request blk_mq_end_request blk_mq_free_tag_set blk_mq_kick_requeue_list blk_mq_requeue_request blk_mq_start_request blk_mq_start_stopped_hw_queues blk_mq_stop_hw_queues s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@93c3ca65 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@73ebe792 s#blk_holder_ops@3d630586 s#blk_mq_ctx@159718d5 s#blk_mq_debugfs_attr@9913c52c s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@e03dedc0 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#disk_stats@4b99ea9b s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@68d4da21 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@3ce04acd s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@353020bc s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#block/blk-settings.symtypes blk_set_stacking_limits blk_stack_limits s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#bio_integrity_payload@93c3ca65 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@73ebe792 s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_debugfs_attr@9913c52c s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#cgroup_subsys_state@9592e946 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@353020bc s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#block/bsg-lib.symtypes bsg_job_done s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bsg_job@e8161648 s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#block/disk-events.symtypes disk_check_media_change s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@93c3ca65 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@73ebe792 s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#block/genhd.symtypes __blk_alloc_disk __register_blkdev del_gendisk device_add_disk put_disk s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@e8137038 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@93c3ca65 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@73ebe792 s#blk_holder_ops@3d630586 s#blk_mq_ctx@159718d5 s#blk_mq_debugfs_attr@9913c52c s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@e03dedc0 s#blkcg_gq@0386a888 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@4b99ea9b s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@68d4da21 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@353020bc s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d set_capacity set_disk_ro unregister_blkdev
F#drivers/base/core.symtypes _dev_err _dev_info _dev_printk _dev_warn dev_driver_string get_device s#Qdisc@ccf40764 s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@b0c59979 s#blk_mq_tag_set@1cc4433c s#blk_mq_tags@78ab9fcb s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_mprog_entry@74c9db46 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cpu_rmap@912b6b64 s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@5250564c s#device@d0b2836c s#device_node@346471e3 s#device_private@38a41b15 s#devlink_port@90deb245 s#dim_irq_moder@73772ab2 s#disk_stats@fa55c981 s#dma_map_ops@299c8cb1 s#dpll_pin@2b16be81 s#driver_private@408764e2 s#dsa_port@258bc0e4 s#dst_entry@d3e7ee36 s#elevator_queue@d35b4dc0 s#ethtool_netdev_state@eff8fd02 s#ethtool_ops@13aaf17f s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@02b05148 s#fib_rules_ops@306a8a75 s#fib_table@c68738ba s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#garp_port@d7d34070 s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#in_device@e840243a s#inet6_dev@fbc129b1 s#inet_hashinfo@b8c86004 s#inet_peer_base@34625d11 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@98b9c64d s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@9f3c7244 s#ip_tunnel_parm_kern@cca4cb16 s#ipv4_devconf@97093f25 s#ipv6_devconf@7893195b s#irq_domain@27204fc0 s#iw_handler_def@c89ad982 s#iw_public_data@41c9989c s#kernel_hwtstamp_config@9fdcb0e7 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#l3mdev_ops@957f97dc s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#macsec_ops@c7967aeb s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mpls_dev@ecb506b0 s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mrp_port@e05e7d57 s#mtd_info@8095bfdb s#ndisc_ops@397a4195 s#neigh_parms@3fe62c7d s#neighbour@8167d134 s#net@c82d40a9 s#net_device@025f9d55 s#net_generic@1d11e6c7 s#netdev_name_node@2ff0458c s#netdev_rx_queue@13c6ee90 s#netns_ipvs@44694bf2 s#netpoll_info@1c74e1ed s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nla_policy@f0766bba s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#phy_device@88a4c771 s#phy_link_topology@dd16f297 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#prot_inuse@df3cc499 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@6ee74121 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#rtnl_link_ops@8affdff9 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#tipc_bearer@55f19674 s#tlsdev_ops@4e0b3003 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#udp_table@fd544100 s#udp_tunnel_nic_info@ae20cdf5 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vlan_info@f17b3f88 s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@c4d4f412 s#watch_list@9efb3bb2 s#wireless_dev@7bc3c537 s#wpan_dev@dcad4f7d s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d s#xdp_buff@e3d549f9 s#xdp_frame@9dbad4b3 s#xdp_metadata_ops@f9442117 s#xfrm_policy@a692f712 s#xfrm_state@92682e23 s#xsk_buff_pool@6a898e0c s#xsk_tx_metadata_ops@35dc8735
F#drivers/char/random.symtypes get_random_bytes s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@b0c59979 s#blk_mq_tag_set@1cc4433c s#blk_mq_tags@78ab9fcb s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request@6ee74121 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@7dd4191c s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#drivers/nvme/host/fc.symtypes nvme_fc_register_localport nvme_fc_register_remoteport nvme_fc_set_remoteport_devloss nvme_fc_unregister_localport nvme_fc_unregister_remoteport s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@e03dedc0 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@581f6d64 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#dst_entry@d3e7ee36 s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@02b05148 s#fib_rules_ops@306a8a75 s#fib_table@c68738ba s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#inet_hashinfo@b8c86004 s#inet_peer_base@34625d11 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@9f3c7244 s#ipv4_devconf@97093f25 s#ipv6_devconf@7893195b s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mtd_info@8095bfdb s#neighbour@8167d134 s#net@c82d40a9 s#net_device@f8d214a7 s#net_generic@1d11e6c7 s#netns_ipvs@44694bf2 s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#prot_inuse@df3cc499 s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#udp_table@fd544100 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#drivers/pci/access.symtypes pci_read_config_word pcie_capability_clear_and_set_word_unlocked s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@a2ebfa8f s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hotplug_slot@1b7da886 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#pci_dev@0a024d59 s#pci_sriov@8a12dbad s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#rcec_ea@44428194 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#drivers/pci/iomap.symtypes pci_iomap s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@a2ebfa8f s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hotplug_slot@1b7da886 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#pci_dev@0a024d59 s#pci_sriov@8eb10e41 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#rcec_ea@e5415a95 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#drivers/pci/msi/api.symtypes e#irqchip_irq_state@8b3c971d pci_alloc_irq_vectors pci_free_irq_vectors pci_irq_vector s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@a2ebfa8f s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hotplug_slot@1b7da886 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_affinity@5ea67367 s#irq_affinity_desc@fe1e4133 s#irq_affinity_notify@2a9cac88 s#irq_data@f61673cf s#irq_domain@634338af s#irq_domain_chip_generic@0d384feb s#irqaction@ba286ba9 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#msi_desc@44af7c7e s#msi_msg@6a0c952c s#msi_parent_ops@145ca724 s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#pci_dev@0a024d59 s#pci_sriov@8eb10e41 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#rcec_ea@e5415a95 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#drivers/pci/pci-driver.symtypes __pci_register_driver e#irqchip_irq_state@8b3c971d pci_unregister_driver s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@96cc726c s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@299c8cb1 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hotplug_slot@1b7da886 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_domain@5cec7dba s#iommu_mm_data@b2cc622d s#iov_iter@aa255615 s#irq_affinity_desc@fe1e4133 s#irq_affinity_notify@2a9cac88 s#irq_data@f61673cf s#irq_domain@634338af s#irq_domain_chip_generic@0d384feb s#irqaction@ba286ba9 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#msi_desc@44af7c7e s#msi_msg@6a0c952c s#msi_parent_ops@145ca724 s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#pci_dev@0a024d59 s#pci_sriov@8a12dbad s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#rcec_ea@44428194 s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#drivers/pci/pci.symtypes e#irqchip_irq_state@8b3c971d pci_disable_device pci_enable_device pci_release_regions pci_request_regions pci_set_master s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@a2ebfa8f s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hotplug_slot@484ea182 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_affinity_desc@fe1e4133 s#irq_affinity_notify@2a9cac88 s#irq_data@f61673cf s#irq_domain@634338af s#irq_domain_chip_generic@0d384feb s#irqaction@ba286ba9 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#msi_desc@44af7c7e s#msi_msg@6a0c952c s#msi_parent_ops@145ca724 s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#pci_dev@0a024d59 s#pci_sriov@8a12dbad s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#rcec_ea@44428194 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#drivers/scsi/hosts.symtypes s#Scsi_Host@b4eb472f s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#scsi_cmnd@d9d0b114 s#scsi_device@3ad13230 s#scsi_device_handler@2fa82fb9 s#scsi_target@aa610dc7 s#scsi_transport_template@4cdd7909 s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d scsi_add_host_with_dma scsi_host_alloc scsi_host_busy scsi_host_put scsi_is_host_device scsi_remove_host
F#drivers/scsi/scsi.symtypes s#Scsi_Host@b4eb472f s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#scsi_cmnd@d9d0b114 s#scsi_device@3ad13230 s#scsi_device_handler@2fa82fb9 s#scsi_target@aa610dc7 s#scsi_transport_template@45ac62e3 s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d scsi_change_queue_depth
F#drivers/scsi/scsi_common.symtypes int_to_scsilun scsi_build_sense_buffer scsi_device_type scsi_normalize_sense
F#drivers/scsi/scsi_lib.symtypes s#Scsi_Host@b4eb472f s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@93c3ca65 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#scsi_cmnd@d9d0b114 s#scsi_device@3ad13230 s#scsi_device_handler@a8de8a13 s#scsi_target@aa610dc7 s#scsi_transport_template@4cdd7909 s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d scsi_block_requests scsi_device_set_state scsi_done scsi_unblock_requests
F#drivers/scsi/scsi_lib_dma.symtypes s#Scsi_Host@b4eb472f s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#scsi_cmnd@d9d0b114 s#scsi_device@3ad13230 s#scsi_device_handler@2fa82fb9 s#scsi_target@aa610dc7 s#scsi_transport_template@45ac62e3 s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d scsi_dma_map scsi_dma_unmap
F#drivers/scsi/scsi_scan.symtypes s#Scsi_Host@b4eb472f s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#scsi_cmnd@d9d0b114 s#scsi_device@3ad13230 s#scsi_device_handler@a8de8a13 s#scsi_target@aa610dc7 s#scsi_transport_template@4cdd7909 s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d scsi_add_device scsi_rescan_device
F#drivers/scsi/scsi_sysfs.symtypes s#Scsi_Host@b4eb472f s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#scsi_cmnd@d9d0b114 s#scsi_device@3ad13230 s#scsi_device_handler@a8de8a13 s#scsi_target@aa610dc7 s#scsi_transport_template@4cdd7909 s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d scsi_remove_device
F#drivers/scsi/scsi_transport_fc.symtypes fc_attach_transport fc_block_scsi_eh fc_eh_timed_out fc_get_event_number fc_host_post_event fc_release_transport fc_remote_port_add fc_remote_port_delete fc_remove_host s#Scsi_Host@b4eb472f s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bsg_job@e8161648 s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#scsi_cmnd@d9d0b114 s#scsi_device@3ad13230 s#scsi_device_handler@2fa82fb9 s#scsi_target@aa610dc7 s#scsi_transport_template@4cdd7909 s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d scsi_is_fc_rport
F#drivers/scsi/scsi_transport_sas.symtypes s#Scsi_Host@b4eb472f s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#badblocks@7e65f071 s#bdi_writeback@6b721080 s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bsg_job@e8161648 s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#scsi_cmnd@d9d0b114 s#scsi_device@3ad13230 s#scsi_device_handler@2fa82fb9 s#scsi_target@aa610dc7 s#scsi_transport_template@4cdd7909 s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d sas_attach_transport sas_end_device_alloc sas_expander_alloc sas_phy_add sas_phy_alloc sas_phy_delete sas_port_add sas_port_add_phy sas_port_alloc_num sas_port_delete sas_port_delete_phy sas_port_free sas_release_transport sas_rphy_add sas_rphy_free
F#fs/attr.symtypes inode_newsize_ok s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@ae8ea715 s#file_lock@31a8bf1f s#file_lock_context@787998e9 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nfs4_lock_state@47003d93 s#nlm_lockowner@c8646510 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d setattr_prepare
F#fs/buffer.symtypes __block_write_full_folio block_invalidate_folio block_write_begin block_write_end free_buffer_head invalidate_inode_buffers s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@892fbd44 s#blk_mq_tag_set@a38af0c6 s#blk_mq_tags@83f6aa16 s#blk_plug@7d226752 s#blk_trace@e03dedc0 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@af8f736c s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@32f16975 s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request@003e27a0 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d u#fscrypt_policy@cc542eb0
F#fs/char_dev.symtypes __register_chrdev __unregister_chrdev alloc_chrdev_region cdev_add cdev_del cdev_init s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@581f6d64 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#serial_icounter_struct@d94a6582 s#serial_struct@0187e4b2 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_driver@1bbe640d s#tty_struct@9bd315b1 s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d unregister_chrdev_region
F#fs/d_path.symtypes d_path dentry_path_raw s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@7d6db402 s#fs_struct@9466df19 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@ced81a6d s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#fs/dcache.symtypes d_add d_alloc d_drop d_find_alias d_instantiate d_invalidate d_lookup d_make_root d_move d_obtain_alias d_prune_aliases d_set_d_op d_splice_alias dget_parent dput names_cachep s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@7d6db402 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@af8f736c s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@ced81a6d s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d u#fscrypt_policy@cc542eb0
F#fs/debugfs/inode.symtypes debugfs_create_dir debugfs_create_file debugfs_remove s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@30a833e5 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#fs/file.symtypes acfs_only_symbol close_fd edv_only_symbol fdget fget fget_raw s#Qdisc@ccf40764 s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_mprog_entry@74c9db46 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cpu_rmap@912b6b64 s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#devlink_port@90deb245 s#dim_irq_moder@73772ab2 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#dpll_pin@2b16be81 s#driver_private@80bd9a0c s#dsa_port@258bc0e4 s#dst_entry@5a2a5794 s#ethtool_netdev_state@eff8fd02 s#ethtool_ops@13aaf17f s#event_filter@89b1689f s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@09b7d66f s#fib_rules_ops@ab0c04da s#fib_table@c68738ba s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@bbbe635b s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#garp_port@d7d34070 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#in_device@e840243a s#inet6_dev@fbc129b1 s#inet_hashinfo@b8c86004 s#inet_peer_base@34625d11 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@9f3c7244 s#ip_tunnel_parm_kern@cca4cb16 s#ipv4_devconf@97093f25 s#ipv6_devconf@7893195b s#irq_domain@27204fc0 s#iw_handler_def@c89ad982 s#iw_public_data@41c9989c s#kernel_hwtstamp_config@0606f718 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#l3mdev_ops@705e73d8 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#lwtunnel_state@c2751f5a s#macsec_ops@c7967aeb s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mpls_dev@ecb506b0 s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mrp_port@e05e7d57 s#mtd_info@8095bfdb s#ndisc_ops@397a4195 s#neigh_parms@19878e97 s#neighbour@b77debc9 s#net@c82d40a9 s#net_device@025f9d55 s#net_generic@1d11e6c7 s#netdev_name_node@2ff0458c s#netdev_rx_queue@13c6ee90 s#netns_ipvs@44694bf2 s#netpoll_info@1c74e1ed s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nla_policy@a743e2ce s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#phy_device@88a4c771 s#phy_link_topology@dd16f297 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#prot_inuse@6e8fe549 s#proto_accept_arg@91662e5f s#raw_hashinfo@98139727 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#request_sock_ops@b37b346c s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#rtnl_link_ops@1c901e6b s#scatterlist@183eecfb s#sched_class@05ccdc2b s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sk_filter@02e5399f s#sk_psock@54c50505 s#sock@c64df4d1 s#sock_fprog_kern@078f369c s#sock_reuseport@1f233d59 s#socket@7480649c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#timewait_sock_ops@e9b123c0 s#tipc_bearer@55f19674 s#tlsdev_ops@4e0b3003 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ubuf_info@f851873b s#ucounts@94c8bcd2 s#udp_table@fd544100 s#udp_tunnel_nic_info@ae20cdf5 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@7dd4191c s#vdso_image@20f1c9bb s#vlan_info@f17b3f88 s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#wireless_dev@7bc3c537 s#wpan_dev@dcad4f7d s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d s#xdp_buff@e3d549f9 s#xdp_frame@9dbad4b3 s#xdp_metadata_ops@f9442117 s#xfrm_policy@a692f712 s#xfrm_state@92682e23 s#xsk_buff_pool@6a898e0c s#xsk_tx_metadata_ops@35dc8735
F#fs/file_table.symtypes fput s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@581f6d64 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@ae8ea715 s#file_lock@31a8bf1f s#file_lock_context@787998e9 s#fileattr@44f677b4 s#files_struct@bbbe635b s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nfs4_lock_state@47003d93 s#nlm_lockowner@c8646510 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#fs/filesystems.symtypes register_filesystem s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@30a833e5 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d unregister_filesystem
F#fs/fs-writeback.symtypes __mark_inode_dirty s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@b0c59979 s#blk_mq_tag_set@1cc4433c s#blk_mq_tags@78ab9fcb s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request@6ee74121 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d write_inode_now
F#fs/fs_context.symtypes fs_context_for_reconfigure put_fs_context s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#dst_entry@d3e7ee36 s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@02b05148 s#fib_rules_ops@306a8a75 s#fib_table@c68738ba s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@30a833e5 s#fs_pin@7d6db402 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#inet_hashinfo@b8c86004 s#inet_peer_base@34625d11 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@9f3c7244 s#ipv4_devconf@97093f25 s#ipv6_devconf@7893195b s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@ced81a6d s#module@7b5e330f s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mtd_info@8095bfdb s#neighbour@8167d134 s#net@c82d40a9 s#net_device@f8d214a7 s#net_generic@1d11e6c7 s#netns_ipvs@44694bf2 s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#prot_inuse@df3cc499 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#udp_table@fd544100 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#fs/inode.symtypes __insert_inode_hash __remove_inode_hash clear_inode drop_nlink igrab inc_nlink init_special_inode inode_init_once iput new_inode s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@581f6d64 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@ae8ea715 s#file_lock@31a8bf1f s#file_lock_context@787998e9 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nfs4_lock_state@47003d93 s#nlm_lockowner@c8646510 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@4d5b1a1c s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d set_nlink
F#fs/ioctl.symtypes fiemap_fill_next_extent fiemap_prep s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@1bed3a83 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@8d2befb0 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@af8f736c s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d u#fscrypt_policy@cc542eb0
F#fs/libfs.symtypes s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@b0c59979 s#blk_mq_tag_set@1cc4433c s#blk_mq_tags@78ab9fcb s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@97c6b0cb s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@af8f736c s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@a449eb34 s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iomap@3288b49c s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@3663e9fd s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request@6ee74121 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d simple_read_from_buffer simple_write_to_buffer u#fscrypt_policy@cc542eb0
F#fs/locks.symtypes __break_lease locks_init_lock locks_lock_inode_wait posix_lock_file posix_test_lock s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@ae8ea715 s#file_lock@31a8bf1f s#file_lock_context@787998e9 s#fileattr@44f677b4 s#files_struct@bbbe635b s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nfs4_lock_state@47003d93 s#nlm_lockowner@c8646510 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#fs/mpage.symtypes mpage_read_folio mpage_readahead mpage_writepages s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@b0c59979 s#blk_mq_tag_set@1cc4433c s#blk_mq_tags@78ab9fcb s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@a449eb34 s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request@6ee74121 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#fs/namei.symtypes done_path_create follow_down_one full_name_hash generic_permission kern_path kern_path_create lock_rename lookup_one_len path_get path_put s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#dst_entry@d3e7ee36 s#event_filter@89b1689f s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@02b05148 s#fib_rules_ops@306a8a75 s#fib_table@c68738ba s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@ae8ea715 s#file_lock@31a8bf1f s#file_lock_context@787998e9 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@7d6db402 s#fs_struct@9466df19 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#inet_hashinfo@b8c86004 s#inet_peer_base@34625d11 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@9f3c7244 s#ipv4_devconf@97093f25 s#ipv6_devconf@7893195b s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@ced81a6d s#module@7b5e330f s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mtd_info@8095bfdb s#neighbour@8167d134 s#net@c82d40a9 s#net_device@f8d214a7 s#net_generic@1d11e6c7 s#netns_ipvs@44694bf2 s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nfs4_lock_state@47003d93 s#nlm_lockowner@c8646510 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@4d5b1a1c s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#prot_inuse@df3cc499 s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#udp_table@fd544100 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@7dd4191c s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d unlock_rename vfs_mkdir vfs_rename vfs_unlink
F#fs/namespace.symtypes mntput s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@30a833e5 s#fs_pin@7d6db402 s#fs_struct@9466df19 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@ced81a6d s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@40742561 s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@9dab2a04 vfs_create_mount
F#fs/open.symtypes filp_close filp_open generic_file_open s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@581f6d64 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@ae8ea715 s#file_lock@31a8bf1f s#file_lock_context@787998e9 s#fileattr@44f677b4 s#files_struct@bbbe635b s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@9466df19 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nfs4_lock_state@47003d93 s#nlm_lockowner@c8646510 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#serial_icounter_struct@d94a6582 s#serial_struct@0187e4b2 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_driver@1bbe640d s#tty_struct@9bd315b1 s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#fs/proc/generic.symtypes proc_create proc_create_data proc_mkdir remove_proc_entry s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@a2ebfa8f s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#coredump_params@c0ae74d4 s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_pagemap@b8b78600 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@c068fab7 s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_dir_entry@5f4e08e8 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#fs/read_write.symtypes default_llseek fixed_size_llseek generic_file_llseek generic_write_checks kernel_read kernel_write s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@bfb6453b s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#watch_queue@abc0efda s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d vfs_iter_read vfs_iter_write vfs_llseek
F#fs/seq_file.symtypes s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@a2ebfa8f s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@d2202b4f s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_pagemap@b8b78600 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@689a97e0 s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@a6dd4e37 s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@779e9ef8 s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d seq_printf
F#fs/splice.symtypes iter_file_splice_write s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@bfb6453b s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#watch_queue@abc0efda s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#fs/stat.symtypes generic_fillattr s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@b0c59979 s#blk_mq_tag_set@1cc4433c s#blk_mq_tags@78ab9fcb s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@7d6db402 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@ced81a6d s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request@6ee74121 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#fs/super.symtypes kill_block_super mount_bdev s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@b0c59979 s#blk_mq_tag_set@1cc4433c s#blk_mq_tags@78ab9fcb s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@af8f736c s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@a449eb34 s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request@6ee74121 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d u#fscrypt_policy@cc542eb0
F#fs/sync.symtypes s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@b0c59979 s#blk_mq_tag_set@1cc4433c s#blk_mq_tags@78ab9fcb s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request@6ee74121 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d vfs_fsync vfs_fsync_range
F#init/init_task.symtypes init_task s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#binfmt_misc@a1efc11e s#bio_list@9189344b s#bio_vec@e60777b1 s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog@3425efb4 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bucket_table@6a272079 s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#cgroup_namespace@b9b52aeb s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_pagemap@b8b78600 s#dst_entry@d3e7ee36 s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@02b05148 s#fib_rules_ops@306a8a75 s#fib_table@c68738ba s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#inet_hashinfo@b8c86004 s#inet_peer_base@34625d11 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@9f3c7244 s#ipv4_devconf@97093f25 s#ipv6_devconf@7893195b s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mtd_info@8095bfdb s#neighbour@8167d134 s#net@c82d40a9 s#net_device@f8d214a7 s#net_generic@1d11e6c7 s#netns_ipvs@44694bf2 s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nsproxy@9767106e s#obj_cgroup@3ce04acd s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#prot_inuse@df3cc499 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#udp_table@fd544100 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@7dd4191c s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#init/main.symtypes reset_devices system_state
F#kernel/capability.symtypes capable s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#kernel/cpu.symtypes __cpu_active_mask __cpu_online_mask __cpu_possible_mask __cpu_present_mask __cpuhp_remove_state __cpuhp_setup_state __num_online_cpus
F#kernel/cred.symtypes __put_cred override_creds prepare_creds prepare_kernel_cred revert_creds s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@14a1c20a s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#coredump_params@c0ae74d4 s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#dst_entry@d3e7ee36 s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@02b05148 s#fib_rules_ops@306a8a75 s#fib_table@c68738ba s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#inet_hashinfo@b8c86004 s#inet_peer_base@34625d11 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@9f3c7244 s#ipv4_devconf@97093f25 s#ipv6_devconf@7893195b s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@c068fab7 s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mtd_info@8095bfdb s#neighbour@8167d134 s#net@c82d40a9 s#net_device@f8d214a7 s#net_generic@1d11e6c7 s#netns_ipvs@44694bf2 s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#prot_inuse@df3cc499 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#udp_table@fd544100 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@7dd4191c s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#kernel/dma/mapping.symtypes dma_alloc_attrs dma_free_attrs dma_map_page_attrs dma_set_coherent_mask dma_set_mask dma_unmap_page_attrs s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2e19c8ab s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@299c8cb1 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@98b9c64d s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#kernel/groups.symtypes in_group_p s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#kernel/irq/chip.symtypes e#irqchip_irq_state@8b3c971d irq_get_irq_data s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@a2ebfa8f s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@ad17fee0 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_affinity_desc@fe1e4133 s#irq_affinity_notify@2a9cac88 s#irq_data@f61673cf s#irq_domain@634338af s#irq_domain_chip_generic@0d384feb s#irqaction@ba286ba9 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#msi_desc@44af7c7e s#msi_msg@6a0c952c s#msi_parent_ops@145ca724 s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@3620399f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#kernel/irq/manage.symtypes e#irqchip_irq_state@8b3c971d free_irq request_threaded_irq s#irq_affinity_notify@2a9cac88
F#kernel/kallsyms.symtypes sprint_symbol
F#kernel/kthread.symtypes kthread_complete_and_exit kthread_create_on_node kthread_should_stop kthread_stop s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#binfmt_misc@14a1c20a s#bio_list@9189344b s#bio_vec@a2ebfa8f s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#coredump_params@c0ae74d4 s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_pagemap@b8b78600 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@c068fab7 s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@3ce04acd s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#kernel/locking/mutex.symtypes __mutex_init mutex_is_locked mutex_lock mutex_trylock mutex_unlock s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#kernel/locking/rwsem.symtypes __init_rwsem down_read down_read_trylock down_write down_write_trylock up_read up_write
F#kernel/locking/semaphore.symtypes down down_interruptible up
F#kernel/locking/spinlock.symtypes _raw_read_lock _raw_read_lock_irqsave _raw_read_unlock _raw_read_unlock_irqrestore _raw_spin_lock _raw_spin_lock_bh _raw_spin_lock_irq _raw_spin_lock_irqsave _raw_spin_unlock _raw_spin_unlock_bh _raw_spin_unlock_irq _raw_spin_unlock_irqrestore _raw_write_lock _raw_write_lock_irqsave _raw_write_unlock _raw_write_unlock_irqrestore
F#kernel/module/main.symtypes __module_get module_put s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@1688e719 s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d try_module_get
F#kernel/panic.symtypes __stack_chk_fail __warn_printk panic
F#kernel/params.symtypes param_ops_charp param_ops_int param_ops_long param_ops_uint s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#kernel/pid.symtypes pid_task s#Qdisc@ccf40764 s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_mprog_entry@74c9db46 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cpu_rmap@912b6b64 s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#devlink_port@90deb245 s#dim_irq_moder@73772ab2 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#dpll_pin@2b16be81 s#driver_private@80bd9a0c s#dsa_port@258bc0e4 s#dst_entry@5a2a5794 s#ethtool_netdev_state@eff8fd02 s#ethtool_ops@13aaf17f s#event_filter@89b1689f s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@09b7d66f s#fib_rules_ops@ab0c04da s#fib_table@c68738ba s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#garp_port@d7d34070 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#in_device@e840243a s#inet6_dev@fbc129b1 s#inet_hashinfo@b8c86004 s#inet_peer_base@34625d11 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@9f3c7244 s#ip_tunnel_parm_kern@cca4cb16 s#ipv4_devconf@97093f25 s#ipv6_devconf@7893195b s#irq_domain@27204fc0 s#iw_handler_def@c89ad982 s#iw_public_data@41c9989c s#kernel_hwtstamp_config@0606f718 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#l3mdev_ops@705e73d8 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#lwtunnel_state@c2751f5a s#macsec_ops@c7967aeb s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mpls_dev@ecb506b0 s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mrp_port@e05e7d57 s#mtd_info@8095bfdb s#ndisc_ops@397a4195 s#neigh_parms@19878e97 s#neighbour@b77debc9 s#net@c82d40a9 s#net_device@025f9d55 s#net_generic@1d11e6c7 s#netdev_name_node@2ff0458c s#netdev_rx_queue@13c6ee90 s#netns_ipvs@44694bf2 s#netpoll_info@1c74e1ed s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nla_policy@a743e2ce s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#phy_device@88a4c771 s#phy_link_topology@dd16f297 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#proc_ns_operations@40742561 s#prot_inuse@6e8fe549 s#proto_accept_arg@91662e5f s#raw_hashinfo@98139727 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#request_sock_ops@b37b346c s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#rtnl_link_ops@1c901e6b s#scatterlist@183eecfb s#sched_class@05ccdc2b s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sk_filter@02e5399f s#sk_psock@54c50505 s#sock@c64df4d1 s#sock_fprog_kern@078f369c s#sock_reuseport@1f233d59 s#socket@7480649c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#timewait_sock_ops@e9b123c0 s#tipc_bearer@55f19674 s#tlsdev_ops@4e0b3003 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ubuf_info@f851873b s#ucounts@94c8bcd2 s#udp_table@fd544100 s#udp_tunnel_nic_info@ae20cdf5 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@7dd4191c s#vdso_image@20f1c9bb s#vlan_info@f17b3f88 s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#wireless_dev@7bc3c537 s#wpan_dev@dcad4f7d s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d s#xdp_buff@e3d549f9 s#xdp_frame@9dbad4b3 s#xdp_metadata_ops@f9442117 s#xfrm_policy@a692f712 s#xfrm_state@92682e23 s#xsk_buff_pool@6a898e0c s#xsk_tx_metadata_ops@35dc8735
F#kernel/printk/printk.symtypes _printk s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@581f6d64 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#printk_buffers@27aff139 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#serial_icounter_struct@d94a6582 s#serial_struct@0187e4b2 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_driver@1bbe640d s#tty_struct@9bd315b1 s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#kernel/printk/printk_safe.symtypes vprintk
F#kernel/reboot.symtypes emergency_restart register_reboot_notifier s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d unregister_reboot_notifier
F#kernel/sched/build_policy.symtypes s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@14a1c20a s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@e9ea2393 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#coredump_params@c0ae74d4 s#cpuidle_state@db91e22a s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@5250564c s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@c068fab7 s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@624278e3 s#rt_mutex_waiter@aa7a31a4 s#sched_class@ed2df786 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@58dfc497 s#task_group@1e8ff265 s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d set_user_nice yield
F#kernel/sched/build_utility.symtypes __init_swait_queue_head __init_waitqueue_head __wake_up add_wait_queue autoremove_wake_function complete finish_wait init_wait_entry prepare_to_wait prepare_to_wait_event prepare_to_wait_exclusive remove_wait_queue s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@14a1c20a s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@e9ea2393 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#coredump_params@c0ae74d4 s#cpuidle_state@0db9253f s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@5250564c s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@c068fab7 s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@624278e3 s#rt_mutex_waiter@aa7a31a4 s#sched_class@ed2df786 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@58dfc497 s#task_group@1e8ff265 s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@7dd4191c s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d wait_for_completion wait_for_completion_interruptible wait_for_completion_io_timeout wait_for_completion_timeout
F#kernel/sched/core.symtypes __SCT__cond_resched __SCT__might_resched __SCT__preempt_schedule default_wake_function io_schedule s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@14a1c20a s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@b0c59979 s#blk_mq_tag_set@1cc4433c s#blk_mq_tags@78ab9fcb s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@e9ea2393 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#coredump_params@c0ae74d4 s#cpuidle_state@0db9253f s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@5250564c s#device@d0b2836c s#device_node@346471e3 s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#dst_entry@d3e7ee36 s#elevator_queue@d35b4dc0 s#event_filter@89b1689f s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@02b05148 s#fib_rules_ops@306a8a75 s#fib_table@c68738ba s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#inet_hashinfo@b8c86004 s#inet_peer_base@34625d11 s#inode@4761f272 s#io_bitmap@fd172377 s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_mapped_ubuf@42ab5e51 s#io_rsrc_data@54f82f1c s#io_rsrc_node@92ed44e3 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@d2aed70f s#io_wq_hash@e3bd1a1d s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@9f3c7244 s#ipv4_devconf@97093f25 s#ipv6_devconf@7893195b s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@c068fab7 s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mtd_info@8095bfdb s#neighbour@8167d134 s#net@c82d40a9 s#net_device@f8d214a7 s#net_generic@1d11e6c7 s#netns_ipvs@44694bf2 s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#prot_inuse@df3cc499 s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request@6ee74121 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@624278e3 s#rq_qos@0cb844b7 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#sched_class@ed2df786 s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@58dfc497 s#task_group@1e8ff265 s#taskstats@ff2eca7f s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#udp_table@fd544100 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@7dd4191c s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d schedule wake_up_process
F#kernel/signal.symtypes flush_signals kill_pid recalc_sigpending s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@14a1c20a s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@581f6d64 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#coredump_params@fb813bbf s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@c068fab7 s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#serial_icounter_struct@d94a6582 s#serial_struct@0187e4b2 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_driver@1bbe640d s#tty_struct@9bd315b1 s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d send_sig sigprocmask
F#kernel/smp.symtypes nr_cpu_ids
F#kernel/softirq.symtypes __tasklet_hi_schedule tasklet_init
F#kernel/time/jiffies.symtypes jiffies
F#kernel/time/time.symtypes __msecs_to_jiffies jiffies_to_msecs jiffies_to_timespec64 jiffies_to_usecs s#old_timespec32@90d4ac33 set_normalized_timespec64 sys_tz
F#kernel/time/timeconv.symtypes time64_to_tm
F#kernel/time/timekeeping.symtypes ktime_get_coarse_real_ts64 ktime_get_coarse_ts64 ktime_get_real_seconds ktime_get_real_ts64 ktime_get_ts64
F#kernel/time/timer.symtypes add_timer init_timer_key mod_timer msleep msleep_interruptible round_jiffies schedule_timeout schedule_timeout_uninterruptible timer_delete_sync usleep_range_state
F#kernel/umh.symtypes call_usermodehelper s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@14a1c20a s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#coredump_params@c0ae74d4 s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@bbbe635b s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@9466df19 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@c068fab7 s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#kernel/user_namespace.symtypes from_kgid from_kuid make_kgid make_kuid s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@9466df19 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_pkey_params@96107994 s#kernel_pkey_query@dc358d8c s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@d979dd54 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@40742561 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#kernel/workqueue.symtypes __flush_workqueue alloc_workqueue cancel_delayed_work_sync delayed_work_timer_fn destroy_workqueue queue_delayed_work_on queue_work_on system_wq
F#lib/bcd.symtypes _bin2bcd
F#lib/bitmap.symtypes __bitmap_weight s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@a2ebfa8f s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@ad17fee0 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@3620399f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#lib/dump_stack.symtypes dump_stack
F#lib/find_bit.symtypes _find_first_and_bit _find_first_bit _find_next_bit
F#lib/iomap.symtypes ioread32 ioread8 iowrite32 s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@a2ebfa8f s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hotplug_slot@1b7da886 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#pci_dev@0a024d59 s#pci_sriov@8eb10e41 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#rcec_ea@e5415a95 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#lib/iov_iter.symtypes iov_iter_bvec iov_iter_get_pages2 iov_iter_init iov_iter_kvec iov_iter_npages s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@e60777b1 s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_pagemap@b8b78600 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@29d56ea4 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@689a97e0 s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@bfb6453b s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#readahead_control@489c99e4 s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@a6dd4e37 s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@402c95c4 s#watch_list@9efb3bb2 s#watch_queue@abc0efda s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d
F#lib/kstrtox.symtypes kstrtoint kstrtou8 kstrtoull
F#lib/list_debug.symtypes __list_add_valid_or_report __list_del_entry_valid_or_report
F#lib/lockref.symtypes lockref_get
F#lib/parser.symtypes match_token
F#lib/scatterlist.symtypes s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@e60777b1 s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@d2202b4f s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_pagemap@b8b78600 s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@29d56ea4 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@689a97e0 s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#scatterlist@183eecfb s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sg_table@81d73f88 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@a6dd4e37 s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@779e9ef8 s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d sg_copy_from_buffer sg_copy_to_buffer sg_next
F#lib/string.symtypes memcmp sized_strscpy strchr strcmp strcpy strlcat strlen strncmp strncpy strnlen strrchr strsep strspn strstr
F#lib/string_helpers.symtypes __fortify_panic s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@338fca9c s#bdi_writeback@6b721080 s#bio_list@9189344b s#bio_vec@a2ebfa8f s#blk_plug@e2161b61 s#block_device@3ea0352f s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@ec9d5f7b s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@90aef3e2 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@3b7d487b s#mempolicy@66376883 s#mm_struct@92a23cf0 s#module@7b5e330f s#mtd_info@8095bfdb s#nsproxy@170c24b3 s#obj_cgroup@3ce04acd s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9afb65e4 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@43548338 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@ce8044bf s#uprobe_task@d5702d22 s#user_namespace@e4129c73 s#userfaultfd_ctx@37162c45 s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@480d8bf2 s#xattr_handler@16eddf4d strim
F#lib/strncpy_from_user.symtypes strncpy_from_user
F#lib/usercopy.symtypes _copy_from_user _copy_to_user check_zeroed_user
F#lib/vsprintf.symtypes scnprintf simple_strtol simple_strtoull snprintf sprintf sscanf vscnprintf vsnprintf vsprintf
F#lib/xarray.symtypes s#list_lru@a08e643b xa_find xa_find_after xa_load
F#mm/filemap.symtypes __folio_lock __generic_file_write_iter filemap_fault filemap_fdatawait_range filemap_fdatawrite filemap_fdatawrite_range filemap_flush filemap_get_folios_tag filemap_splice_read filemap_write_and_wait_range folio_unlock folio_wait_bit generic_file_direct_write generic_file_read_iter read_cache_folio s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#array_buffer@3614c36d s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@30a833e5 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@bfb6453b s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@58dfc497 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#watch_queue@abc0efda s#writeback_control@ac4b7257 s#xattr_handler@9dab2a04
F#mm/folio-compat.symtypes clear_page_dirty_for_io end_page_writeback grab_cache_page_write_begin redirty_page_for_writepage s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d set_page_dirty set_page_writeback unlock_page
F#mm/gup.symtypes get_user_pages s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@30a833e5 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@9dab2a04
F#mm/hugetlb_vmemmap.symtypes hugetlb_optimize_vmemmap_key
F#mm/memory.symtypes remap_pfn_range s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@58dfc497 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d unmap_mapping_range
F#mm/mempolicy.symtypes alloc_pages_noprof s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#mm/mempool.symtypes mempool_alloc_noprof mempool_alloc_slab mempool_create_node_noprof mempool_destroy mempool_free mempool_free_slab
F#mm/memremap.symtypes __put_devmap_managed_folio_refs devmap_managed_key s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@61b69476 s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#mm/mmap.symtypes find_vma s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#array_buffer@3614c36d s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@30a833e5 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@9dab2a04 vm_munmap
F#mm/mmap_lock.symtypes __mmap_lock_do_trace_acquire_returned __mmap_lock_do_trace_released __mmap_lock_do_trace_start_locking __tracepoint_mmap_lock_acquire_returned __tracepoint_mmap_lock_released __tracepoint_mmap_lock_start_locking s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#mm/page-writeback.symtypes filemap_dirty_folio folio_mark_dirty s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#badblocks@7e65f071 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_flush_queue@4aaf6b7c s#blk_holder_ops@3d630586 s#blk_mq_ctx@a9e7a7e1 s#blk_mq_ops@b0c59979 s#blk_mq_tag_set@1cc4433c s#blk_mq_tags@78ab9fcb s#blk_plug@7d226752 s#blk_trace@ed399ad7 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cdrom_device_info@edfd2f7d s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#elevator_queue@d35b4dc0 s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@89751274 s#hd_geometry@1fae69fd s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@ea2dcf26 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@7f1b6f92 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#pr_ops@43a01d23 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request@6ee74121 s#request_queue@75629dc9 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rq_qos@0cb844b7 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d tag_pages_for_writeback
F#mm/page_alloc.symtypes __free_pages free_pages get_free_pages_noprof node_states numa_node s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@58dfc497 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#mm/percpu.symtypes free_percpu pcpu_alloc_noprof
F#mm/show_mem.symtypes _totalram_pages si_meminfo
F#mm/slab_common.symtypes __kmem_cache_create_args kmalloc_caches kmem_cache_destroy random_kmalloc_seed s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@98b9c64d s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@628730d2 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#mm/slub.symtypes __kmalloc_cache_noprof __kmalloc_large_node_noprof __kmalloc_large_noprof __kmalloc_noprof kfree kmem_cache_alloc_noprof kmem_cache_free s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_local_storage@0f78b271 s#bpf_net_context@9b7e8a68 s#bpf_prog_array@b5d94ddc s#bpf_run_ctx@2d1ee41d s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@628730d2 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@b304f10d s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#mm/swap.symtypes __folio_put release_pages s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d
F#mm/truncate.symtypes invalidate_mapping_pages s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@30a833e5 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@b3ae8fa5 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@9dab2a04 truncate_inode_pages truncate_inode_pages_final truncate_inode_pages_range truncate_pagecache truncate_setsize
F#mm/usercopy.symtypes __check_object_size
F#mm/util.symtypes s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@a449eb34 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@ff0e459e s#pollfd@9600d34e s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d vm_mmap
F#mm/vmalloc.symtypes __vmalloc_noprof is_vmalloc_addr s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@19f7762e s#array_buffer@3614c36d s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bus_dma_region@2684f1cf s#capture_control@6270f693 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#driver_private@80bd9a0c s#event_filter@89b1689f s#export_operations@96518368 s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#irq_domain@27204fc0 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mtd_info@8095bfdb s#net@be3f1911 s#net_device@f8d214a7 s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_ns_operations@d97ed1ec s#readahead_control@489c99e4 s#reclaim_state@038189e0 s#request_queue@4916233f s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt_mutex_waiter@aa7a31a4 s#sched_class@05ccdc2b s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sock@25784684 s#sock_fprog_kern@078f369c s#static_call_mod@47e5f6aa s#swap_info_struct@568371c0 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#time_namespace@dc9d28a7 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ucounts@94c8bcd2 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@d2776060 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@402c95c4 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d vfree vmalloc_node_noprof vmalloc_noprof vmalloc_to_page vzalloc_node_noprof vzalloc_noprof
F#net/core/net_namespace.symtypes init_net s#Qdisc@ccf40764 s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_mprog_entry@74c9db46 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cpu_rmap@912b6b64 s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#devlink_port@90deb245 s#dim_irq_moder@73772ab2 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#dpll_pin@2b16be81 s#driver_private@80bd9a0c s#dsa_port@258bc0e4 s#dst_entry@5a2a5794 s#ethtool_netdev_state@eff8fd02 s#ethtool_ops@13aaf17f s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@09b7d66f s#fib_rules_ops@ab0c04da s#fib_table@c68738ba s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#garp_port@d7d34070 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#in_device@e840243a s#inet6_dev@fbc129b1 s#inet_hashinfo@b8c86004 s#inet_peer_base@34625d11 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@9f3c7244 s#ip_tunnel_parm_kern@cca4cb16 s#ipv4_devconf@97093f25 s#ipv6_devconf@7893195b s#irq_domain@27204fc0 s#iw_handler_def@c89ad982 s#iw_public_data@41c9989c s#kernel_hwtstamp_config@0606f718 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#l3mdev_ops@705e73d8 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#lwtunnel_state@c2751f5a s#macsec_ops@c7967aeb s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mpls_dev@ecb506b0 s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mrp_port@e05e7d57 s#mtd_info@8095bfdb s#ndisc_ops@397a4195 s#neigh_parms@19878e97 s#neighbour@b77debc9 s#net@c82d40a9 s#net_device@025f9d55 s#net_generic@395da95a s#netdev_name_node@2ff0458c s#netdev_rx_queue@13c6ee90 s#netns_ipvs@44694bf2 s#netpoll_info@1c74e1ed s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nla_policy@a743e2ce s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#phy_device@88a4c771 s#phy_link_topology@dd16f297 s#pid@8fb1b168 s#pid_namespace@987b78a4 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#proc_ns_operations@40742561 s#prot_inuse@6e8fe549 s#proto_accept_arg@91662e5f s#raw_hashinfo@98139727 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#request_sock_ops@b37b346c s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#rtnl_link_ops@1c901e6b s#scatterlist@183eecfb s#sched_class@05ccdc2b s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sk_filter@02e5399f s#sk_psock@54c50505 s#sock@c64df4d1 s#sock_fprog_kern@078f369c s#sock_reuseport@1f233d59 s#socket@7480649c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#timewait_sock_ops@e9b123c0 s#tipc_bearer@55f19674 s#tlsdev_ops@4e0b3003 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ubuf_info@f851873b s#ucounts@94c8bcd2 s#udp_table@fd544100 s#udp_tunnel_nic_info@ae20cdf5 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vlan_info@f17b3f88 s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#wireless_dev@7bc3c537 s#wpan_dev@dcad4f7d s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d s#xdp_buff@e3d549f9 s#xdp_frame@9dbad4b3 s#xdp_metadata_ops@f9442117 s#xfrm_policy@a692f712 s#xfrm_state@92682e23 s#xsk_buff_pool@6a898e0c s#xsk_tx_metadata_ops@35dc8735
F#net/core/sock.symtypes s#Qdisc@d0f221a6 s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@f169a0d9 s#bpf_func_state@447aa7ab s#bpf_local_storage@d5cd3a20 s#bpf_local_storage_map@0560b78d s#bpf_mprog_entry@74c9db46 s#bpf_net_context@d59fc2a3 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@d55a211d s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cpu_rmap@912b6b64 s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#devlink_port@90deb245 s#dim_irq_moder@73772ab2 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#dpll_pin@2b16be81 s#driver_private@80bd9a0c s#dsa_port@258bc0e4 s#dst_entry@5a2a5794 s#ethtool_eth_phy_stats@e5a790c1 s#ethtool_link_ext_stats@42f8b2c9 s#ethtool_netdev_state@6330f982 s#ethtool_ops@1d1dba04 s#export_operations@96518368 s#fib6_info@2d942774 s#fib6_nh@58738b2a s#fib6_table@d9bdc901 s#fib_notifier_ops@09b7d66f s#fib_rules_ops@ab0c04da s#fib_table@d7877c9d s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_ops@83508898 s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#garp_port@d7d34070 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#in_device@e840243a s#inet6_dev@2fdc6d2e s#inet_hashinfo@f8eabb77 s#inet_peer_base@b794a578 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@b9bbe5c8 s#ip_tunnel_parm_kern@cca4cb16 s#ipv4_devconf@97093f25 s#ipv6_devconf@b2d0f0de s#irq_domain@27204fc0 s#iw_handler_def@c89ad982 s#iw_public_data@41c9989c s#kernel_hwtstamp_config@0606f718 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#l3mdev_ops@705e73d8 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#lwtunnel_state@e718e16c s#macsec_ops@c7967aeb s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mpls_dev@ecb506b0 s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mrp_port@e05e7d57 s#mtd_info@8095bfdb s#ndisc_ops@5f578ea9 s#neigh_parms@19878e97 s#neighbour@b77debc9 s#net@c82d40a9 s#net_device@025f9d55 s#net_generic@1d11e6c7 s#netdev_name_node@7621124b s#netdev_rx_queue@13c6ee90 s#netns_ipvs@44694bf2 s#netpoll_info@1c74e1ed s#nexthop@fa8f6e55 s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nla_policy@a743e2ce s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_event@82b204da s#perf_event_context@11805577 s#phy_device@88a4c771 s#phy_link_topology@dd16f297 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#prefix_info@8e275acb s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#prot_inuse@6e8fe549 s#proto_accept_arg@91662e5f s#qdisc_walker@0594779d s#raw_hashinfo@98139727 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#request_sock@e1990980 s#request_sock_ops@ec1ce132 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt6_info@c74dcddd s#rt6_statistics@553b91e2 s#rt_mutex_waiter@aa7a31a4 s#rtnl_link_ops@1c901e6b s#scatterlist@183eecfb s#sched_class@05ccdc2b s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sk_filter@201051b1 s#sk_psock@54c50505 s#sock@c64df4d1 s#sock_fprog_kern@51f2cd25 s#sock_reuseport@36c358d9 s#socket@7480649c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#tcf_exts@805dd0ca s#tcf_walker@58fadffa s#tcp_congestion_ops@f68d33a2 s#tcp_fastopen_context@6f553f23 s#time_namespace@dc9d28a7 s#timewait_sock_ops@85121b0a s#tipc_bearer@55f19674 s#tlsdev_ops@4e0b3003 s#trace_eval_map@b76c02a9 s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ubuf_info@f851873b s#ucounts@94c8bcd2 s#udp_table@fd544100 s#udp_tunnel_nic_info@ae20cdf5 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vlan_info@f17b3f88 s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#wireless_dev@7bc3c537 s#wpan_dev@dcad4f7d s#writeback_control@ac4b7257 s#xattr_handler@16eddf4d s#xdp_buff@824aab4a s#xdp_frame@87db4985 s#xdp_metadata_ops@ed3230e7 s#xfrm_policy@f23b9978 s#xfrm_state@9fe0fb67 s#xsk_buff_pool@6a898e0c s#xsk_tx_metadata_ops@35dc8735 sock_setsockopt u#tcp_cc_info@270739f8
F#net/socket.symtypes kernel_accept kernel_recvmsg kernel_sendmsg s#Qdisc@d0f221a6 s#acpi_device_id@893be69a s#address_space@c94b877f s#anon_vma@ca7d7321 s#array_buffer@3614c36d s#audit_context@382c83ee s#audit_names@7d86a629 s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@f169a0d9 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_mprog_entry@74c9db46 s#bpf_net_context@d59fc2a3 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@d55a211d s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@581f6d64 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cpu_rmap@912b6b64 s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#devlink_port@90deb245 s#dim_irq_moder@73772ab2 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#dpll_pin@2b16be81 s#driver_private@80bd9a0c s#dsa_port@258bc0e4 s#dst_entry@5a2a5794 s#ethtool_eth_phy_stats@e5a790c1 s#ethtool_link_ext_stats@42f8b2c9 s#ethtool_netdev_state@6330f982 s#ethtool_ops@1d1dba04 s#event_filter@89b1689f s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@09b7d66f s#fib_rules_ops@ab0c04da s#fib_table@d7877c9d s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@e8c933d7 s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@1e0318bf s#fsnotify_sb_info@c7b3898e s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#garp_port@d7d34070 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#in_device@e840243a s#inet6_dev@2fdc6d2e s#inet_hashinfo@b8c86004 s#inet_peer_base@b794a578 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@b9bbe5c8 s#ip_tunnel_parm_kern@cca4cb16 s#ipv4_devconf@97093f25 s#ipv6_devconf@b2d0f0de s#irq_domain@27204fc0 s#iw_handler_def@2758a185 s#iw_public_data@301f3163 s#kernel_hwtstamp_config@0606f718 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#l3mdev_ops@705e73d8 s#ldt_struct@408584e6 s#libipw_device@70ed142f s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#lwtunnel_state@e718e16c s#macsec_ops@c7967aeb s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mpls_dev@ecb506b0 s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mrp_port@e05e7d57 s#mtd_info@8095bfdb s#ndisc_ops@5f578ea9 s#neigh_parms@19878e97 s#neighbour@b77debc9 s#net@c82d40a9 s#net_bridge@1c7c5eb7 s#net_device@025f9d55 s#net_generic@1d11e6c7 s#netdev_name_node@2ff0458c s#netdev_rx_queue@13c6ee90 s#netns_ipvs@44694bf2 s#netpoll_info@1c74e1ed s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@eb89433b s#nf_logger@bdabd2f7 s#nla_policy@a743e2ce s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@8080a399 s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#phy_device@88a4c771 s#phy_link_topology@dd16f297 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@bfb6453b s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#prefix_info@8e275acb s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#prot_inuse@6e8fe549 s#proto_accept_arg@91662e5f s#qdisc_walker@0594779d s#raw_hashinfo@98139727 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#request_sock@e1990980 s#request_sock_ops@ec1ce132 s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#rtnl_link_ops@1c901e6b s#scatterlist@183eecfb s#sched_class@05ccdc2b s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sk_filter@201051b1 s#sk_psock@54c50505 s#sock@c64df4d1 s#sock_fprog_kern@51f2cd25 s#sock_reuseport@1f233d59 s#socket@7480649c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#tcf_exts@805dd0ca s#tcf_walker@58fadffa s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#timewait_sock_ops@85121b0a s#tipc_bearer@55f19674 s#tlsdev_ops@4e0b3003 s#trace_array@0621e4a4 s#trace_eval_map@b76c02a9 s#trace_event_call@1d2f948f s#tracer@3969359b s#tty_struct@71ff2bce s#ubuf_info@f851873b s#ucounts@94c8bcd2 s#udp_table@fd544100 s#udp_tunnel_nic_info@ae20cdf5 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vlan_info@f17b3f88 s#vm_operations_struct@edf46a8f s#vm_struct@61a4eee6 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#watch_queue@abc0efda s#wireless_dev@7bc3c537 s#wpan_dev@dcad4f7d s#writeback_control@ac4b7257 s#xattr_handler@9dab2a04 s#xdp_buff@824aab4a s#xdp_frame@87db4985 s#xdp_metadata_ops@ed3230e7 s#xfrm_policy@a692f712 s#xfrm_state@92682e23 s#xsk_buff_pool@6a898e0c s#xsk_tx_metadata_ops@35dc8735 sock_create_kern sock_release sockfd_lookup
F#security/security.symtypes s#Qdisc@ccf40764 s#acpi_device_id@e58a0b4f s#address_space@c94b877f s#anon_vma@ca7d7321 s#audit_context@382c83ee s#backing_dev_info@bd4ed559 s#bdi_writeback@f123c24b s#binfmt_misc@a1efc11e s#bio_integrity_payload@5dd98af2 s#bio_list@d0a28660 s#bio_vec@e60777b1 s#blk_holder_ops@4f0b2a12 s#blk_plug@e2161b61 s#blkcg_gq@5d57e740 s#block_device@8db9437c s#bpf_cgroup_storage@080bca65 s#bpf_func_state@447aa7ab s#bpf_local_storage@0f78b271 s#bpf_local_storage_map@17d09388 s#bpf_mprog_entry@74c9db46 s#bpf_net_context@9b7e8a68 s#bpf_prog@abd92cca s#bpf_prog_array@c2d10354 s#bpf_prog_stats@6734514e s#bpf_run_ctx@ef4d0a5d s#bpf_verifier_env@5cd2267a s#bucket_table@6a272079 s#bus_dma_region@2684f1cf s#can_dev_rcv_lists@f9a3495b s#can_pkg_stats@b6fbe87d s#can_rcv_lists_stats@7dc788d5 s#capture_control@e8ae89d1 s#cdev@69ffcaf2 s#cfs_rq@b985a5b8 s#cgroup@49126c15 s#cgroup_namespace@5ac1c800 s#cgroup_subsys_state@ffe2cd4b s#cgroup_taskset@1a4c4a87 s#compat_robust_list_head@320188e6 s#completion@136faf3e s#cpu_rmap@912b6b64 s#cred@94bccd5d s#css_set@6c95c1f1 s#dentry@1963d644 s#dev_iommu@6b28d4e3 s#dev_pagemap@b8b78600 s#dev_pin_info@74d04f18 s#dev_pm_qos@4a00fc73 s#device@d0b2836c s#device_node@26a212ba s#device_private@95088762 s#devlink_port@90deb245 s#dim_irq_moder@73772ab2 s#disk_stats@fa55c981 s#dma_map_ops@b53ba484 s#dpll_pin@2b16be81 s#driver_private@80bd9a0c s#dsa_port@258bc0e4 s#dst_entry@5a2a5794 s#ethtool_netdev_state@eff8fd02 s#ethtool_ops@13aaf17f s#event_filter@89b1689f s#export_operations@96518368 s#fib6_info@efeac2b6 s#fib6_table@9726e4a6 s#fib_notifier_ops@09b7d66f s#fib_rules_ops@ab0c04da s#fib_table@c68738ba s#fiemap_extent_info@672844d2 s#file@76e9f396 s#file_lease@3afc3356 s#file_lock@c34f1df2 s#file_lock_context@59edc797 s#fileattr@44f677b4 s#files_struct@8536a667 s#folio_queue@17dee850 s#fs_context@dc4237ee s#fs_parameter_spec@2dfde979 s#fs_pin@cb017644 s#fs_struct@b5890d40 s#fscrypt_inode_info@65e93c4c s#fscrypt_operations@8c0aa70b s#fsnotify_mark_connector@d56ec019 s#fsnotify_sb_info@1ef4c56a s#fsverity_info@ecc2a868 s#fsverity_operations@ba45af4c s#ftrace_hash@302dc061 s#ftrace_ops@393d5fad s#fwnode_handle@f1692138 s#fwnode_reference_args@b4532ede s#garp_port@d7d34070 s#gendisk@e24151d3 s#hrtimer_clock_base@65ed4b96 s#in6_addr@52a16b22 s#in_device@e840243a s#inet6_dev@fbc129b1 s#inet_hashinfo@b8c86004 s#inet_peer_base@34625d11 s#inode@4761f272 s#io_bitmap@ce3b45cd s#io_comp_batch@dd097e59 s#io_context@e59e5b32 s#io_tlb_mem@5df2ff14 s#io_uring_cmd@1826dcda s#io_uring_task@e43ec8a1 s#ioam6_pernet_data@8c68a5b8 s#iommu_mm_data@7eced742 s#iov_iter@aa255615 s#ip_ra_chain@9f3c7244 s#ip_tunnel_parm_kern@cca4cb16 s#ipv4_devconf@97093f25 s#ipv6_devconf@7893195b s#irq_domain@27204fc0 s#iw_handler_def@c89ad982 s#iw_public_data@41c9989c s#kernel_hwtstamp_config@0606f718 s#kernel_symbol@93dc0cff s#kernfs_iattrs@58e69d36 s#kernfs_root@36eeb110 s#key@daa923af s#key_type@856c83c0 s#key_user@35e5d8d6 s#kmem_cache@bb73f614 s#kobject@1a5ace0a s#kstatfs@195c0481 s#l3mdev_ops@705e73d8 s#ldt_struct@408584e6 s#linux_binfmt@aef01ecd s#list_lru@45bb0e2c s#lwtunnel_state@c2751f5a s#macsec_ops@c7967aeb s#mem_cgroup@bdd3f063 s#mempolicy@66376883 s#mm_struct@92a23cf0 s#mnt_namespace@13467d86 s#module@7b5e330f s#mpls_dev@ecb506b0 s#mpls_route@6bce9b55 s#mptcp_mib@32deb1cd s#mrp_port@e05e7d57 s#mtd_info@8095bfdb s#ndisc_ops@397a4195 s#neigh_parms@19878e97 s#neighbour@b77debc9 s#net@c82d40a9 s#net_device@025f9d55 s#net_generic@1d11e6c7 s#netdev_name_node@2ff0458c s#netdev_rx_queue@13c6ee90 s#netns_ipvs@44694bf2 s#netpoll_info@1c74e1ed s#nf_ct_event_notifier@6bfe66ad s#nf_hook_entries@68c7f280 s#nf_logger@bdabd2f7 s#nla_policy@a743e2ce s#nsproxy@9767106e s#obj_cgroup@a1dd039f s#of_device_id@fae262dc s#old_timespec32@90d4ac33 s#page@d8865f34 s#page_pool@2edb243b s#partition_meta_info@781d7eb3 s#perf_buffer@f69550cf s#perf_event@61b8f7ed s#perf_event_context@b070ac91 s#phy_device@88a4c771 s#phy_link_topology@dd16f297 s#pid@8fb1b168 s#pid_namespace@949a5140 s#pipe_inode_info@b8d1ccf7 s#poll_table_struct@8d8f3878 s#pollfd@b58156ac s#posix_acl@a4ffd084 s#proc_dir_entry@615cd3ba s#proc_ns_operations@d97ed1ec s#prot_inuse@6e8fe549 s#proto_accept_arg@91662e5f s#raw_hashinfo@98139727 s#readahead_control@81e0c38a s#reclaim_state@8708b031 s#request_queue@4916233f s#request_sock@b3c35828 s#request_sock_ops@b37b346c s#robust_list_head@0e27a833 s#rq@defa9c61 s#rt6_info@ba0d0e7c s#rt6_statistics@1738033f s#rt_mutex_waiter@aa7a31a4 s#rtnl_link_ops@1c901e6b s#scatterlist@183eecfb s#sched_class@05ccdc2b s#sctp_association@4cb416a1 s#sctp_mib@9b8f12f8 s#seg6_pernet_data@eb2e9422 s#seq_file@9257e8df s#seq_operations@af352468 s#sighand_struct@7ec6c431 s#signal_struct@a77b7a0b s#sk_buff@6b30ccf8 s#sk_filter@02e5399f s#sk_psock@54c50505 s#sock@c64df4d1 s#sock_fprog_kern@078f369c s#sock_reuseport@1f233d59 s#socket@7480649c s#static_call_mod@47e5f6aa s#swap_info_struct@a9138d45 s#task_delay_info@57aa8129 s#task_group@4547b22f s#taskstats@ff2eca7f s#tcp_congestion_ops@a057e2b5 s#tcp_fastopen_context@8c605e6d s#time_namespace@dc9d28a7 s#timewait_sock_ops@e9b123c0 s#tipc_bearer@55f19674 s#tlsdev_ops@4e0b3003 s#trace_eval_map@2ac6e30f s#trace_event_call@943b33bd s#tty_struct@71ff2bce s#ubuf_info@f851873b s#ucounts@94c8bcd2 s#udp_table@fd544100 s#udp_tunnel_nic_info@ae20cdf5 s#uprobe_task@d5702d22 s#user_namespace@bf1c3b98 s#userfaultfd_ctx@37162c45 s#uts_namespace@d3e2a34d s#vdso_image@20f1c9bb s#vlan_info@f17b3f88 s#vm_operations_struct@edf46a8f s#vm_struct@b8b98380 s#wait_page_queue@779e9ef8 s#wake_irq@491e180a s#watch_list@9efb3bb2 s#wireless_dev@7bc3c537 s#wpan_dev@dcad4f7d s#writeback_control@ac4b7257 s#xattr_handler@9dab2a04 s#xdp_buff@e3d549f9 s#xdp_frame@9dbad4b3 s#xdp_metadata_ops@f9442117 s#xfrm_policy@a692f712 s#xfrm_state@92682e23 s#xsk_buff_pool@6a898e0c s#xsk_tx_metadata_ops@35dc8735 security_inode_init_security
